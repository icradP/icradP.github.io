<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>linux基础10 | 进程控制函数补充 | icrad的博客</title><meta name="keywords" content="linux"><meta name="author" content="Icrad"><meta name="copyright" content="Icrad"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程是操作系统调度的最小的单位进程的控制函数进程的控制函数大概可以这样分类  创建 fork exec系   结束 正常, 意外,出现意外就需要对意外进行控制处理。   控制 保存环境。内存， 信号量等环境处理，响应。   信息 比如什么getpid之类的   结束后的处理。  创建创建进程提供了很多函数 最多的常用的EXEC 系列函数 不过EXEC 并不是真正的创建一个进程，exec会将 系统给">
<meta property="og:type" content="article">
<meta property="og:title" content="linux基础10 | 进程控制函数补充">
<meta property="og:url" content="https://www.icrad.top/2023/03/23/linux10/index.html">
<meta property="og:site_name" content="icrad的博客">
<meta property="og:description" content="进程是操作系统调度的最小的单位进程的控制函数进程的控制函数大概可以这样分类  创建 fork exec系   结束 正常, 意外,出现意外就需要对意外进行控制处理。   控制 保存环境。内存， 信号量等环境处理，响应。   信息 比如什么getpid之类的   结束后的处理。  创建创建进程提供了很多函数 最多的常用的EXEC 系列函数 不过EXEC 并不是真正的创建一个进程，exec会将 系统给">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2023-03-22T16:00:00.000Z">
<meta property="article:modified_time" content="2023-03-25T08:25:06.140Z">
<meta property="article:author" content="Icrad">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="http://q1.qlogo.cn/g?b=qq&nk=972791158&s=100"><link rel="canonical" href="https://www.icrad.top/2023/03/23/linux10/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux基础10 | 进程控制函数补充',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-03-25 16:25:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://q1.qlogo.cn/g?b=qq&amp;nk=972791158&amp;s=100" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 兴趣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-palette"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">icrad的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 兴趣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-palette"></i><span> 绘画</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">linux基础10 | 进程控制函数补充</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-22T16:00:00.000Z" title="发表于 2023-03-23 00:00:00">2023-03-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-25T08:25:06.140Z" title="更新于 2023-03-25 16:25:06">2023-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux/">linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="linux基础10 | 进程控制函数补充"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="进程是操作系统调度的最小的单位"><a href="#进程是操作系统调度的最小的单位" class="headerlink" title="进程是操作系统调度的最小的单位"></a>进程是操作系统调度的最小的单位</h1><h1 id="进程的控制函数"><a href="#进程的控制函数" class="headerlink" title="进程的控制函数"></a>进程的控制函数</h1><p>进程的控制函数大概可以这样分类</p>
<ul>
<li>创建<ul>
<li>fork</li>
<li>exec系</li>
</ul>
</li>
<li>结束<ul>
<li>正常,</li>
<li>意外,出现意外就需要对意外进行控制处理。</li>
</ul>
</li>
<li>控制<ul>
<li>保存环境。内存， 信号量等环境处理，响应。</li>
</ul>
</li>
<li>信息<ul>
<li>比如什么getpid之类的</li>
</ul>
</li>
<li>结束后的处理。</li>
</ul>
<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建进程提供了很多函数</p>
<p>最多的常用的EXEC 系列函数</p>
<p>不过EXEC 并不是真正的创建一个进程，exec会将 系统给当前进程分配的内存空间内存（用户区，比如什么.data段啦，.bss段啦之类的。替代码区等待），进行一个重新赋值替换，然而PCB 进程控制块区域不变（在系统内核区部分）</p>
<p>换核不换壳，该进程的pid ppid都不变</p>
<p>真正创建进程的这是fork函数。</p>
<h2 id="EXEC系列"><a href="#EXEC系列" class="headerlink" title="EXEC系列"></a>EXEC系列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><ul>
<li><p>const char * pathname </p>
<ul>
<li>执行文件的路径，不过只可以输入绝对路径。</li>
</ul>
</li>
<li>const char *arg<ul>
<li>第一个参数 默认填写程序自身。 第二个参数如果没有填NULL，因为默认NULL 结束</li>
</ul>
</li>
</ul>
<h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><ul>
<li>const char* file<ul>
<li>执行文件的路径，可以绝对也可以相对，相对位置为当前程序所在位置. 函数名上的p也可以体现</li>
</ul>
</li>
<li>const char*arg<ul>
<li>同上没有变化，命名l的原因，va_list 的L</li>
<li>执行参数 ，如果没有则为NULL；</li>
</ul>
</li>
</ul>
<h3 id="execle"><a href="#execle" class="headerlink" title="execle"></a>execle</h3><ul>
<li>const char * pathname <ul>
<li>执行文件的绝对路径</li>
</ul>
</li>
<li>const char* arg<ul>
<li>同上，以（char *）null结束</li>
</ul>
</li>
<li>char * const envp[]<ul>
<li>环境变量（输入参数），可以自行设定执行文件程序的所携带的环境变量。</li>
</ul>
</li>
</ul>
<h3 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h3><ul>
<li>const char * pathname <ul>
<li>执行文件的路径，不过只可以输入绝对路径。</li>
</ul>
</li>
<li>char const *argv[]<ul>
<li>输入参数，类型是一个argv数组的地址</li>
<li>参数的数组形式，第一个值也必须是自身。数组最后一个值也必须是NULL!</li>
</ul>
</li>
</ul>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><ul>
<li>const char* file<ul>
<li>执行文件的路径，可以绝对也可以相对，相对位置为当前程序所在位置. 函数名上的p也可以体现</li>
</ul>
</li>
<li>char const *argv[]<ul>
<li>输入参数，类型是一个argv数组的地址</li>
<li>参数的数组形式，数组最后一个值也必须是NULL!</li>
</ul>
</li>
</ul>
<h3 id="execve-内核级别"><a href="#execve-内核级别" class="headerlink" title="execve(内核级别)"></a>execve(内核级别)</h3><ul>
<li>const char * filename <ul>
<li>执行文件的绝对路径,不同的是也可以相对</li>
</ul>
</li>
<li>char const *argv[]<ul>
<li>输入参数，类型是一个argv数组的地址</li>
<li>参数的数组形式，数组最后一个值也必须是NULL!</li>
</ul>
</li>
<li>char * const envp[]<ul>
<li>环境变量（输入参数），可以自行设定执行文件程序的所携带的环境变量。</li>
</ul>
</li>
</ul>
<p>当然还有个execvpe</p>
<h2 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h2><p>一个简单的函数使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> sonpid, fatherpid;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">  fatherpid = getpid();</span><br><span class="line">  sonpid = fork();</span><br><span class="line">  <span class="keyword">if</span> (sonpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sonpid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is son %d !is ppid  %d!\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is parent %d, is ppid  %d!\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    <span class="keyword">if</span> (sonpid == wait(&amp;<span class="built_in">log</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;log : %d\n&quot;</span>, <span class="built_in">log</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从代码中得出几个信息</p>
<ul>
<li>进程与子进程，变量并不共通。</li>
<li>进程的子进程结束后需要收尸，否则会产生僵尸进程，因为死了但是没管他，父进程一直在自己运行。</li>
<li>当子进程出现异常，信号使他关闭后，父进程正常wait,得到的log值是信号编号。比如说kill -9 子进程 返回log的值为9</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>正常退出与异常退出，大部分几乎程序的退出结束，在Linux中是不同的各种信号所影响的。</p>
<h2 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h2><h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>手动报错，cored umped错误,将CPU 的寄存器的值dump，发送SIGABRT signal使进程结束。</p>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">(scalar expression)</span>;</span><br></pre></td></tr></table></figure>
<p>需要调用头文件assert.h </p>
<blockquote>
<p>If expression is false (i.e., compares equal to zero), assert() prints an  error message  to  standard error and terminates the program by calling abort(3).  The error message includes the name of the file and function containing the assert() call,  the  source  code  line number of the call, and the text of the argument;</p>
</blockquote>
<p>手动断言，当scalar expression 中为 0 时， 将输入在stderror中一个断言执行的文件与代码语句所处位置。</p>
<h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>
<p><strong>进程结束后调用</strong>，需要填写一个带void 参数的函数指针，调用该函数。</p>
<h3 id="on-exit"><a href="#on-exit" class="headerlink" title="on_exit"></a>on_exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">on_exit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">int</span> , <span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>子进程结束后调用</strong>，填写一个带int参数和void 参数的函数指针 ，调用该函数</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="_exit"></a>_exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>   _exit() terminates the calling process &quot;immediately&quot;.  Any open file descriptors
   belonging to the process are closed.  Any children of the process are  inherited
   by  init(1) (or by the nearest &quot;subreaper&quot; process as defined through the use of
   the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process&#39;s parent is sent  a
   SIGCHLD signal.

   The  value status &amp; 0xFF is returned to the parent process as the process&#39;s exit
   status, and can be collected by the parent using one of the  wait(2)  family  of
   calls.

   The function _Exit() is equivalent to _exit().
</code></pre></blockquote>
<p>进程和描述符<strong>立刻</strong>关闭。并且发送一个SIGCHLD 信号关闭所有自己的子进程，然后向自己的爷爷进程告知自己的状态，这个状态 就是 status.的值&amp;0XFF（限制字节大小范围），无论子进程结束后还是自己结束后有什么on_exit 或者，atexit 通通无效，主打的就是一个immediately</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常，说白了也是信号导致的，不过异常的行为是人，也就是设计者的主观认为，是预期之外的错误。</p>
<p>出现异常关闭可以使用wait/waitpid收集到关闭的状态,加以分析。当然这并不是什么好办法。</p>
<p>c还提供了如下函数来对意外进行一个容错。</p>
<h3 id="setjmp"><a href="#setjmp" class="headerlink" title="setjmp"></a>setjmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作用是保存当前堆栈环境，当程序出现异常错误时，想要恢复（比如说服务器程序,通常利用该函数进行异常处理， 避免在其他函数出现崩溃后，直接就寄了，实现了一个异常捕获。</p>
<p>实际上C 语言中，这就是一个处理异常的方式 类似c++ 的 try catch error,</p>
<blockquote>
<pre><code>   The setjmp() function saves various information about the calling envi‐
   ronment (typically, the stack pointer, the instruction pointer,  possi‐
   bly  the  values  of other registers and the signal mask) in the buffer
   env for later use by longjmp().  In this case, setjmp() returns 0.

   The longjmp() function uses the information saved in  env  to  transfer
   control  back  to  the  point  where setjmp() was called and to restore
   (&quot;rewind&quot;) the stack to its state at the time of the setjmp() call.  In
   addition,  and  depending on the implementation (see NOTES), the values
   of some other registers and the process signal mask may be restored  to
   their state at the time of the setjmp() call.
</code></pre></blockquote>
<p>the values of some other registers and the process signal mask may be restored  to their state at the time of the setjmp() call.</p>
<p>需要时刻注意的是，恢复之后，正常执行的运算保存在寄存器中的值，和信号遮罩可能会重置回到第一次执行setjmp的状态。</p>
<p>简单代码示例：一个简单的异常捕获的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">  longjmp(jmpBuf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">  longjmp(jmpBuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">  test02();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_deal</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sig == SIGSEGV) &#123;</span><br><span class="line">    longjmp(jmpBuf, SIGSEGV);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">sighandler_t</span> hsig = signal_deal;</span><br><span class="line">  <span class="comment">// 注册一个段错误信号回调函数。</span></span><br><span class="line">  signal(SIGSEGV, hsig);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> jmpret = setjmp(jmpBuf);</span><br><span class="line">  <span class="keyword">if</span> (jmpret == <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// 手动段错误。</span></span><br><span class="line">    *(<span class="type">int</span>*)(<span class="literal">NULL</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jmpret == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理异常 test02\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jmpret == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理异常 test03\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jmpret == SIGSEGV) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理异常 段错误信号\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;主函数正常运行\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sigjmpset"><a href="#sigjmpset" class="headerlink" title="sigjmpset"></a>sigjmpset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>
<p>作用呢同setjmp，但是呢，保存的值保存的状态更全,不仅仅是寄存器，可以是上下文：堆栈，寄存器，状态新城进程，栈每次地址。</p>
<blockquote>
<pre><code>sigsetjmp()  and  siglongjmp() also perform nonlocal gotos, but provide predictable handling of the process signal mask.
 If, and only if, the savesigs argument provided to sigsetjmp() is  non‐
       zero, the process&#39;s current signal mask is saved in env and will be re‐
       stored if a siglongjmp() is later performed with this env.
</code></pre></blockquote>
<p>根据文档，可见，sigsetjmp不进可以实现非本地的进程跳转，（线程，进程之间也可以跳转,改变进程之间顺序）， 而且提供 可预测的，要调用（跳转的）进程信号遮罩 mask 信号屏蔽量。</p>
<p>常在逆向中使用。嘿嘿嘿嘿。</p>
<h3 id="信号捕获衍生"><a href="#信号捕获衍生" class="headerlink" title="信号捕获衍生"></a>信号捕获衍生</h3><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>int signum </p>
<ul>
<li>信号码</li>
</ul>
</li>
<li><p>const struct sigaction *act </p>
<ul>
<li><p>存放信号行为信息的结构体</p>
<ul>
<li>```c<pre><code>struct sigaction &#123;
     void     (*sa_handler)(int);
     void     (*sa_sigaction)(int, siginfo_t *, void *);
     sigset_t   sa_mask;
     int        sa_flags;
     void     (*sa_restorer)(void);
 &#125;;
</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 第一个 表示行为的调用规则</span><br><span class="line"></span><br><span class="line">      常见的有 SIG_DFL 默认行为，SIG_IGN ：不理睬捕获这个信号。</span><br><span class="line"></span><br><span class="line">    - 第二个 这个信号的的回调函数的 函数指针。</span><br><span class="line"></span><br><span class="line">    - 当前信号遮罩，用于信号集的过滤等。。</span><br><span class="line"></span><br><span class="line">    - sa_flags 行为标志，根据不同的信号不同的回收之类的操作。</span><br><span class="line"></span><br><span class="line">    - The sa_restorer field is not intended for application use.  (POSIX does</span><br><span class="line">        not  specify a sa_restorer field.)  Some further details of the purpose</span><br><span class="line">        of this field can be found in sigreturn(2).</span><br><span class="line"></span><br><span class="line"># 信息</span><br><span class="line"></span><br><span class="line">### 进程信息常用的获取函数</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">   #include &lt;unistd.h&gt;</span><br><span class="line">  </span><br><span class="line">   pid_t getpid(void);</span><br><span class="line">   pid_t getppid(void);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>得到进程的pid 和得到进程的ppid 也就是parent pid 父进程的pid </p>
<ul>
<li>```c<br>pid_t getpgrp(void);                 /<em> POSIX.1 version </em>/<br>pid_t getpgrp(pid_t pid);            /<em> BSD version </em>/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不同系统内核下不同版本，得到当前的进程组id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">既然有get,那当然就有set.</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int setpgrp(void);                   /* System V version */</span><br><span class="line">  int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<pre><code>All  of  these  interfaces  are available on Linux, and are used for getting and
setting the process group ID (PGID) of a process.  The preferred, POSIX.1-speci‐
fied ways of doing this are: getpgrp(void), for retrieving the calling process&#39;s
PGID; and setpgid(), for setting a process&#39;s PGID.

setpgid() sets the PGID of the process specified by pid  to  pgid.   If  pid  is
zero, then the process ID of the calling process is used.  If pgid is zero, then
the PGID of the process specified by pid is made the same as its process ID.  If
setpgid()  is  used  to  move a process from one process group to another (as is
done by some shells when creating pipelines), both process groups must  be  part
of  the same session (see setsid(2) and credentials(7)).  In this case, the pgid
specifies an existing process group to be joined and  the  session  ID  of  that
group must match the session ID of the joining process.


  The  System V-style  setpgrp(), which takes no arguments, is equivalent
   to setpgid(0, 0).

   The BSD-specific setpgrp() call, which takes arguments pid and pgid, is
   a wrapper function that calls

       setpgid(pid, pgid)

   Since  glibc 2.19, the BSD-specific setpgrp() function is no longer ex‐
   posed by &lt;unistd.h&gt;; calls should be replaced with the  setpgid()  call
   shown above.
</code></pre></blockquote>
<p>​    被取代为setpgid()咯。</p>
<p>而setpgid调用后，就会将该进程脱离父进程的组，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setpgid(pid, pid);<span class="comment">//让子进程脱离父进程</span></span><br></pre></td></tr></table></figure>
<p>将进程的组ID 设计为自己的ID 作为自己的组ID ，实际上。</p>
<h3 id="得到进程的执行优先级"><a href="#得到进程的执行优先级" class="headerlink" title="得到进程的执行优先级"></a>得到进程的执行优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> prio)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>   The  scheduling priority of the process, process group, or user, as in‐<br>   dicated by which and who is obtained with the  getpriority()  call  and<br>   set  with  the setpriority() call.  The process attribute dealt with by<br>   these system calls is the same attribute  (also  known  as  the  “nice”<br>   value) that is dealt with by nice(2).</p>
<p>   The  value  which  is one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER, and<br>   who  is  interpreted  relative  to  which  (a  process  identifier  for<br>   PRIO_PROCESS, process group identifier for PRIO_PGRP, and a user ID for<br>   PRIO_USER).  A zero value for who denotes  (respectively)  the  calling<br>   process,  the process group of the calling process, or the real user ID<br>   of the calling process.</p>
</blockquote>
<ul>
<li>int which<ul>
<li>三种不同宏，</li>
<li>PRIO_PROCESS 得到进程的优先级</li>
<li>PRIO_PGRP 得到进程组的优先级</li>
<li>PRIO_USER 得到用户的优先级</li>
</ul>
</li>
<li>id_t who <ul>
<li>当然是id了，</li>
</ul>
</li>
<li>set 进程组的优先级</li>
</ul>
<blockquote>
<p> The prio argument is a value in the range -20 to 19 (but see NOTES  be‐<br>     low).  with -20 being the highest priority and 19 being the lowest pri‐<br>     ority.  Attempts to set a priority  outside  this  range  are  silently<br>     clamped  to  the range.  The default priority is 0; lower values give a<br>     process a higher scheduling priority.</p>
</blockquote>
<p>prio通常的优先级范围从 -20 ~19 。数字越小进程优先越高。</p>
<p>我们常见的sleep函数呢，为了保证能够挂起指定的时间通常会将进程的优先级设为最高后设定挂起时间。 </p>
<p>当我们进行一个进程的调试时，发现，进程的父进程就是gdb ,而gdb进程的子进程就是该被调试的进程。</p>
<p>可以得知：调试也是一个进程。</p>
<p><strong>在修改优先级的时候，降级没问题， 而提升则是需要检查有效用户的权限。</strong></p>
<h1 id="结束后的处理"><a href="#结束后的处理" class="headerlink" title="结束后的处理"></a>结束后的处理</h1><p>子进程结束后的处理。一般进程结束，比如，收尸啥的。</p>
<p>以下是常用得函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line">                <span class="comment">/* This is the glibc and POSIX interface; see</span></span><br><span class="line"><span class="comment">                   NOTES for information on the raw system call. */</span></span><br></pre></td></tr></table></figure>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>等待子进程中断或结束。防止出现僵尸进程。zone</p>
<p>不过这种wait只能wait一个子进程pid,无法wait多个进程，不可控的。</p>
<p>并且还不能设定wait的处理模式，只能阻塞等待</p>
<h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><p>waitpid的三个参数</p>
<ul>
<li>pid_t pid<ul>
<li>需要监听的pid，不同的pid值有不同的意义</li>
<li>返回小于-1  的值 表示 等待的所有子进程的进程组ID  比如-12323 等待组ID 为12323的 所有子进程</li>
<li>等于 -1 表示 等待所有子进程</li>
<li>0 表示等待任意调用进程组ID相同的组内的子进程。</li>
</ul>
</li>
<li>int *wstatus<ul>
<li>传出的wait statu 状态，提供了几个宏来判断状态类型。</li>
<li>​       WIFEXITED(wstatus) 返回 是否 普通的结束 </li>
<li>​       WEXITSTATUS(wstatus) 返会子进程的退出的状态码</li>
<li>​       WIFSIGNALED(wstatus) 返回进程 是否 是由于信号导致的结束</li>
<li>​       WTERMSIG(wstatus) 返回信号导致的结束的信号</li>
<li>​      WCOREDUMP(wstatus) 返回 是否 是CORE DUMP 而结束进程</li>
<li>​       WIFSTOPPED(wstatus) 返回是否是比一个a信号传递的导致的结束 与WUNTRACED 配合操作</li>
<li>​       WSTOPSIG(wstatus)   返回信号，造成子进程信号值，搭配WIFSOPPED 使用<ul>
<li>returns  the  number  of the signal which caused the child to stop.  This<pre><code>macro should be employed only if WIFSTOPPED returned true.
</code></pre></li>
</ul>
</li>
<li>​       WIFCONTINUED(wstatus) 返回是否是因为SIGCONT. 信号导致进程挂起。 也常常与与WCONTINUED 配合操作</li>
</ul>
</li>
<li>int options<ul>
<li>wait操作<ul>
<li>WNOHANG 非阻塞<ul>
<li>return immediately if no child has exited.</li>
</ul>
</li>
<li>WUNTEACED 被调试 <ul>
<li>also return if a child has stopped (but not traced via ptrace(2)).   Status  for  traced children which have stopped is provided even if this option is not specified.</li>
</ul>
</li>
<li>WCONTINUED 发生了信号导致进程暂停后，<ul>
<li>also return if a stopped child has been resumed by delivery of SIGCONT</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>return int <ul>
<li>如果回收成功一个进程后返回 该进程id</li>
<li>if  WNOHANG  was specified and one or more child(ren) specified by pid<pre><code>exist, but have not yet changed state, then 0 is returned
</code></pre></li>
<li>当waitpid 为非阻塞回收时， 检测到还没有结束的子进程，返回0 表示没有回收，等待回收。</li>
<li>失败返回-1 并输出error；</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.icrad.top">Icrad</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.icrad.top/2023/03/23/linux10/">https://www.icrad.top/2023/03/23/linux10/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.icrad.top" target="_blank">icrad的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://q1.qlogo.cn/g?b=qq&amp;nk=972791158&amp;s=100" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Icrad</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/icradP"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/87672381" target="_blank" title="Bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="https://github.com/icradP" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://message/?uin=972791158" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里icrad的博客，后端前端都学一点，快乐多一点，头发少一点。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8D%95%E4%BD%8D"><span class="toc-number">1.</span> <span class="toc-text">进程是操作系统调度的最小的单位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">进程的控制函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EXEC%E7%B3%BB%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">EXEC系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execl"><span class="toc-number">3.1.1.</span> <span class="toc-text">execl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execlp"><span class="toc-number">3.1.2.</span> <span class="toc-text">execlp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execle"><span class="toc-number">3.1.3.</span> <span class="toc-text">execle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execv"><span class="toc-number">3.1.4.</span> <span class="toc-text">execv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execvp"><span class="toc-number">3.1.5.</span> <span class="toc-text">execvp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execve-%E5%86%85%E6%A0%B8%E7%BA%A7%E5%88%AB"><span class="toc-number">3.1.6.</span> <span class="toc-text">execve(内核级别)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FORK"><span class="toc-number">3.2.</span> <span class="toc-text">FORK</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F"><span class="toc-number">4.</span> <span class="toc-text">结束</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8"><span class="toc-number">4.1.</span> <span class="toc-text">正常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#abort"><span class="toc-number">4.1.1.</span> <span class="toc-text">abort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assert"><span class="toc-number">4.1.2.</span> <span class="toc-text">assert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atexit"><span class="toc-number">4.1.3.</span> <span class="toc-text">atexit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#on-exit"><span class="toc-number">4.1.4.</span> <span class="toc-text">on_exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">4.1.5.</span> <span class="toc-text">_exit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">4.2.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setjmp"><span class="toc-number">4.2.1.</span> <span class="toc-text">setjmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigjmpset"><span class="toc-number">4.2.2.</span> <span class="toc-text">sigjmpset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E8%8E%B7%E8%A1%8D%E7%94%9F"><span class="toc-number">4.2.3.</span> <span class="toc-text">信号捕获衍生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">sigaction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%97%E5%88%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.4.</span> <span class="toc-text">得到进程的执行优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">结束后的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#wait"><span class="toc-number">5.1.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waitpid"><span class="toc-number">5.2.</span> <span class="toc-text">waitpid</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #77767b"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Icrad</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://icrad-twikoo-blog.zeabur.app/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 5/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://unpkg.com/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="982869212" data-server="netease" data-type="playlist" data-fixed="true" data-lrctype="0" data-autoplay="false"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://unpkg.com/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://unpkg.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/aplayer/dist/APlayer.min.js"></script><script src="https://unpkg.com/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://unpkg.com/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>