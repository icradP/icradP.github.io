<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/07/18/internet03/"/>
      <url>/2022/07/18/internet03/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="点对点信道的数据链路层"><a href="#点对点信道的数据链路层" class="headerlink" title="点对点信道的数据链路层"></a>点对点信道的数据链路层</h2><p>点对点（ppp)</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>给上一层交付的协议数据单元进行先添加帧尾和帧头使其成为帧</p><p>ppp帧（点对点信道的帧）</p><p>帧头帧尾作用之一是帧定界标志</p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>指的是对上层交付的传输数据没有任何限制，数据链路层的封装好像就是理所应当的，看不见的，不存在的（可以理解为你经常会忽视，你习以为常的事物）</p><h4 id="面对字节的物理链路使用字节填充"><a href="#面对字节的物理链路使用字节填充" class="headerlink" title="面对字节的物理链路使用字节填充"></a>面对字节的物理链路使用字节填充</h4><p>在发送帧之前检测定界标志，检测到定界符flag或者转义字符就前插入一个esc转义字符</p><p>如图所示：</p><p><img src="" alt=""></p><p>注意转义字符只有一个字节，10进制为27，是一个控制字符</p><h4 id="面向比特的物理链路使用比特填充"><a href="#面向比特的物理链路使用比特填充" class="headerlink" title="面向比特的物理链路使用比特填充"></a>面向比特的物理链路使用比特填充</h4><p>对数据部分进行每五个连续的比特1添加一个比特0，确保帧定界的标志成为唯一的值</p><p><img src="" alt=""></p><p>在接收方时按照改规则去除比特0即可</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>提高帧的传输效率，应当使数据部分的长度更大一些</p><p>但是考虑到差错控制等多种因素，每一种数据链路层的协议都规定的帧的数据部分的最大上限</p><p>我们称其为最大传送单元MTU（Maximum Transfer Unit)</p><p>mac帧是没有定界符的，取代而之的是物理层加入一个前导码，有着相同的作用</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>比特差错，也是我们常说的误码</p><p>0变成1,1变成0 ，<del>想到了一些怪东西，不要深究</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/E42EE4FE61B7BAB7585878F6B6268C33.jpg" alt=""></p><p>在一定时间内，产生的错误在传输过程中占比，被称为误码率</p><p>这个时候我们就需要进行校验</p><h4 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h4><p>顾名思义，检测比特1是否为奇数或偶数</p><p>通信的双方指定一个校验方式</p><p>漏检率较高，计网用不着</p><h4 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h4><p>CRC (Cyclic Redundancy Check)</p><p>双方生成多项式G(X)</p><p>发送方：根据发送数据和生成的多项式计算出差错检测码（冗余码），将其添加到带传输数据的后面一起传输</p><p>简单冗余码的计算过程</p><p>首先我们需要得知待发送的信息的比特串</p><pre><code>假设为：101001</code></pre><p>生成一个多项式（随机假设的）</p><script type="math/tex; mode=display">G(x)=x^3+x^2+1</script><p>通过多项式的系数构造一个被除数</p><pre><code>得到：1101</code></pre><p><strong>注意</strong> 使用的是模2除法，不是我们常用的十进制除法（进行的是异或运算）</p><p><img src="" alt=""></p><p>通过组合计算出来的余数就可以发送了</p><pre><code>发送的数据：101001  001                  余数</code></pre><p>接受方：根据发送数据和生成的多项式计算，检查余数是否为0,若不为0,说明为产生误码</p><p>直接上图：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718095630773.png" alt="image-20220718095630773"></p><p><strong>注意</strong>：咱这只是差错检测，<strong>纠错</strong>是不行的，想要纠错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>向前纠错</strong>。但是纠错码<strong>开销较大</strong>，计算机很少用</p><p>那么纠错该怎么实现呢，检错重传方式来纠正传输中的差错，或者是直接丢弃错误的帧，这都取决于数据链路层向上提供的是啥协议TCPor UDP可靠或者不可靠的 传输服务了</p><p><strong>CRC有很好的检错能力，计算也不复杂，而且易于硬件实现，所以广泛应用于数据链路层</strong></p><h3 id="可靠传输基本概念"><a href="#可靠传输基本概念" class="headerlink" title="可靠传输基本概念"></a>可靠传输基本概念</h3><p>基本概念：使用了差错检测后，出现了误码</p><p>不可靠传输服务：<strong>仅仅丢弃</strong>有误码的帧，啥也不做</p><p>可靠传输服务：发送端发到什么，接收端收什么</p><p>注意：可靠传输服务，<strong>不仅</strong>仅存在于数据链路层，在各层中都可以实现</p><p><strong>差错</strong>也有很多种：</p><p>比特差错<br>以下差错<strong>一般</strong>出现在数据链路层的上层</p><p><strong>分组丢失</strong></p><p><strong>分组失序</strong></p><p><strong>分组重复</strong></p><p><strong>再次作证了可靠传输服务</strong>，<strong>不仅仅存在于数据链路层</strong>，<strong>在各层中都可以实现</strong></p><h3 id="可靠传输的实现的机制"><a href="#可靠传输的实现的机制" class="headerlink" title="可靠传输的实现的机制"></a>可靠传输的实现的机制</h3><h4 id="停止等待协议（SW）"><a href="#停止等待协议（SW）" class="headerlink" title="停止等待协议（SW）"></a>停止等待协议（SW）</h4><p><strong>A方</strong>发送<strong>DATA分组</strong>给B方</p><p>B方检测<strong>DATA分组没有错误</strong>，返回发送一个<strong>ACK分组</strong>（表示接受成功）</p><p>A方接收到了ACK分组，OK，A方就可以呢<strong>继续发送下一个DATA分组</strong></p><p>当B方检测这个DATA分组<strong>有错误</strong>，丢掉，返回一个NAK分组（表示没有成功姐接受）</p><p>A方呢，重新再把这个DATA分组数据啊，再发送一次，直到呢B方返回一个ACK分组</p><p>图解：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718103620500.png" alt=""></p><p>诶那你就会有疑问了，如果出现A方发送的DATA数据丢失了呢，不就会出现B方什么也没收到，就什么也不返回，A方也不知道到底接没接收到，就一直处于等待接收方返回ACK/NAK的状态么。</p><p>出现这种情况，发送方内部启动个<strong>计时器</strong>，设定计时器的时间</p><p><strong>超时</strong>没收到返回分组，那我就<strong>重传</strong>原来的数据分组，这就是<strong>超时重传</strong>的概念</p><p>这个计时器的时间，一般大于发送往返的时间：图解如下</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718104421832.png" alt=""></p><p>然而呢，假设还有两种种情况：</p><p>就是出现：</p><ul><li><p>A方发送过去了，就是有点久<strong>超过了设定计时器定时 B方才接收到</strong> 或者 <strong>ACK回晚了</strong></p></li><li><p><strong>返回的ACK丢失了</strong>。</p></li></ul><p>出现这两种就会出现第二种解法：<strong>超时重传</strong>，但是啊，搞清楚了，B方式已经默认收到DATA 的，有A方又传了一个相同的DATA分组，这就是出现了<strong>分组重复</strong>的情况</p><p>这种情况需要发送方A在发送事给每个分组带上一个<strong>序号</strong>，接受方B接收该数据DATA0，检测该序号，与上一个DATA0<strong>分组序号相同</strong>就丢弃顺便返回一个ACK0（针对的DATA0的数据分组，注意啊：ACK也是需要编号的，否则依然会出现<strong>ACK重复混淆</strong> 的这种情况） ，A方就可以取消该DATA0分组的重传</p><p>继续发下一个DATA1（此时变为了1）返回的ACK1（也变为了1）</p><p>再下一个层就是为ACK0和DATA0，至此呢所有情况，都有了相应的应对方案。</p><p>上图：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718110752910.png" alt=""></p><p>值得一提的是：在PPP（点对点的信道物理链路层）中，发送时间，往返时间都是<strong>固定</strong>的，所以呢不用担心<strong>超时重传</strong>的问题，设不设定计时器重传时间，编不编号都无伤大雅，<del>除非有老鼠掐准点把你家电路吃了</del>，不过为了这个传输协议的鲁棒性，健壮型，加编号未尝不可</p><p><strong>但是在</strong>（实际的ISO协议）运输层中，这这额外的情况就很可能发生，设定往返超时的判断时间（<strong>重传时间</strong>）是需要<strong>谨慎确定</strong>的问题</p><p>注意：编号一个比特表示0/1就够了，停等协议是这样的</p><p><strong>SW协议的的信道利用率</strong></p><p>短距离，数据帧的长度低，信道利用率的能稍微高点</p><p>但实际上SW协议的新到利用率相当的低，有图可证</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718134746790.png" alt=""></p><p>可以用公式来计算：</p><script type="math/tex; mode=display">U= \frac{T_D}{T_D+RTT+T_A}</script><p>RTT是往返时间，出现重传U还要降低</p><p>为此，如此低的信道利用率太浪费资源，就有了GBN和SR协议的解决方法</p><p><strong>SW协议也被称为 自动请求重传协议ARQ（Automatic Repeat reQuest)</strong></p><h4 id="回退N帧协议（GBN）"><a href="#回退N帧协议（GBN）" class="headerlink" title="回退N帧协议（GBN）"></a>回退N帧协议（GBN）</h4><p>那么，为了解决SW协议的信道利用率，就提出了回退N帧协议</p><p>那SW协议就就连续发多个分组，跟流水线一样</p><p>但是需要做出限制，限定了一个发送窗口，记为$W_T$</p><p>当取值等于1时，等于SW协议</p><p>取值等$1&lt;W_T&lt;=2^n-1$ </p><p>n为采用几个比特给分组编号</p><p>（如$W_T$大于上限，就会出现分组重复的差错）</p><p>我们也需要给接收方设定一个接受窗口$W_R$=1</p><p>接收方只能按序接收数据分组，当发送方每收到一个ACK就往前移动一个序号的发送窗口</p><p>图如下</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100250014.png" alt=""></p><p>如果每一个序号的分组都进行发送确认ACK，开销有点大，</p><p>可以只发送序号最大的ACK4（假设发送窗口为5，采用3比特进行编号）那么发送方就知道0~4的信号接收方已接受。</p><p>那么出现差错怎么办呢</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100449425.png" alt="image-20220719100449425"></p><p>就会将所有的发送全部丢弃，每丢弃一个数据分组，就发送一个ACK4,表示我只接受到了0到4的数据分组，之前的所有数据都没有成功接收，全部需要重发。</p><p>由此可见，在网络波动大时，新到的利用率跟SW协议差不了多少。</p><p><strong>总结：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719101040194.png" alt="image-20220719101040194"></p><p>我们可以看下题解析，巩固一下理解 </p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100136847.png" alt=""></p><p>同样是一种ARQ协议，当通信线路8太行时，信道利用率和SW协议差不多</p><h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p>是GBN的改进，</p><h2 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h2><h3 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h3><p>接入控制与碰撞检测协议</p><h3 id="802-11局域网"><a href="#802-11局域网" class="headerlink" title="802.11局域网"></a>802.11局域网</h3><p>接入控制与碰撞检测协议</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="数据链路层的互连设备"><a href="#数据链路层的互连设备" class="headerlink" title="数据链路层的互连设备"></a>数据链路层的互连设备</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第二节|物理层</title>
      <link href="/2022/07/17/internet02/"/>
      <url>/2022/07/17/internet02/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章了解个概念，不深究，比较抽象</p><h2 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h2><p><strong>明确：考虑怎么链接各种计算机之间传输比特流数据</strong></p><p>四个特性</p><ul><li><p>机械</p><p>接口类型</p></li><li><p>电气</p><p>电压</p></li><li><p>功能</p><p>传输1/0编码</p></li><li><p>过程</p><p>时种顺序</p></li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><p>注意传输介质实际上不属于物理层</p><h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul><li><strong>双绞线</strong></li></ul><p>两根，按一定规则双绞，抗干扰</p><ul><li><p><strong>同轴电缆</strong></p></li><li><p><strong>光纤</strong></p><ul><li><p>单模光纤：波导,就是贵，对光信号要求高</p></li><li><p>多模光纤：全反射</p><p>优点：带宽大,损耗低</p></li></ul></li><li><p><strong>电力线</strong></p><p>适合短距离</p></li></ul><h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><p>(自由空间)</p><ul><li><strong>微波</strong></li></ul><p>直线，电离层无折射，需要中继站，典型5G通信</p><ul><li><strong>无线电波</strong></li></ul><p>电离层折射，距离远</p><ul><li><strong>可见光</strong></li></ul><p>应用：lifi</p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>一条数据传输线路</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>多条数据传输线路</p><p><strong>计算机内部常用并行传输</strong></p><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><h4 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h4><p>连续无间隔</p><p><strong>外同步</strong></p><p>多加一条单独的时钟信号线</p><p><strong>内同步</strong></p><p>市中心号线与发送数据曼彻斯特编码</p><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>异步的体现：字节之间的时间间隔不固定</p><p>需要字节需要加上起始位和结束位</p><p>但各比特的持续时间是相同的</p><p>字节异步，比特同步</p><h3 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h3><p>单向</p><h3 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h3><p>双向不同时</p><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>同时双向</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p>关于编码与调制我们需要了解：</p><p>信息-&gt;数据（二进制）-&gt;信号（电磁表现）</p><p>数字基带信号的数字</p><p>模拟基带信号</p><p>两者都有编码和调制</p><h3 id="数字基带信号"><a href="#数字基带信号" class="headerlink" title="数字基带信号"></a>数字基带信号</h3><p>编码（数字信号转化数字信号）：以太网下的曼彻斯特编码，4B/5B 走的是数字信道</p><p>调制（数字信号转化模拟信号）：WIFI CCK/DSS/OFDM调制，走的是模拟信道</p><h3 id="模拟基带信号"><a href="#模拟基带信号" class="headerlink" title="模拟基带信号"></a>模拟基带信号</h3><p>编码（数字信号转化数字信号）：音频信号的PCM脉码调制，走的是数字信道</p><p>调制（数字信号转化模拟信号）：FDM频分复用，充分利用带宽资源，走的是模拟信道</p><p><del>啊~这熟悉又陌生的的名词</del></p><p><strong>注意</strong></p><p>传输媒体不等于信道</p><p>不同的传输媒体，包含多个不同数量的信道</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h4><p>自同步，编码效率低，需要归零</p><h4 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h4><p>需要多一条信道传输时钟信号，这玩意不能用来传递时钟信号</p><h4 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h4><p>码元为单位，以中间的信号跳变表示0/1</p><p>跳变有表示时钟，又表示数据</p><p>（是传统以太网10Mb/s）</p><h4 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h4><p>跳变只表示时钟</p><p>码元开始处 的电平是否发生变化表示数据，</p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字基带信号</p><p>频率，振幅，相位</p><h4 id="二元调制："><a href="#二元调制：" class="headerlink" title="二元调制："></a>二元调制：</h4><p>只有<strong>两种</strong>码元</p><p><strong>调幅AM</strong></p><p><strong>调频FM</strong></p><p><strong>调相PM</strong></p><p>调频和调相<strong>不能一块调</strong>，调幅调相可以同时，或者调频调幅</p><h4 id="混合调制："><a href="#混合调制：" class="headerlink" title="混合调制："></a>混合调制：</h4><p><strong>调频和调相混合</strong></p><p>至少可以有<strong>四种</strong>码元，若是有4个相位，4种振幅，可以调出16个不同的波形，也就是码元</p><p>我们再以二进制处理这16种码元</p><script type="math/tex; mode=display">log_216=4</script><p>可以算出每个码元所还能携带的信息量为4比特</p><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p><strong>奈氏准则</strong>，假定的理想条件下，避免码间串扰，码元的传输速率是有上限的</p><p>不考虑信噪比</p><p>理想低通信道的最高码元传输速率=2W Baud= 2W(单位：码元/s)</p><p>理想带通信道的组稿码元传输速率=W Baud= W（单位：码元/s）</p><p>W指的是，信道带宽hz</p><p>那么要考虑噪声，引出<strong>香农公式</strong></p><p>带宽受限 且高斯白噪声干扰的信道的极限信息的传输效率</p><script type="math/tex; mode=display">c=W*log_2(1+\frac{S}{N})~~~~（单位：bit/s）</script><p>综上奈氏准则和香农公式，要想<strong>提高信息的传输速率</strong>就必须用<strong>多元</strong>制的调制方式，努力提高<strong>信道中的信噪比</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思维导图：不着急，躺平摸鱼</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础，物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/16/socket/"/>
      <url>/2022/07/16/socket/</url>
      
        <content type="html"><![CDATA[<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>套接字 描述计算机的ip地址和端口，基于TCP/ip</p><p>这里我直接上图：先把协议的概念先搞懂</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/bfcd89ba301b34b6f158d2065a5ccb40.jpg" alt="https://s4.51cto.com/oss/201910/22/bfcd89ba301b34b6f158d2065a5ccb40.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第一节</title>
      <link href="/2022/07/15/Internet01/"/>
      <url>/2022/07/15/Internet01/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络基础-第一节"><a href="#计算机网络基础-第一节" class="headerlink" title="计算机网络基础|第一节"></a>计算机网络基础|第一节</h1><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/728da9773912b31bad1719cedfd48473dbb4e130.png" alt="img"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学校网课不努力，B站大学再继续。实在努力不下去，美团饿么当兄弟。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/9bb444786eaac9678f1b8574db28d03b69cef878.jpg@942w_942h_progressive.webp" alt="img"></p><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p>两个以上主机可发送接受信息的互连的，可自治的，组成计算机网络</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="常用以下8个"><a href="#常用以下8个" class="headerlink" title="常用以下8个"></a>常用以下8个</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h4><p><strong>比特 bit 数据量单位</strong></p><p>代表：一个数0/1</p><p>字节=B</p><p>8bit=1B;</p><p>注意：<strong>依次乘与2的10次方</strong></p><p><strong>K-&gt;M-&gt;G-&gt;T</strong></p><p>举个例子</p><p>我们购买的硬盘，商家标的是250GB为什么在操作系统中却只有232.8GB呢</p><p>我们看下面的一个公式：</p><script type="math/tex; mode=display">\frac{250*10^{9} } {2^{30} }=232.8（GB）</script><p>商家的计算方式是G 为10的9次方，操作系统中数据量的G 是2的30次方</p><p><strong>比特率</strong>速率单位 bit/s</p><p>注意：<strong>依次乘与10的3次方</strong></p><p><strong>k-&gt;M-&gt;G-&gt;T</strong></p><p><strong>与数据量不同</strong></p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h4><p>在<strong>模拟信号</strong>中 ：单位<strong>Hz</strong></p><p>表达的是信号频率范围</p><p>在<strong>计算机网络</strong>中：</p><p>可以理解为网络中点到点传输的 最高数据率</p><p>单位b/s与比特率相同</p><p>这两者其实表述都是有联系的，带宽频率越宽，网络越好</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图50.png" alt=""></p><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3.吞吐量"></a>3.吞吐量</h4><p>单位时间通过的数据量</p><p>受到带宽限制</p><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><p>总的来说就是传输数据的时间</p><p>可以细分为：</p><p>网络时延：发送，传播，处理</p><ul><li>发送时延：分组长度/发送速率</li></ul><ul><li><p>传播时延</p><p>计算是有公式的</p><p>信道长度/电磁波传播速率 </p><p>然而在不同的传输介质中传播速率是不同的</p><p>这里列出3个不同的常见的传播介质</p><ul><li>光纤</li><li>忘了</li><li>是啥来着？</li></ul></li><li><p>处理时延：不方便计算</p></li></ul><h4 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h4><p>传播时延乘与带宽的乘积</p><p><img src="/home/icrad/图片/截图/截图 2022-07-15 19-11-41.png" alt=""></p><p>链路的时延带宽积又称为以比特为单位的链路长度</p><h4 id="6-往返时间"><a href="#6-往返时间" class="headerlink" title="6.往返时间"></a>6.往返时间</h4><p>数据双向交互一次的时间</p><p>我们简称为<strong>RTT(Round-Trip Time)</strong></p><h4 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h4><ul><li><p>信道利用率：有百分之几的时间是被利用的</p></li><li><p>网络利用率：全网络的信道利用率的加权平均。</p></li></ul><p>根据排队论，信道的利用率增大时，该信道引起的时延也会迅速增加</p><p>因此信道利用率并非越高越好</p><p>如果令<script type="math/tex">D_0</script>表示为网络空闲的时延，D表示当前的时延，那么在适当的假定条件下，可以用以下的简单公式来表示D与<script type="math/tex">D_0</script>和利用率U之间的关系</p><script type="math/tex; mode=display">D=\frac{D_0} {1-U}</script><ul><li>当网络的利用率达到50%时，时延加倍</li><li>当利用率超过50%时，时延急剧增大</li><li>当网络利用率接近100%时，时延趋于无穷大</li><li>依次一些拥有交大主干网的ISP通常会控制他们的新到利用率不超过50%,如果超过了，就扩容，增加带宽。</li><li><strong>注意</strong>：也不能太低，浪费了宝贵的通信资源，设定一个程序机制来根据情况动态调整网络中的通信量，是网络利用率保持在一个合理的范围内</li></ul><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><p>即分组的丢失率</p><ul><li>一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li><li>可以分为接口丢包率，结点丢包率，链路丢包率，路径丢包率，网络丢包率等</li></ul><p>分组丢失主要有两种情况：</p><ul><li><p>分组在传输的过程中，出现误码，被结点丢弃；</p></li><li><p>分组到达一台队列已满的分组交换机时被丢弃；在通信量较大是就可能造成网络拥塞</p></li><li><p>因此 丢包率也可以反应网络的拥塞情况</p><ul><li><p>无拥塞时路径丢包率为0；</p></li><li><p>轻度拥塞时路径丢包率为1%~4%</p></li></ul></li></ul><ul><li>严重时可达到5%~15%</li></ul><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p>有三种常见的计算机网络体系结构</p><ul><li><p><strong>法律上的国际标准(OSI)</strong></p><p>有七层：我不考研简单知道一下就够了，实际上开发不会用到这个框架</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图414.png" alt=""></p></li><li><p><strong>实际上的国际标准(TCP/IP)</strong></p><p>表明了各种层的协议</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图.png" alt=""></p></li><li><p><strong>原理体系结构（在学习中我们主要遵循的）</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图54.png" alt=""></p></li></ul><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>分层的思想：以大化小，以小化了</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>需要解决：</p><ul><li><p>传输介质</p></li><li><p>物理接口</p></li><li><p>什么信号</p></li></ul><p>严格来说：传输媒体并不属于物理层</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>需要解决：</p><ul><li>目的主机该如何标识（主机编址）</li><li>目的主机识别出力分组数据的封装</li><li>协调多个主机之间的数据交换（一个网络或一段链路）</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>需要解决：</p><ul><li>网络以及网络中的各主机的共同编址问题（多个网络（路由））</li><li>路由器该怎么转发分组，路由的选择</li></ul><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>需要解决：</p><ul><li>不同网络应用进程之间的通信(<strong>端到端</strong>的逻辑通信，不是端口到端口)</li><li>出错与异常的解决（丢包，误码等）</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>需要解决：</p><ul><li>不同网络进城程间的通信的基础上，规定特定的技术协议运用</li></ul><h3 id="分层的思想示例"><a href="#分层的思想示例" class="headerlink" title="分层的思想示例"></a>分层的思想示例</h3><p>简单的图解（图片来源湖南科技大学课程）：<br><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图2022-07-1623.png" alt=""></p><p>可以简单理解为：邮件的传输</p><p>个人主机：</p><ul><li><p>首先在<strong>应用层</strong>我们写了一个信件（<strong>报文</strong>） 内容规则可以是http，FTP，我们放在了自家的邮寄箱中 </p><p>这个时候来了个小哥来拿，他根据你在的地方，寄的信件内容类型呢，加了个邮局分局的地址等一系列信息，进行了一个简单的包装</p><p>（<strong>运输层</strong>根据tcp协议的规定 添加端口等一系列信息的<strong>TCP首部</strong>，成了一个<strong>TCP报文段</strong>）</p></li><li><p>拿到了你这个地区的邮局站，根据你要寄的地址分号码分类</p><p>（<strong>网络层</strong>加了个<strong>IP首部</strong>，成为了一个<strong>IP数据报</strong>）</p></li><li><p>然后根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>（<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p></li></ul><p>（帧交给物理层，加了个前导码，目的是为了让目的主机做好帧接受的准备）</p><p>​    </p><p>通过链路到达了另外一个邮寄站点（路由） </p><ul><li><p>物理层将信件货物拆解，去掉上一个标签</p><p>（比特流化为帧）</p></li><li><p>再将其交付给处理信件地址的网络层解析（提取查找路由表，确定转发端口 指定下一个路由或者地址）</p></li><li><p>再重新根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>(<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p><p>（<strong>帧</strong>交给<strong>物理层</strong>，加了个<strong>前导码</strong>，目的是为了让目的主机做好帧接受的准备）</p></li></ul><p>  以下内容都是同理</p><p>  （重复解析封装一发送）</p><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>任何可发送或接受信息的硬件或者软件进城</p><h4 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h4><p>相同层次中的实体</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120751857.png" alt=""></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>控制两个对等实体进行逻辑通信的规则的集合</p><p>注意：<strong>逻辑通信</strong>，的意思是，这个通信的的规则不是存在的，是假设的一种通信，单独简化研究，同理逻辑接口</p><p>三要素：</p><ul><li>语法：定义交换信息的格式（各种分组格式http ftp等）</li><li>语义：定义通信双方所要完成的操作</li><li>同步：定义收发双方的时序关系（<strong>三次握手</strong>）</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120824649.png" alt=""></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>协议的控制下，<strong>对等实体</strong>的逻辑通信向上层提供服务</p><p>实现本层的协议需要，使用下面一层所提供的服务</p><p>协议是<strong>水平</strong>的，服务是<strong>垂直</strong>的</p><ul><li><p>服务访问点：相邻两层的逻辑接口，用于交换两层之间的是实体信息，区分不同的服务类型</p><ul><li>数据链路层的服务访问点为帧的<strong>类型字段</strong></li><li>网络层的服务访问点为ip数据报首部的<strong>协议字段</strong></li><li>运输层的服务访问点为<strong>端口号</strong></li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120844704.png" alt=""></li></ul></li></ul><p>  <strong>协议数据单元</strong></p><p>  PDU：对等层次之间传送的数据包称为该层的协议数据单元</p><p>  SDU：同一系统系统内服务数据单元 层与层之间交换的数据包成为服务数据单元</p><p>  多个SDU 可以合成为一个PDU</p><p>  一个SDU 也 可以分为多个PDU </p><p>  比特-&gt;帧-&gt;ip数据段-&gt;tcp/udp数据报-&gt;报文</p><p>  <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图27.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不着急写，<del>随便做个思维导图糊弄一下</del></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB基础</title>
      <link href="/2022/07/14/GDB/"/>
      <url>/2022/07/14/GDB/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB的调试"><a href="#GDB的调试" class="headerlink" title="GDB的调试"></a>GDB的调试</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gdb.jpg" alt=""></p><p><strong>GDB (GUN DEBUGGER)</strong></p><ol><li><p>设置断点</p></li><li><p>单步运行</p></li><li><p>查看变量值</p></li><li><p>动态改变执行环境</p></li><li><p>分析崩溃产生core文件</p></li></ol><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><pre><code class="lang-bash">g++ -g test.cpp -o test#生成可调试的执行文件</code></pre><h3 id="GDB-常用指令"><a href="#GDB-常用指令" class="headerlink" title="GDB 常用指令"></a>GDB 常用指令</h3><p>​    说多也不多，毕竟现在调试大多都是gui调试，暂时很少直接用gdb命令行进行调试，写几个比较基础的<del>糊弄糊弄，就记住几个</del></p><pre><code class="lang-bash">gdb [file]#执行gdb调试#进入gdb，可以直接输入命令break(b) [num]#在第num行代码设置断电info breakpoint #查看当前代码信息display [变量]#显示变量，在每次运行到断点显示值continue#继续运行run#运行程序quit#退出GDB调试#更多的我也记不到了，用men gdb指令查吧</code></pre>]]></content>
      
      
      <categories>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
            <tag> C++ </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G++基础</title>
      <link href="/2022/07/14/Gcc/"/>
      <url>/2022/07/14/Gcc/</url>
      
        <content type="html"><![CDATA[<h2 id="G-GCC基础"><a href="#G-GCC基础" class="headerlink" title="G++/GCC基础"></a>G++/GCC基础</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gcc.png" alt=""></p><h3 id="编译过程有四步"><a href="#编译过程有四步" class="headerlink" title="编译过程有四步"></a>编译过程有四步</h3><ol><li><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><pre><code class="lang-bash">g++ -E test.cpp -o test.i#预处理为.i文件#头文件啥的的预定义啥的</code></pre></li></ol><ol><li><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><pre><code class="lang-bash">g++ -S test.i -o test.s#编译为汇编语言输出为.s文件</code></pre></li></ol><ol><li><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><pre><code class="lang-bash">g++ -c test.s -o test.o#编译为机器语言输出为.o</code></pre></li></ol><ol><li><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><pre><code class="lang-bash">g++ test.o test#生成为可执行文件test，二进制的文件</code></pre></li></ol><h3 id="GCC-G-的优化选项"><a href="#GCC-G-的优化选项" class="headerlink" title="GCC/G++的优化选项"></a>GCC/G++的优化选项</h3><pre><code class="lang-bash">#基本优化-O #等效O1-O0#不做优化-O1#为默认优化-O2#默认优化+额外的调整-O3#默认优化+额外的调整+循环展开等处理特性的优化g++ test.cpp -O2 -o test#优化等级2生成可执行文件test</code></pre><p>所谓优化就是提升效率，编译时间换取执行效率</p><p>示例:</p><pre><code class="lang-c++">#include &lt;iostream&gt;using    namespace std;int main ()&#123;    unsigned long int counter;    unsigned long int result;    unsigned long int temp;    unsigned int five;    int i;    //有很多计算步骤都都在循环条件里    for(counter=0;counter&lt;2000*2000*100/4+2010;counter+=(10-6)/4)    &#123;        temp+=counter/1979;        for(i=0;i&lt;20;i++)        &#123;            five=200*200/8000;            result=counter;        &#125;    &#125;    cout&lt;&lt;&quot;result=&quot;&lt;&lt;result&lt;&lt;endl;    return 0;&#125;</code></pre><p>测试优化O2与不优化O0</p><pre><code class="lang-bash">g++ test.cpp -O2 -o Youhua</code></pre><pre><code class="lang-bash">g++ test.cpp -O0 -o NotYouhua</code></pre><p>再依次执行</p><pre><code class="lang-bash">time ./Youhuatime ./NotYouhua</code></pre><p>可以看见优化后的执行效率相当高</p><h3 id="指定库文件与头文件"><a href="#指定库文件与头文件" class="headerlink" title="指定库文件与头文件"></a>指定库文件与头文件</h3><p>库的指定：</p><pre><code class="lang-bash">g++ -lglog test.cpp#链接golg 库g++ -L/home/icrad/mylibfolder -lmylib test.cpp#链接自己的指定的库文件夹下的库文件，需要大写</code></pre><p>头文件的指定</p><pre><code class="lang-bash">#一般来说，是不需要指定的，GCC默认去找include文件夹，当不存在时，就需要自己指定了头文件目录了g++ -I/myinclude test.cpp</code></pre><h3 id="基本常用的其他项"><a href="#基本常用的其他项" class="headerlink" title="基本常用的其他项"></a>基本常用的其他项</h3><ul><li><p>-Wall</p><p>打印警告信息</p><pre><code class="lang-bash">g++ -Wall test.cpp</code></pre></li></ul><ul><li><p>-w</p><p>关闭警告信息</p><pre><code class="lang-bash">g++ -W test.cpp</code></pre></li></ul><ul><li><p>-std=c++11</p><p>指定C++ 特性</p><pre><code class="lang-bash">g++ -std=c++11 test.cpp</code></pre></li></ul><ul><li><p>-o</p><p>编译输出可执行文件</p><pre><code class="lang-bash">g++ test.cpp -o test</code></pre></li></ul><ul><li><p>-D</p><p>定义宏</p><pre><code class="lang-c++">//使用场景，可以在编译的时候选择是否 执行宏定义#include &lt;iostream&gt;using namespace std;int main ()&#123;    #ifdef DEBUG     cout&lt;&lt;&quot;DEBUG_LOG&quot;&lt;&lt;endl;    #endif    cout&lt;&lt;&quot;Ubuntu,yes!&quot;;    return 0;&#125;</code></pre><p>编译这个文件时可以</p><pre><code class="lang-bash">g++ -DDEBUG test.cpp -o test</code></pre><p>生成的执行文件会将宏定义中的代码输出</p><p>如果没有定义宏，只会输出</p><pre><code>  Ubuntu,yes!</code></pre></li></ul><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><pre><code class="lang-bash">g++ -g test.cpp -o test#生成可调试的执行文件</code></pre><h3 id="编译示例"><a href="#编译示例" class="headerlink" title="编译示例"></a>编译示例</h3><h4 id="多文件夹的目录结构"><a href="#多文件夹的目录结构" class="headerlink" title="多文件夹的目录结构"></a>多文件夹的目录结构</h4><pre><code>├── include│   └── swap.h├── math.cpp└── src    └── swap.cpp</code></pre><ul><li><h4 id="直接编译"><a href="#直接编译" class="headerlink" title="直接编译"></a>直接编译</h4><pre><code class="lang-bash">g++ math.cpp -std=c++11 src/swap.cpp -Iinclude#记得引入头文件</code></pre><p>即可生成可执行文件a.out </p></li></ul><ul><li><h4 id="链接生成静态库"><a href="#链接生成静态库" class="headerlink" title="链接生成静态库"></a>链接生成静态库</h4><pre><code class="lang-bash">#将src的文件夹下的swap.cpp生成为.o文件(汇编语言)cd src/g++ swap.cpp  -c -I../include#进行归档操作ar rs libswap.a swap.o#作用是将swap.o归档为一个静态库文件cd ..#回到上级目录g++ math.cpp -lswap -Lsrc -I\include -o static_swap#链接指定的静态库进行编译#最终得到可执行文件static_swap</code></pre></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><ul><li><h4 id="链接生成动态库"><a href="#链接生成动态库" class="headerlink" title="链接生成动态库"></a>链接生成动态库</h4><pre><code class="lang-bash">cd src/g++ swap.cpp -I../include -fPIC -shared -o libswap.so#等价于gcc    swap.cpp -I../include -c -fPIC #生成.o文件gcc -shared -o libswap.so swap.o#生成静态库文件libswap.so回到上级目录cd ..g++ math .cpp -Iinclude -lswap -Lsrc -o dyna_swap#生成了可执行的文件dyna_swap</code></pre><p>动态库的可执行文件需要指定搜索路径</p><pre><code class="lang-bash">LD_LIBRARY_PATH=src ./dyna_swap#指定了动态库的搜索路径运行该可执行文件</code></pre></li></ul><p>静态库与静态库的区别：大小，前者更大，动态库在调用相应函数时才会加载，所以在运行时，静态库不需要指定路径直接运行，而动态库需要。</p>]]></content>
      
      
      <categories>
          
          <category> GCC/G++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> G++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的更新与备份</title>
      <link href="/2022/07/14/blog/"/>
      <url>/2022/07/14/blog/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的更新与备份"><a href="#博客的更新与备份" class="headerlink" title="博客的更新与备份"></a>博客的更新与备份</h2><p>基于hexo的博客，搭建在github的仓库中</p><p>我们要实现在不同的系统与电脑中进行修改，与同步</p><h3 id="需要以下条件"><a href="#需要以下条件" class="headerlink" title="需要以下条件"></a>需要以下条件</h3><ol><li>Nodes.js</li><li>npm</li><li>git</li><li>博客源文件已经部署在github的仓库中（建议部署在分支中）</li></ol><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><p>首先新系统下的git配置，关键点在于重新配置ssh密匙</p><p>其次是Nodes.js与npm需要最新版本（有多新装多新</p><h3 id="初始化另一台电脑的操作"><a href="#初始化另一台电脑的操作" class="headerlink" title="初始化另一台电脑的操作"></a>初始化另一台电脑的操作</h3><ol><li><p>git bash 将远程仓库克隆到本地</p><pre><code class="lang-bash">git clone 博客所在仓库地址</code></pre></li><li><p>进入项目目录，安装依赖启动博客服务器，生成静态文件</p><p>并在本地部署，通过<a href="http://localhost:4000进行访问">http://localhost:4000进行访问</a></p><pre><code class="lang-bash">npm installhexo g&amp;hexo s</code></pre></li><li><p>发布文章与之前相同</p><pre><code class="lang-bash">hexo c&amp;hexo d -g</code></pre></li></ol><h3 id="另一台电脑同步"><a href="#另一台电脑同步" class="headerlink" title="另一台电脑同步"></a>另一台电脑同步</h3><p>​        在博客目录下执行</p><pre><code>hexo cleanhexo d -g</code></pre><p>​        后执行更新原始文件</p><pre><code class="lang-bash">git pull git add -Agit commit -m &quot;描述&quot;git push origin hexo</code></pre><p>​        每次有新的操作的时候，在另一台电脑上也同时进行更新</p><pre><code class="lang-bash">git pull hexo #拉取源文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake基础</title>
      <link href="/2022/07/12/cmake01/"/>
      <url>/2022/07/12/cmake01/</url>
      
        <content type="html"><![CDATA[<h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a><a href="">Cmake</a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux下cmake编译工具使用过程与windows的操作大同小异</p><p>单独开一篇文章对指令基础做个总结</p><h3 id="Corss-platform-development"><a href="#Corss-platform-development" class="headerlink" title="Corss-platform development"></a>Corss-platform development</h3><p>跨平台：毕竟做linux下的c++ 开发不用cmake 可不行</p><h3 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h3><p>指令格式</p><pre><code>指令（参数1 参数2）</code></pre><p>不同参数需要用<strong>空格</strong>或者<strong>分号</strong>隔开</p><p>指令无关大小写，<strong>参数</strong>和<strong>变量</strong>是大小写<strong>相关</strong>的</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ul><li><p><strong>cmake_minimum_required</strong>:指定cmake版本</p><pre><code class="lang-cmake">#cmake_minimum_required -指定cmake的最小版本要求cmake_minimum_required (VERSION 2.8.3)</code></pre></li><li><p><strong>project</strong>:定义工程名称</p><pre><code class="lang-cmake">#指定 project(projectname [CXX][C][java])project(HEllO CXX)#指定工程名称为HELLO 支持C++</code></pre></li><li><p><strong>set</strong>:显示的定义变量</p><pre><code class="lang-cmake">set(SRC sayhello.cpp hello.cpp)#定义一个SRC变量 引用SRC 相当于引用sayhello.cpp hello.cpp</code></pre></li><li><p><strong>include_directories </strong>向工程添加多个特定的头文件搜索路径</p><p>假设文件夹路径是这样的格式</p><pre><code>└── myfolderinclude    └── othersfolderinclude</code></pre><pre><code class="lang-cmake">include_directories(../myfolderinclude ./othersfolderinclude)#类似于g++中的-I</code></pre></li><li><p><strong>link_directories</strong>:向工程添加多个指定的库文件搜索路径</p><pre><code class="lang-cmake">link_directories(../myfolderlib ./othersfolderlib)</code></pre></li><li><p><strong>add_library</strong>:生成库文件</p><p>比较重要的语法</p><pre><code class="lang-cmake"># add-library(libname[SHARED|STATIC|MODULE][EXCLUDE_FORM_ALL]source1 source2 ..sourceN)#通过变量SRC （上方代码中定义的SRC变量引用）生成动态[SHARED] 的libhellp.so文件add_library(hello SHARED $&#123;SRC&#125;)#注意，变量的引用使用$&#123;&#125;</code></pre></li><li><p><strong>add_compile_options</strong>：添加编译参数</p><pre><code class="lang-cmake">add_compile_options(-Wall -std=c++ -O2)#分别添加的是警告显示，定义语言特性，优化级数</code></pre></li><li><p><strong>add_executable</strong> :生成可执行文件</p><pre><code class="lang-cmake">add_executable(main main.cpp)#将main.cpp编译为 mian</code></pre></li><li><p><strong>target_link_libraries</strong>为target链接的动态库</p><pre><code class="lang-cmake">#等价于g++ -l 编译器参数target_link_libraries(main hello)#将hello动态库链接到可执行文件main</code></pre></li><li><p><strong>add_subdirectory</strong>向当前的工程添加存放源文件的子目录，指定中间二进制和目标二进制的存放位置</p><pre><code class="lang-cmake">add_subdirectory(src)#添加一个src子目录,src中需要也有一个CMakelists.txt</code></pre></li><li><p><strong>aux_source_directory</strong> 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</p><pre><code class="lang-cmake">aux_source_directory(. SRC)#定义. （就是一个目录下所有的源文件） 为SRC变量add_exrcutable(mian $&#123;SRC&#125;)#引用SRC 生成可执行文件</code></pre></li></ul><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><ul><li><p><strong>CMAKE_CXX_FLAGS</strong>：编译选项</p><pre><code class="lang-cmake">#在CMAKE_CXX_FALGS编译选项后加 -std=c++11set(CMAKE_CXX_FALGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;)#类似CMAKE_CXX_FALGS+=-std=c++11</code></pre></li><li><p><strong>CMAKE_BUILDTYPE</strong>：编译类型</p><pre><code class="lang-cmake">set(CMAKE_BUILD_TYPE Debug)#编译为Debugset(CMAKE_BUILD_TYPE Release)#编译为Release</code></pre></li></ul><h3 id="CMake编译"><a href="#CMake编译" class="headerlink" title="CMake编译"></a>CMake编译</h3><p>手动编写CMakeLists.txt</p><h4 id="两种编译规则"><a href="#两种编译规则" class="headerlink" title="两种编译规则"></a>两种编译规则</h4><ul><li><p>​    子目录无CMakeLists.txt</p></li><li><p>​    子目录包含CMakeLists.txt</p></li></ul><h4 id="两种构建方式"><a href="#两种构建方式" class="headerlink" title="两种构建方式"></a>两种构建方式</h4><ul><li><p>内部构建（不用</p><pre><code>单纯的直接cmake 当前文件夹生成makefile再make 执行makefile 生成可执行文件等等，因为都生成在当前文件夹很乱，目录结构不清析。所以不用</code></pre></li></ul><ul><li><p>外部构建（常用</p><pre><code class="lang-bash">#在当前目录下新建一个build mkdir build #跳转cd build #执行cmake,执行上层主目录下的CMakelists.txtcmake .. #生成makefile和其他文件make #执行#所有的编译输出文件都存在了build目录中#互不干扰结构明了</code></pre></li></ul><h3 id="CMake在vs-code下的甜点"><a href="#CMake在vs-code下的甜点" class="headerlink" title="CMake在vs.code下的甜点"></a>CMake在vs.code下的甜点</h3><p>​        当我们需要在vs.code调试CMake代码生成的可执行文件的时候，可以设置launch.json和一个task.json的调试脚本<del>个人觉得，只是锦上添花的操作，除了tasks.josn,我们可以写bat，或者shell都可以而且代码更少</del>，达到可以直接运行调试的效果，不需要在修改源代码后，再手动输入cmake与make 重新编译，实现自动化操作</p><p>​        首先我们选择运行与调试默认生成的launch.json，给出一个文件目录的示例</p><pre><code class="lang-bash">.├── build│   ├── CMakeCache.txt│   ├── CMakeFiles/....│   ├── cmake_install.cmake│   ├── Makefile│   └── main#这个是生成的可执行文件├── CMakeLists.txt├── include│   ├── gun.h│   └── soilder.h├── main.cpp└── src    ├── gun.cpp    └── soilder.cpp</code></pre><p>根据文件目录我们将默认生成的launch.json进行改动</p><pre><code class="lang-json">&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) 启动&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/main&quot;,//这里需要更改为你的可执行文件            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;,                &#123;                    &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;,                    &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ],            &quot;preLaunchTask&quot;: &quot;Build&quot;, //这是里我们需要修改的地方            //上方代码的意思是，执行调试前的前置任务，所以我们需要再生成一个tasks.json文件            &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;//默认添加        &#125;    ]&#125;</code></pre><p>再编写一个简单的tasks.json，可以直接在vs.code终端菜单下直接生成一个简单的任务范例</p><pre><code class="lang-json">&#123;    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;options&quot;: &#123;        &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot;//指定工作区下的目录    &#125;,    &quot;tasks&quot;: [        &#123;            &quot;label&quot;: &quot;step1&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;cmake&quot;,            &quot;args&quot;: [                &quot;..&quot;  //参数            ]        &#125;,        &#123;            &quot;label&quot;: &quot;step2&quot;,            &quot;group&quot;: &#123;                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;:true            &#125;,            &quot;command&quot;: &quot;make&quot;,            &quot;args&quot;: [            ]        &#125;,        &#123;            &quot;label&quot;: &quot;Build&quot;,            &quot;dependsOrder&quot;: &quot;sequence&quot;,//依赖顺序设置为顺序执行            &quot;dependsOn&quot;:[   //顺序                &quot;step1&quot;,                &quot;step2&quot;            ]        &#125;    ]&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用VScode与CMake做C++开发环境</title>
      <link href="/2022/07/11/zatan01/"/>
      <url>/2022/07/11/zatan01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//v2-49a45b8c622434dbf79463ccab9fa627_720w.png" alt=""></p><h3 id="啥事cmake"><a href="#啥事cmake" class="headerlink" title="啥事cmake?"></a>啥事cmake?</h3><p>​        CMake 是一个开源、跨平台的工具，旨在构建、测试和打包您的程序。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。这套 CMake 工具由 Kitware 创建，以满足 ITK 和 VTK 等开源项目对强大的跨平台构建环境的需求。</p><p>​        说白了，这玩意只是个配置器，配置你的编译器该如何进行编译</p><h3 id="cmake的好处："><a href="#cmake的好处：" class="headerlink" title="cmake的好处："></a>cmake的好处：</h3><pre><code>&lt;center&gt;“Write once, run everywhere”&lt;/center&gt;</code></pre><p>​        非常好理解，就是只写一次，到处运行</p><p>​        对我来说就三个字：跨平台。</p><h3 id="cmake的缺点："><a href="#cmake的缺点：" class="headerlink" title="cmake的缺点："></a>cmake的缺点：</h3><p>​        缺点：麻烦，步骤繁多        </p><p>​        断点调试挺麻烦的，VScode里的插件可以，但是需要对luanch.json和tasks.json进行修改，尤其是出现多个目录多个源文件等大项目的编译，修改虽然不复杂，但是麻烦。想要调试添加额外配置参数来打印所执行的所有代码及行号，插入log等方式检查问题。</p><p>​        有这弱语言的共通问题，就是容易出问题。</p><p>总而言之，挺麻烦的</p><p><del>要不是最近需要将Qmake项目迁移到cmake，还真不想用这玩意</del></p><h3 id="利用CMake编译一个简单的C-程序"><a href="#利用CMake编译一个简单的C-程序" class="headerlink" title="利用CMake编译一个简单的C++程序"></a>利用CMake编译一个简单的C++程序</h3><p>首先vscode需要下载两个插件，CMAKE与C/C++,这些我默认就有，因为在下载之前就一直用着VS2022，模块化无脑安装。</p><p>然后配置CMake和MINGW环境变量，这些我默认也有，安装Qt自带，直接指向Qt/tools里的对应路径即可。</p><p>前提条件准备得那是相当充足。</p><p>直接就随便顺手写一个冒泡排序的小例子</p><pre><code>//创建这样一个目录结构└── src        └── sort.cpp└── include        └── sort.h└── main.cpp</code></pre><p>main.cpp</p><pre><code class="lang-c++">#include&lt;iostream&gt;using namespace std;#include&quot;sort.h&quot;int main()&#123;    int a[10]=&#123;3,1,2,4,5,6,8,9,10,7&#125;;    Sort sort;    sort(a);    for (int i = 0; i &lt; 10; i++)    &#123;        /* code */        cout&lt;&lt;a[i]&lt;&lt;endl;    &#125;    sort.test();    return 0;&#125;</code></pre><p>sort.h</p><pre><code class="lang-c++">#pragma once#include&lt;iostream&gt;using namespace std;class Sort&#123;    public:    int x[10];    int temp;    void test();    void operator()(int x[10])    &#123;        for(int i=0;i&lt;10;i++)        &#123;               for (int j = 0; j &lt; 10-i-1; j++)            &#123;                if(x[j]&lt;x[j+1])                &#123;                    temp=x[j];                    x[j]=x[j+1];                    x[j+1]=temp;                &#125;            &#125;        &#125;    &#125;&#125;;</code></pre><p>sort.cpp</p><pre><code>#include&quot;sort.h&quot;void Sort::test()&#123;    cout&lt;&lt;&quot;test\n&quot;;&#125;</code></pre><p>到这里，前提源文件准备工作结束</p><p>开始编写CMakelists.txt</p><pre><code class="lang-cmake">#这种写法非常简单，无脑摁写，但是不够直观project(Sorttest) #项目名称aux_source_directory(src SRC_SUB) #项目根目录下的所有子项目aux_source_directory(. SRC_CUR)  #同理add_executable(sort $&#123;SRC_SUB&#125; $&#123;SRC_CUR&#125;) #同理include_directories(include) #头文件包含目录</code></pre><pre><code class="lang-cmake">cmake_minimum_required(VERSION 3.0) #最低版本需求project(Sorttest) #项目名include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)#头文键包含#添加源文件add_executable(main               $&#123;PROJECT_SOURCE_DIR&#125;/src/main.cpp #这个路径看这个main.cpp位于哪里了                             $&#123;PROJECT_SOURCE_DIR&#125;/src/sort.cpp)</code></pre><p>后者相对前者直观一些，效果都是一样的</p><p>在CMakelist.txt视窗中按下快捷键</p><pre><code>shift+ctrl+p</code></pre><p>唤起</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711223231514.png" alt="image-20220711223231514"></p><p>选择CMake配置，一切自动化帮你构建build文件夹目录</p><p>再新终端下方 cd跳转到build目录中</p><p>输入以下指令</p><pre><code class="lang-powershell">cmake ..</code></pre><p>运行如下工具 (这个是根据build的中的Makefile中的规则经行对源文件进行编译)</p><pre><code>mingw32-make.exe</code></pre><p>可以看到运行后在Bulid目录下多出一个sort.exe</p><p>在终端中输入运行</p><pre><code>.\sort.exe</code></pre><p>既可以看到程序的输出结果：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711224250666.png" alt="image-20220711224250666"></p><p>至此编译到此结束</p>]]></content>
      
      
      <categories>
          
          <category> CMake,C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
            <tag> VScode </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础00</title>
      <link href="/2022/07/11/linux00/"/>
      <url>/2022/07/11/linux00/</url>
      
        <content type="html"><![CDATA[<h2 id="linux基础中的基础"><a href="#linux基础中的基础" class="headerlink" title="linux基础中的基础"></a>linux基础中的基础</h2><h3 id="linux-的基础命令"><a href="#linux-的基础命令" class="headerlink" title="linux  的基础命令"></a>linux  的基础命令</h3><h4 id="指令默认格式"><a href="#指令默认格式" class="headerlink" title="指令默认格式"></a>指令默认格式</h4><pre><code class="lang-bash">指令 [选项] [操作对象]</code></pre><p>注意：中括号代表的意思是可以省略内容不输入，一样可以运行该指令</p><p>默认打开终端</p><pre><code>Ctrl+Alt+T</code></pre><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>打印当前所在的目录</p><pre><code class="lang-bash">pwd</code></pre><p>打印当前目录下的文件与文件夹</p><pre><code class="lang-bash">ls</code></pre><p>ls的用法扩展：</p><pre><code class="lang-bash">ls [文件路径]#文件路径：#相对路径or绝对路径</code></pre><p>打开文件目录下的文件</p><pre><code class="lang-bash">ls 选项 [文件路径]#选项：指定方式显示</code></pre><p>选项：</p><pre><code class="lang-bash">-a #表示显示所有的(all)文件与文件夹，包括隐藏-l #表示详细列表的方式展示(list)-h #以可读性较高的形式显示</code></pre><ul><li><h4 id="cd-chanage-directory"><a href="#cd-chanage-directory" class="headerlink" title="cd(chanage directory)"></a>cd(chanage directory)</h4></li></ul><p>：跳转目录</p><pre><code class="lang-bash">cd  cd ~#作用都是直接回到家目录</code></pre><p>与ls类似的</p><pre><code class="lang-bash">cd [文件路径]#文件路径：#相对路径or绝对路径</code></pre><ul><li><h4 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a>mkdir(make directories)</h4></li></ul><pre><code class="lang-bash">mkdir myfolder #在当前的目录下创建一个mydir文件夹mkdir myfolder1 myfolder2#在当前目录下创建两个文件夹，分别是 myfolder1，myfolder2</code></pre><pre><code class="lang-bash">mkdir -p ~/a/b/c#-p 选项是必须的#当前家目录下(~)创建多层不存在的目录</code></pre><ul><li><h4 id="touch-change-file-timestamps"><a href="#touch-change-file-timestamps" class="headerlink" title="touch-change file timestamps"></a>touch-change file timestamps</h4></li></ul><p>作用：创建文件（虽然本意不是这个）</p><pre><code class="lang-bash">touch  test.txt#在当前目录下生成一个 test.txt文件touch ../test1  #（相对路径)#在当前目录的上级目录下生成一个 test1文件touch ~/test2  #(绝对路径)#在~（家)目录下生成一个 test2文件</code></pre><ul><li><h4 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm (remove )"></a>rm (remove )</h4></li></ul><p>删除指令</p><pre><code class="lang-bash">rm [选项] [路径]</code></pre><pre><code class="lang-bash">rm test.txt#删除文件rm ../test1#删除上级目录的文件rm ~/test2#在~（家)目录下删除test2文件</code></pre><p>删除文件夹和文件夹下的文件</p><pre><code class="lang-bash">rm -rf [文件夹路径]#删除文件夹</code></pre><ul><li><h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a>cp(copy)</h4></li></ul><p>作用：复制文件</p><pre><code class="lang-bash">cp [复制的文件路径] [副本的文件路径]cp ../test ./test.txt#上级的目录下的test文件复制到当前目录下 并且换了个名字（加了个.txt后缀名）</code></pre><p>复制文件夹</p><pre><code class="lang-bash">cp -r [文件夹路径] [副本文件夹的路径]#-r是递归的意思</code></pre><ul><li><h4 id="mv-move"><a href="#mv-move" class="headerlink" title="mv (move)"></a>mv (move)</h4></li></ul><p>作用：移动文件位置，或者重命名文件</p><pre><code class="lang-bash">mv test test.txt#重新命名test文件为 test.txt(在当前目录下)#等效 mv test ./test.txtmv test ../test.txt #重新命名并且移动到了上级目录中</code></pre><ul><li><h4 id="men-menu"><a href="#men-menu" class="headerlink" title="men (menu)"></a>men (menu)</h4><p>说明书目录:</p></li></ul><pre><code class="lang-bash">man ls#参看命令ls的手册#在man中无cd的手册#我们在cd help中可以看到man man #参看man的命令手册</code></pre><ul><li><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启</p><pre><code class="lang-bash">reboot#立即重启</code></pre></li></ul><ul><li><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>关机</p><pre><code class="lang-bash">shutdown -h [时间]shutdown -h now #立即关机</code></pre></li></ul><h3 id="文件的编辑"><a href="#文件的编辑" class="headerlink" title="文件的编辑"></a>文件的编辑</h3><ul><li><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>一句话：<strong>编辑器之神</strong></p><p>安装：(Ubuntu LTS 22.04)</p><p><del>想用的时候居然没有安装</del></p><pre><code class="lang-bash">sudo apt install vim#建议安装： ctags vim-doc vim-scripts#顺带一并安装#都是vim的插件sudo apt-get install ctagssudo apt-get install vim-docsudo apt-get install vim-scripts</code></pre><p><img src="https://img-blog.csdn.net/2018101511335895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9jeTY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="助记图"></p></li></ul><p>  这里不继续详细的说明，将会新开一篇文章来记录VIM 的使用</p><p>  简单的使用：</p><pre><code>  vim [file]  #直接打开文本</code></pre><p>  终端直接变成了文本编辑器</p><p>  键盘摁下 i 键</p><p>  可以可以看见左下角状态变更为 插入 （insert）</p><p>  此时即可以输入文本进行编辑了</p><p>  保存需摁下</p><pre><code>  shift</code></pre><p>  输入： </p><pre><code>  :w #保存文本  :q #退出vim编辑器</code></pre><ul><li><h4 id="geidt"><a href="#geidt" class="headerlink" title="geidt"></a>geidt</h4><p>纯文本的编辑器，ubuntu 都是自带的,默认的编辑器</p></li></ul><p>  简单的使用：</p><pre><code class="lang-bash">  vim [file]  #直接打开文本编辑框，</code></pre><p>  与vim不同点在于 弹出的geidt的编辑界面，对新手挺友好的</p><p>  直接按照Windows下的记事本使用即可</p><ul><li><h4 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h4><p>与Vim类似，但是比vim简单而且小巧</p><p>简单的使用:</p><pre><code class="lang-bash">nano [file]#终端变成nano界面</code></pre><p>指令都在下方直观的显示出来</p><p>修饰键是Ctrl ，使用起来非常简单</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习第一节|Qt基础</title>
      <link href="/2022/06/26/QTstudy/"/>
      <url>/2022/06/26/QTstudy/</url>
      
        <content type="html"><![CDATA[<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628200812272.png" alt=""></p><p>基于C++的跨平台的图形引擎</p><p>发行于1991年 <del>就记了个大概，不知道的咱可以百度不是</del></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.跨平台</p><p>2.接口简单</p><p>3.一定程度简化了内存回收</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.WPS</p><p>2.linux-KDE</p><p>3.vlc多媒体播放</p><h2 id="创建第一个Qt"><a href="#创建第一个Qt" class="headerlink" title="创建第一个Qt"></a>创建第一个Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111650699.png" alt=""></p><p>系统环境：windows11<br>软件环境：Qt6.2.3(MSVC 2019 64bit)</p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>一开始可以直接打开官方的Qt Creator，暂且不需要使用MSVS上进行调试开发，</p><pre><code>file-&gt; new project</code></pre><h4 id="选择模板（tempates"><a href="#选择模板（tempates" class="headerlink" title="选择模板（tempates)"></a>选择模板（tempates)</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110514448.png" alt=""></p><p>默认<strong>Qt widget application</strong>（最基本的，也是最常用的窗口应用）</p><p>新建文件名和选择路径需要注意：（名字 路径，都不要有中文）</p><h4 id="选择构建系统（build-system）"><a href="#选择构建系统（build-system）" class="headerlink" title="选择构建系统（build system）"></a>选择构建系统（build system）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110646484.png" alt=""></p><p>因为做的是第一个程序，要快速上手选择qmake（Qt自带，不过个人建议cmake）。</p><h4 id="细节（details）"><a href="#细节（details）" class="headerlink" title="细节（details）"></a>细节（details）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111032398.png" alt=""></p><p>名字都可以默认，也可以更改随喜好，注意事项（中文不行，空格禁止）</p><p><strong>重点在于Base class（基类）</strong></p><p>窗口类型介绍：QMainWindow、QWidget、QDialog三个类都可以用来创建窗口，可以直接使用，也可以继承后使用。</p><p>　　QMainWindow窗口包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式，也可以说是GUI程序的主窗口。</p><p>　　QDialog是对话框窗口的基类。对话框主要用来执行短期任务，或者与用户进行互动，它可以是模态的，也可以是非模态的。他没有菜单栏、工具栏、状态栏等。</p><p>　　如果是主窗口，就使用QMainWindow类；</p><p>　　如果是对话框，就使用QDialog类；</p><p>　　如果不确定，有可能作为顶层窗口，也有可能嵌入到其他窗口，就使用QWidget类。</p><p>​        第一个程序我们可以默认直接选QWidget类</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202512898.png" alt=""></p><p>这个是生成一个UI界面，一开始做第一个程序可以不选，因为需要学习一下UI底层的实现代码。</p><h4 id="Kits-选择"><a href="#Kits-选择" class="headerlink" title="Kits 选择"></a>Kits 选择</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202115437.png" alt=""></p><p>这里我因为安装时选择需要MSVC调试开发，所以会出现MSVC，默认有MInGW,一般可全选，创建第一个项目的时候不容易出错</p><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202912401.png" alt="">选择版本控制系统，一开始第一个程序用不上，实际是做大项目开发用的源代码管理工具选择，比如说我们常见的git ，svn等。具体可看这篇CSDN博文：<a href="https://blog.csdn.net/weixin_45627194/article/details/110050361">源代码管理工具 </a></p><p>点击完成至此，创建一个Qt项目完成</p><h4 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h4><pre><code>//ctrl / 注释//ctrl r 运行//ctrl b 编译//ctrl i 自动对齐//F4 快捷切换同名文件</code></pre><h3 id="生成的代码文件"><a href="#生成的代码文件" class="headerlink" title="生成的代码文件"></a>生成的代码文件</h3><h3 id="需要掌握的："><a href="#需要掌握的：" class="headerlink" title="需要掌握的："></a>需要掌握的：</h3><p>main.cpp:</p><pre><code class="lang-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;//argc为命令行变量的数量//*argv变量的数组int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);//a即为应用程序对象，有且仅有一个    Widget w;    //窗口对象 （子类widger ：public QWidget）    //默认不显示；    //需要以下函数调用，调用的是顶层窗口函数    w.show();    return a.exec();     //让应用程序对象进入消息循环机制    //类似while（true）    //触发条件退出循环结束程序    //堵塞你的代码运行    //与system(&quot;pause&quot;)作用类似    //之后的代码依旧会顺序执行。&#125;</code></pre><p>widget.cpp</p><pre><code>#include &quot;widget.h&quot;#include&lt;QDebug&gt;#include&lt;QPushButton&gt;Widget::Widget(QWidget *parent): QWidget(parent)//这不就是初始化列表么&#123;    //创建一个按钮    QPushButton *btn = new QPushButton;    //btn-&gt;show();//单独弹出一个顶层的窗口来弹出窗口控件    //所以我们需要将Btn对象依赖在Widget窗口中    btn-&gt;setParent(this);    //函数名直译，设置父母。    //给按钮显示值    btn-&gt;setText(&quot;第一个按钮&quot;);//    创建第二个按钮    QPushButton *btn2=new QPushButton(&quot;第二个按钮&quot;,this);//有参构造    //但是有问题，只会按照空间的大小创建窗口    //我们可以自己设定默认窗口大小    //可修改    resize(600,400);   //我想要窗口固定大小，就需要    setFixedSize(600,400);    //同理，按钮需要定义大小也可以    btn-&gt;resize(50,20);    //但是运行还是只有一个按钮没因为默认位置将第一个按钮覆盖显示了，我们需要移动他    btn2-&gt;move (100,100);    //这样我们就可以看到两个按钮了，这个时候我也可以更改应用标题    setWindowTitle(&quot;第一个Qt&quot;);    //问题：    //我们的按钮都是开辟于堆区，不用去考虑释放内存的问题吗    //引入对象树的概念    //setparent(this)    //关键函数：    //将这个类与类下的对象放入对象树中    //析构的时候   --接以下注释--&#125;Widget::~Widget()&#123;    qDebug(&quot;父类的析构&quot;);    //先执行自行添加的代码，然后    //底层在释放这个类之前判断是否有子类，如果有就找到子类析构，再执行自添加的代码，再判断，    //直到找不到子类，确认是最后一个子类后释放这个子类下的对象    //所以就会出现，先输出父类析构代码再输出子类的析构代码的情况&#125;</code></pre><h4 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h4><p>Qt的学习重点，Qt的引以为豪的部分。</p><p>怎了么理解信号与槽？</p><p>我们现看个例子：</p><p>我打开一盏灯，灯亮了</p><p>信号的发送者，发送具体信号，信号的接收者，槽函数：信号的处理</p><p>connect （信号的发送者，发送具体信号；信号的接收者，信号的处理）</p><p>信号槽的优点，松散耦合：可以理解为信号发送与接收者没啥关联，通过connect的链接两端耦合在一起</p><pre><code class="lang-c++">    //连接函数    connect(mybtn  ,&amp;QPushButton::clicked,this,&amp;Widget::close);    //参数1：信号发送者，参数2：信号这里填入地址；    //参数3：信号接收者，参数3；同样是地址槽（槽函数，执行行为）</code></pre><p>QT库中有现成的信号与槽函数，当然我们也可以自己写一个，具体实现：</p><p>更多内容在下一篇文章再说，<del>还没写呢。先玩游戏去辣</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628211036994.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Qt学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt6.2.3，C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觉得博客很空总想写点什么？</title>
      <link href="/2022/06/26/others1/"/>
      <url>/2022/06/26/others1/</url>
      
        <content type="html"><![CDATA[<h2 id="个人最近杂谈："><a href="#个人最近杂谈：" class="headerlink" title="个人最近杂谈："></a>个人最近杂谈：</h2><p>​        百无聊赖，不知道写些什么，也不知道要做些什么（虽然有一堆事请要做，但是就是不想干），想要说些什么，却不知道写啥，肚子里憋不出一点墨水，确实很久都没有翻过书了，既然开始建立了博客，就得写写博文，平常连论文都憋不出几个字，但是还得整些文化人的东西，果然有必要增加阅读量的，总不能一天到晚看番剧在评论区玩玩烂梗，总不能一直写大白文。 </p> <center> <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220626222334097.png" r style="zoom:40%;" /></center><p>​        最近在网络上看到的段子：奶酪洞越多，奶酪越少，而奶酪越多，奶酪洞越多，得出结论：奶酪越少，奶酪就越少；<br>​        乍一看，嗯，很合理。虽然仔细思考一看有很多漏洞，但是依旧合理，首先第一眼能看到最大的问题就是，结论纯纯的废话：<del>毕竟正在看这篇文章的一定在看这篇文章罢</del> </p><p>​        我们可以简单的分析一下，首先<strong>典型的演绎论证，需要：前提，论证，结论</strong>。 这个是我们常用的论证手段。这条段子咱们可以处理为：</p><p>​        前提：如果奶酪洞越多，奶酪越少。论证：奶酪越多，奶酪洞越多。</p><p>​        结论：奶酪越少，奶酪就越少；</p><p>​        前提乍一看是真，但是我的理解是：多和少这个概念其实是通过对比而言的，怎么定义多，怎么定义少？所以原前提对我个人而言是不能确定的（虽然一般都会默认比较的是自身的体重体积大小 的变化前与变化后）。我们需要让前提更严谨一些：有一个奶酪，体积重量大小都是一个固定的量，不会产生莫名其妙的增加或减少，只会通过奶酪洞的形式变化，如果奶酪洞越多，奶酪的重量大小和体积大小越少。这样就可以确定该前提为真。<br>​        虽然看都很合理，但是蕴含悖论：前提永远都是真的 ，看到论证实际上也都是为了配合前提而多说的废话，用来强调前提，而重要的是，结论也永远都是真的 奶酪越少，奶酪就越少；不谈语句问题。这也是个合理的论证，因为不存在一种情况，使得前提为真而结论为假。</p><p>​        总结：虽然合理但是，无效。</p><p>​        咳咳，扯远了<del>想到什么写什么，完全没有规划的那种</del> 来形容我现在的思想情况吧：学的越多越感觉自己懂得越少（拿段子来说的话，奶酪量可以相比脑容量了，自身就没啥奶酪，结果还要开洞/😢😢）</p><p>​        要搭建个博客，直到最近我都认为，搭建博客，需要买个服务器，注册域名，虽然不是必要的，但是有个属于自己的网址确实cool😎，然后找个网页模板就开始改（虽然确实没啥问题），最后将网页上传到服务器就够了。一开始确实是这么认为的，脑子里只有html，CSS，JS的一点概念我就屁颠屁颠来直接开整了，现在网络能拿到很多教程资源（感谢开源！），<del>但依旧磕磕绊绊换了无数个主题弄了个三天</del>，找免费图床,建反向代理，期中了解下node.js，和PHP，虽然有wordpress（这个虽然很方便也有很多现成的方案，但是也需要些折腾，<del>主要是不想买服务器,想白嫖</del>，而且在国内需要建站域名和网站都需要备案），最终选择了基于hexo的fluid的主题，期间用也有试过自建主题，发现需要了解的东西很多，从零开始写CSS和JS也太折磨我了，虽然我怕麻烦，但是为了解决gitalk的porxy代理问题花了一天时间找了的免费的无服务构建应用平台和免费好使的评论，最后做了一大堆查找了一大堆，才回过神，<strong>卧槽!我一开始不是只想找个地方记录我的平常的学习进度么？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 日常杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网上冲浪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章的技巧</title>
      <link href="/2022/06/25/hello-world/"/>
      <url>/2022/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        第一次利用Typora编写Md文件并且发布博客，有很多操作还是非常生疏，在这里记录个Md文件的文章编辑的常用代码。以供我啥时候突然给整忘了回来看看😁</p><p>​                                    <span id="more"></span></p><p>`                      </p><h3 id="文章阅读截止"><a href="#文章阅读截止" class="headerlink" title="文章阅读截止"></a>文章阅读截止</h3><p>​        将过长的文章截取，只显示代码上方的文章内容，避免文章过长的显示在博客主页（这个可以说是非常常用）</p><p>代码如下：</p><pre><code class="lang-bash">&lt;!-- more --&gt;</code></pre><h3 id="文章的新建命令"><a href="#文章的新建命令" class="headerlink" title="文章的新建命令"></a>文章的新建命令</h3><pre><code>hexo new [layout] &lt;title&gt;</code></pre><p>​        在github bash 中使用 该指令可以新建一个页面：</p><p>​        使用实例如下 ：</p><pre><code>hexo new post 标题</code></pre><p>​        可以在hexo根文件的中的_post的文件夹中发现新建了一个标题.md    ，头部信息如下</p><pre><code>title: 标题date: //时间tags: //标签categories:  //分类</code></pre><h3 id="草稿的新建命令"><a href="#草稿的新建命令" class="headerlink" title="草稿的新建命令"></a>草稿的新建命令</h3><pre><code>hexo new draft title</code></pre><p>​        在github bash 中使用 该指令可以新建一个草稿：</p><p>​        使用实例如下 ：</p><pre><code>hexo new draft 标题</code></pre><p>​        可以在hexo根文件的中的_drafts的文件夹中发现新建了一个标题.md    头部的信息如下</p><pre><code>title: 标题date: //时间tags: //标签categories:  //分类</code></pre><p>​        草稿不会显示在博客中，想要看到博客草稿需要在github bash 中使用如下指令：</p><pre><code>hexo s -draft</code></pre><p>​        该指令的作用除了在本地运行博客部署以外，可以在博客中访问草稿.</p><h3 id="front-Matter"><a href="#front-Matter" class="headerlink" title="front  Matter"></a>front  Matter</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//20200916181236318.png" alt=""></p><p>​    每个创建的MD文件都在头端插入了名为front  Matter预定义读取参数,就是上文所说的头部信息。<br>​    可以看见这张图是有水印的，我们可以利用MD的文件中的画图代码画出相同的信息：</p><center>|    参数    |       描述       |       默认值       || :--------: | :--------------: | :----------------: ||   layout   |       布局       |         无         ||   title    |       标题       |         无         ||    date    |    建立的日期    |    文件建立日期    ||   update   |    更新的日期    | 每次文件更新的日期 ||  comments  | 该文章的评论功能 |  默认每个文章开启  ||    tags    |       标签       |         无         || categories |       分类       |         无         |</center>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
