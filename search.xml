<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法|十大排序算法与C++实现</title>
      <link href="/2023/08/03/sort/"/>
      <url>/2023/08/03/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="十个经典的排序算法"><a href="#十个经典的排序算法" class="headerlink" title="十个经典的排序算法"></a>十个经典的排序算法</h1><p>咱们评判一个算法的指标呢，常常有以下这几种</p><ul><li>平均时间复杂度</li></ul><p>时间复杂度，用通俗的话来说，假设有n个数据元素。一个操作(分原子操作)的时间*n</p><ul><li>空间复杂度</li></ul><p>空间复杂度，用通俗的话来讲，还是n个数据元素，运行算法时使用的n个存储空间。</p><ul><li>排序方式</li></ul><p>外部排序或是内部排序，外部就是需要使用到除要排序的数据存储外的还要使用的临时存储空间。</p><p>而内部，就是直接在数据存储的内存进行操作。</p><ul><li>最好情况</li></ul><p>顾名思义，时间复杂度的</p><ul><li>最坏情况·1</li></ul><p>顾名思义，时间复杂度的</p><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><p>从头或者从尾部开始，比较相邻的两q个元素，比大小规则，满足就交换。</p><p>做完一轮，最后或者开头的元素会是最大/最小值，循环-1，继续一轮比较。如此反复。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p><h3 id="代码示范"><a href="#代码示范" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) <span class="built_in">swap</span>(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>先走一轮，先找最大，或者最小。找到了放到当前起始或结尾</p><p>再从剩余的元素找最大，或者最小。找到了放在当前起始或结尾,重复该操作。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p><h3 id="代码示范-1"><a href="#代码示范-1" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[min]&gt;arr[j]) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min) <span class="built_in">swap</span>(arr[i], arr[min]);   </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>从头或从尾，第一元素为准，然后与后方(或者前方)的一个元素比较，满足大或小的比较后，将其插入比较的第一元素的前方或后方。重复该操作</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p><h3 id="代码示范-2"><a href="#代码示范-2" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j != i) arr[j] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔"><a href="#希尔" class="headerlink" title="希尔"></a>希尔</h2><p>实际上是插入排序的改进版，不同的是它通过一个增量gap规则来进行插入排序。</p><p>将一个待排的数组元素，分成了gap增量组，这个gap值由数组总长/步长，假设设定步长为2 ， 总长有10，gap值 = 5；</p><p>每个组内的元素进行一次插入排序</p><p>总体排序后，然后缩小这个增量，gap = gap/步长 = 5/2 = 2,gap就为2；</p><p>每个组内的元素进行一次插入排序</p><p>总体排序后，然后缩小这个增量，gap = gap/步长 = 2/2 = 2,gap就为1；</p><p>最后只需要再执行一次插入排序就可以完成整个数组的排序。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="希尔排序"></p><h3 id="代码示范-3"><a href="#代码示范-3" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j != i) arr[j] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>思想其实就是分而治之。（蛮多算法其实就是这样的，比如上方的希尔排序起始分增量也算是）</p><p>对于排序，最快，最方便起始，就是有只有两个元素的比较是最快的。</p><p>归并的根本原理就是如此，就是把一组n个数的序列，折半分为两个序列，然后再将这两个序列再分，一直分下去，直到分为n个长度为1的序列。然后两两按大小归并。如此反复，直到最后形成包含n个数的一个数组。</p><p>这个反复分与治的操作，可以使用递归进行处理。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="归并排序"></p><h3 id="代码示范-4"><a href="#代码示范-4" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> mid,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">help</span><span class="params">(R-L+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> p1=L,p2=mid+<span class="number">1</span>,i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid &amp;&amp; p2&lt;=R)</span><br><span class="line">help[i++] = arr[p1]&gt;arr[p2] ? arr[p2++] : arr[p1++];</span><br><span class="line"><span class="keyword">while</span>(p1&lt;=mid)</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line"><span class="keyword">while</span>(p2&lt;=R)</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;R-L+<span class="number">1</span>;i++) </span><br><span class="line">        arr[L+i] = help[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">        <span class="comment">//递归分两份，跳出递归条件为L&lt;R</span></span><br><span class="line">        <span class="type">int</span> mid = L + ((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sort</span>(arr,L,mid);</span><br><span class="line"><span class="built_in">sort</span>(arr,mid+<span class="number">1</span>,R);</span><br><span class="line"><span class="built_in">merge</span>(arr,L,mid,R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> size )</span></span>&#123;</span><br><span class="line">    cout &lt;&lt;__FUNCTION__&lt;&lt;<span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(size &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr,<span class="number">0</span>, size<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="精简化"><a href="#精简化" class="headerlink" title="精简化"></a>精简化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> nums[N],tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=nums[j]) tmp[k++]=nums[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++]=nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=nums[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++]=nums[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r&amp;&amp;j&lt;k;i++,j++)&#123;</span><br><span class="line">        nums[i]=tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>抄大佬的。</del></p><h2 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h2><p>也是分儿治之，一个待排的序列，我们找准一个基准数，根据这个基准数，将这个分为两份序列，一份大于基准数（等于），一份小于基准数（等于）。</p><p>同理，这两份序列（等不等长取决于你所选取的基准数在序列中排序后所处的位置.），继续执行个选取基准数规则，继续分。直到基准数左右两边都找不到符合规则需要操作的元素。</p><p>一直分一直分，最后分成两个比较，当然是最快的比较方式了。</p><p>重复的操作，当然还是用递归来实现.</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="快速排序"></p><h3 id="代码示范-5"><a href="#代码示范-5" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = arr[L];</span><br><span class="line">    <span class="keyword">while</span> (L&lt;R)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span> (L&lt;R &amp;&amp; arr[R]&gt;p) </span><br><span class="line">R--;</span><br><span class="line"><span class="keyword">if</span> (L &lt; R) <span class="built_in">swap</span>(arr[L++], arr[R]);</span><br><span class="line"><span class="keyword">while</span> (L &lt; R &amp;&amp; arr[L] &lt;= p) </span><br><span class="line">            L++;</span><br><span class="line"><span class="keyword">if</span> (L &lt; R) <span class="built_in">swap</span>(arr[L], arr[R--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> L, <span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (L &lt; R)</span><br><span class="line">&#123;</span><br><span class="line">mid = <span class="built_in">quick</span>(arr, L, R);  </span><br><span class="line"><span class="built_in">qsort</span>(arr, L, mid - <span class="number">1</span>); </span><br><span class="line"><span class="built_in">qsort</span>(arr, mid+<span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> size )</span></span>&#123;</span><br><span class="line">    cout &lt;&lt;__FUNCTION__&lt;&lt;<span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">qsort</span>(arr,<span class="number">0</span>,size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="精简化-1"><a href="#精简化-1" class="headerlink" title="精简化"></a>精简化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> nums[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QS</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> record = nums[left], i = left - <span class="number">1</span>, j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; record);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; record);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) std::<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QS</span>(nums, left, j);</span><br><span class="line">    <span class="built_in">QS</span>(nums, j + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>构建大顶堆，通俗的来说，最大元素的放在堆顶，就是大顶堆。</p><p>完全二叉树是一种重要的树形结构类型，根据堆顶元素与字串元素的大小分为，大根堆，与小根堆。</p><p>实现问题：</p><ol><li>如何由无序序列建成一个堆？</li><li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li></ol><p>我们从待排序列创建一个堆</p><p>有两种方法</p><ul><li>先取值，在建堆。</li><li>边取值边建堆。</li></ul><p>创建堆，选取第一个值进行创建，一第一个作为母结点也就是根，对比后续的元素大小，大于替换根，原根变为子叶结点（也可能是根），同理，利用递归就可以得到一个堆，大根堆完全二叉树。</p><p>大根堆堆排序，取出堆顶元素，最后一个非子叶结点与堆顶的两个子节点进行对比，谁大交换成为堆顶，然后继续取出堆顶元素，重复迭代，直到输出最后一个元素。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p><h3 id="代码示范-6"><a href="#代码示范-6" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> max = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l &lt; size &amp;&amp; arr[l] &gt; arr[max])</span><br><span class="line">    max = l;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; size &amp;&amp; arr[r] &gt; arr[max])</span><br><span class="line">    max = r;</span><br><span class="line">  <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[max]);</span><br><span class="line">    <span class="built_in">heapify</span>(arr, max, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)(size / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">heapify</span>(arr, i, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">buildheap</span>(arr, size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="built_in">heapify</span>(arr, <span class="number">0</span>, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>该算法的的基本条件满足 <strong>已知数组元素范围的数组，线性的整数。</strong></p><p>所以需要知道该数组的最大值，最小值，自建一个[max]数组用来存储每个值出现的次数，初始化为0。比如说 25的值出现了一次，所以该数组第25加1（为了符合直觉所以+1）个元素计数加1。</p><p>最后再根据统计数组填充数组。</p><p>说实话这玩意过于简单，当数组元素范围很大，或是有很多计量等，所消耗的空间和时间都大。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p><h3 id="代码示范-7"><a href="#代码示范-7" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">auto</span> max = *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  <span class="type">ssize_t</span> countsize = max + <span class="number">1</span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(size)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(countsize)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">    count[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> arrindex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countsize; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      result[arrindex++] = i;</span><br><span class="line">      count[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h2><p>其实也是分而治之的思想。</p><p>设定固定数量桶，桶数量和存储的规则可以按照数组范围大小进行一个均分。</p><p>这个规则（映射函数）分出来的桶满足线性增加。</p><p>比如说52是待排元素中最大额值，2是最小值。通达的小为5（分少了桶内的排序会耗时增加，分多了存储的规则计算耗时也增加，同时内存也会增加，需要进行权衡）。</p><p>每个桶都可以使用不同或者相同的算法进行排序（当然，继续用桶排也不是不行哈）。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%A1%B6%E6%8E%92%E5%BA%8F.gif" alt="桶排序"></p><h3 id="代码示范-8"><a href="#代码示范-8" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size, <span class="type">size_t</span> bucketsize = <span class="number">5</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">auto</span> max = <span class="built_in">max_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  <span class="keyword">auto</span> min = <span class="built_in">min_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  <span class="type">int</span> bucketCount = ((*max) - (*min)) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketCount);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = (arr[i] - (*min)) / bucketsize;</span><br><span class="line">    buckets[index].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buckets[i].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (buckets[i].<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">InsertSort</span>(buckets[i], buckets[i].<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  arr = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h2><p>通过的数个十百的位的数进行排序（基数）</p><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><p>其实本质上也是桶排，不过这个桶是固定的从0到9十个桶</p><p>先从个位找起，再从十位，逐渐往高位找。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="基数排序"></p><h3 id="代码示范-9"><a href="#代码示范-9" class="headerlink" title="代码示范"></a>代码示范</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    buckets[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> iexp = (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">    result[buckets[iexp] - <span class="number">1</span>] = arr[i];</span><br><span class="line">    buckets[iexp]--;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">auto</span> max = *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  <span class="type">int</span> exp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">radix</span>(arr, size, exp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十大算法演示DEMO"><a href="#十大算法演示DEMO" class="headerlink" title="十大算法演示DEMO"></a>十大算法演示DEMO</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SORTTYPE</span> : <span class="type">int</span> &#123;</span><br><span class="line">  Bubble = <span class="number">0</span>,</span><br><span class="line">  Select,</span><br><span class="line">  Insert,</span><br><span class="line">  Shell,</span><br><span class="line">  Merge,</span><br><span class="line">  Quick,</span><br><span class="line">  Heap,</span><br><span class="line">  Counting,</span><br><span class="line">  Bucket,</span><br><span class="line">  Radix</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">  a ^= b;</span><br><span class="line">  b ^= a;</span><br><span class="line">  a ^= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">auto</span> max = *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  <span class="type">ssize_t</span> countsize = max + <span class="number">1</span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(size)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(countsize)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">    count[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> arrindex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countsize; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      result[arrindex++] = i;</span><br><span class="line">      count[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buckets</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    buckets[(arr[i] / exp) % <span class="number">10</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> iexp = (arr[i] / exp) % <span class="number">10</span>;</span><br><span class="line">    result[buckets[iexp] - <span class="number">1</span>] = arr[i];</span><br><span class="line">    buckets[iexp]--;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">auto</span> max = *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  <span class="type">int</span> exp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">radix</span>(arr, size, exp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> L, <span class="type">int</span> mid, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">help</span><span class="params">(R - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> p1 = L, p2 = mid + <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R)</span><br><span class="line">    help[i++] = arr[p1] &gt; arr[p2] ? arr[p2++] : arr[p1++];</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid)</span><br><span class="line">    help[i++] = arr[p1++];</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= R)</span><br><span class="line">    help[i++] = arr[p2++];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; R - L + <span class="number">1</span>; i++)</span><br><span class="line">    arr[L + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">    <span class="comment">// 递归分两份，跳出递归条件为L&lt;R</span></span><br><span class="line">    <span class="type">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">msort</span>(arr, L, mid);</span><br><span class="line">    <span class="built_in">msort</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">merge</span>(arr, L, mid, R);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">msort</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = arr[L];</span><br><span class="line">  <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R &amp;&amp; arr[R] &gt; p)</span><br><span class="line">      R--;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; R)</span><br><span class="line">      <span class="built_in">swap</span>(arr[L++], arr[R]);</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R &amp;&amp; arr[L] &lt;= p)</span><br><span class="line">      L++;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; R)</span><br><span class="line">      <span class="built_in">swap</span>(arr[L], arr[R--]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">    mid = <span class="built_in">quick</span>(arr, L, R);</span><br><span class="line">    <span class="built_in">qsort</span>(arr, L, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">qsort</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">qsort</span>(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> max = i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l &lt; size &amp;&amp; arr[l] &gt; arr[max])</span><br><span class="line">    max = l;</span><br><span class="line">  <span class="keyword">if</span> (r &lt; size &amp;&amp; arr[r] &gt; arr[max])</span><br><span class="line">    max = r;</span><br><span class="line">  <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[max]);</span><br><span class="line">    <span class="built_in">heapify</span>(arr, max, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildheap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)(size / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">heapify</span>(arr, i, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">buildheap</span>(arr, size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">    size--;</span><br><span class="line">    <span class="built_in">heapify</span>(arr, <span class="number">0</span>, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="type">int</span> temp = arr[i];</span><br><span class="line">    <span class="type">int</span> j = i;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j != i)</span><br><span class="line">      arr[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> gap = size / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + gap; j &lt; size; j += gap) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[j];</span><br><span class="line">        <span class="type">int</span> m = j - gap;</span><br><span class="line">        <span class="keyword">for</span> (m = j - gap; m &gt;= <span class="number">0</span> &amp;&amp; arr[m] &gt; temp; m -= gap) &#123;</span><br><span class="line">          arr[m + gap] = arr[m];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[m + gap] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[min] &gt; arr[j])</span><br><span class="line">        min = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != min)</span><br><span class="line">      <span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">        <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size, <span class="type">size_t</span> bucketsize = <span class="number">5</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">auto</span> max = <span class="built_in">max_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  <span class="keyword">auto</span> min = <span class="built_in">min_element</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr));</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">  <span class="type">int</span> bucketCount = ((*max) - (*min)) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketCount);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="type">int</span> index = (arr[i] - (*min)) / bucketsize;</span><br><span class="line">    buckets[index].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buckets[i].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (buckets[i].<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">InsertSort</span>(buckets[i], buckets[i].<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), buckets[i].<span class="built_in">begin</span>(), buckets[i].<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  arr = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> size, SORTTYPE sw, <span class="type">int</span> addarg = <span class="number">5</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\nSort:&quot;</span>;</span><br><span class="line">  <span class="keyword">switch</span> (sw) &#123;</span><br><span class="line">  <span class="keyword">case</span> Bubble:</span><br><span class="line">    <span class="built_in">BubbleSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Select:</span><br><span class="line">    <span class="built_in">SelectSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Insert:</span><br><span class="line">    <span class="built_in">InsertSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Shell:</span><br><span class="line">    <span class="built_in">ShellSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Merge:</span><br><span class="line">    <span class="built_in">MergeSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Quick:</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Heap:</span><br><span class="line">    <span class="built_in">HeapSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Counting:</span><br><span class="line">    <span class="built_in">CountingSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Bucket:</span><br><span class="line">    <span class="built_in">BucketSort</span>(arr, size, addarg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Radix:</span><br><span class="line">    <span class="built_in">RadixSort</span>(arr, size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sw;</span><br><span class="line">  <span class="type">int</span> argadd = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0 Bubble\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;1 Select\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;2 Insert\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;3 Shell\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;4 Merge\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;5 Quick\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;6 Heap\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;7 Counting\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;8 Bucket\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;9 Radix\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">    sw = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (sw == <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Bucket defult value : %d \n&quot;</span>, argadd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">    sw = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (sw == <span class="number">8</span>) &#123;</span><br><span class="line">      argadd = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">73</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">59</span>&#125;;</span><br><span class="line">  <span class="type">int</span> size = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">sort</span>(a, size, (SORTTYPE)sw, argadd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL与C++的环境开发</title>
      <link href="/2023/08/01/mysql/"/>
      <url>/2023/08/01/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>关系数据库：表组成的数据库</strong></p><p>Nosql数据库： 非关系数据库，并非由表构成，多是Key-value数据库，文件数据库，图等。</p><p><strong>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</strong></p><ul><li>1.数据以表格的形式出现</li><li>2.每行为各种记录名称</li><li>3.每列为记录名称所对应的数据域</li><li>4.许多的行和列组成一张表单</li><li>5.若干的表单组成database</li></ul><p>数据库：就是数据表的集合</p><p>数据表：表是数据的矩阵，在一个数据库的表看起来像一个简单的电子表格。</p><p>表还有功能，视图，和过程。本文着重数据表的理解</p><p>列：一列数据元素，包含了相同类型的数据</p><p>行：一行元组或记录，是一组相关的数据</p><p>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性（可以理解为多余的重复数据？不按单条规则的存放的，单条数据废了，还能通过冗余数据推出出现错误的数据信息）</p><p><strong>主键：主键是唯一的，一个数据表中只能包含一个主键，通过主键来查询数据</strong>（唯一性数据，比如说唯一的编号数据）</p><p>索引: 利用索引快速访问数据表中的特定信息。索引是对数据表中一列或多列的值进行排序的一种结构，所以索引也是要占存储空间的，类似书籍的目录（差异性大于男/女）。</p><p>外键</p><p><strong>数据库服务器，提供数据库服务的服务器，</strong></p><p><strong> MySql 一般使用3306端口作为对外的服务端口，多个数据库服务器可以集群工作。</strong></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>性能相对卓越，服务稳定，很少出现异常。</li><li>开放源码无版权制约，自主性及使用成本低</li><li>用户使用活跃，社区完善</li><li>体积小，安装方便，易于维护</li><li>口碑效应，十个企业无需考虑就用，LAMP，LNMP流行架构</li><li>支持多种操作系统，提供多种API接口，支持多种开发语言。</li></ul><h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p>B/S系统架构，网站服务器，网站服务器再访问数据库服务器。</p><p>C/S系统架构，客户端，可直接连接数据库服务器</p><p>分布式系统软件</p><p>集群系统软件</p><p>大规模集群软件，云端服务。</p><h3 id="演变"><a href="#演变" class="headerlink" title="演变"></a>演变</h3><p>这是随数据量的技术演进。</p><ol><li>简单应用，数据量比较小，访问强度低</li><li>垂直拆分，数据库多个表，多个表再拆分为服务器。</li><li>主从结构，主服务器写，多个从服务器读。</li><li>水平拆分，数据库多条数据，数据分片，上设备。</li><li>云计算，用户访问云服务器云端，云端再找多个服务器。</li></ol><h2 id="MySQL开发环境的配置"><a href="#MySQL开发环境的配置" class="headerlink" title="MySQL开发环境的配置"></a>MySQL开发环境的配置</h2><p>mysql 开发头文件和库文件</p><p>mysql的执行和关闭，都是通过官方提供的SDK 文件</p><p>可以使用MySQL的SDK ，可以使用相当于静态的mysqllient.lib。也可以使用动态库</p><p>需要注意的是，MySQL的库都是64位的。</p><h2 id="MySQL数据库的连接"><a href="#MySQL数据库的连接" class="headerlink" title="MySQL数据库的连接"></a>MySQL数据库的连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_real_connect();</span><br></pre></td></tr></table></figure><ul><li>mysql 初始化过的mysql对象</li><li>host 服务器地址</li><li>user 连接服务器使用 用户</li><li>password 密码</li><li>db 连接服务器所使用的库</li><li>port 连接服务器的端口</li><li>unix_socket：unix的套接字的连接方式</li><li>clientflg 一般情况下默认为0<ul><li>CLIENT_CAN_HANDLE_EXPLIRED_PASSWORDS 尝试旧密码</li><li>CLIENT_COMPRESS</li><li>CLIENT FOUND ROWS</li><li>CLIENT_IGNORE_SIGPIPE</li><li>CLIENT IGNORE SPACE</li><li>CLIENT_INTERACTIVE 超时设置。</li><li>CLIENT_LOCAL_FILES</li><li>CLIENT_MULTI_STATEMENTS 兼容多个语句</li><li>CLIENT_NO_SCHEMA//废弃</li><li>CLIENT_ODBC//废弃</li><li>CLIENT_OPTIONAL_RESULTSET_METADATA 高频小数据的查询应答优化</li><li>CLIENT_SSL</li><li>CLIENT_REMEMBER_OPTIONS</li></ul></li></ul><h2 id="MySQL-数据类型以及对应的C-C-类型"><a href="#MySQL-数据类型以及对应的C-C-类型" class="headerlink" title="MySQL 数据类型以及对应的C/C++类型"></a>MySQL 数据类型以及对应的C/C++类型</h2><p>mySQL 中的数据类型（INTEGER,DECIMAL,DATETIME)</p><p>INTEGER: TINYINT, SMALLINT, MEDIUMINT,INT ,BIGINT</p><p>对应的C/C++:char,short int ,int ,int64_t</p><p>DECIMAL:FLOAT，DOUBLE,DECIMAL</p><p>对应的C/C++:float,double,bouble==long double</p><p>DATETIME: DATE,TIME, YEAR,DATETIME, TIMESTAMP</p><p>对应的C/C++: struct tm ,tm, int int ,tm,time_t’</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>&#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;</span><br><span class="line">    <span class="type">int</span> tm_min;</span><br><span class="line">    <span class="type">int</span> tm_hour;</span><br><span class="line">    <span class="type">int</span> tm_mday;</span><br><span class="line">    <span class="type">int</span> tm_mon;</span><br><span class="line">    <span class="type">int</span> tm_year;</span><br><span class="line">    <span class="type">int</span> tm_wday;</span><br><span class="line">    <span class="type">int</span> tm_ydey;</span><br><span class="line">    <span class="type">int</span> tm_isdst;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL 中的文本数据类型 TEXT BLOB;</p><p>TEXT: NCHAR,CHAR,NVARCHAR,VARCHAR,TINYTEXT,TEXT,MEDIUMTEXI,LONGTEXT;</p><p>对应的C/C++: unsigned char<em> ,char</em>, unsigned char<em> , char</em> ,char[256],string,string ,string.</p><p>BLOB:<br>BLOB, TINYBLOB,MEDIUMBLOB,LONGBLOB</p><p>对应的C/C++ : char*</p><h2 id="MySQL-命令的执行"><a href="#MySQL-命令的执行" class="headerlink" title="MySQL 命令的执行"></a>MySQL 命令的执行</h2><p>执行命令的过程</p><ul><li>发送SQL命令</li><li>获取SQL执行结果</li><li>解析获取到的结果</li></ul><p>发送SQL命令接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> STDCALL <span class="title">mysql_real_query</span><span class="params">(MYSQL* mysql, <span class="type">const</span> <span class="type">char</span>* q,<span class="type">unsigned</span> <span class="type">long</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>q是SQL指令，length是指令的长度</li></ul><p>获取SQL执行结果接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL_RES  *STDCALL <span class="title">mysql_use_result</span><span class="params">(MYSQL * mysql)</span></span>;</span><br></pre></td></tr></table></figure><p>释放结果接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> STDCALL <span class="title">mysql_free_result</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br></pre></td></tr></table></figure><p>获得结果集列的数量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> STDCALL <span class="title">mysql_num_fields</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br></pre></td></tr></table></figure><p>获得结果集行的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> STDCALL <span class="title">mysql_num_rows</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br></pre></td></tr></table></figure><p>取结果中的行接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL_ROW STDCALL <span class="title">mysql_fetch_row</span><span class="params">(MYSQL_RES* res)</span></span>;</span><br></pre></td></tr></table></figure><p>获取每一行的长度接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span>* STDCALL <span class="title">mysql_getch_length</span><span class="params">(MYSQL_RES* res)</span></span></span><br></pre></td></tr></table></figure><p>取结果中的列接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL_FIELDS STDCALL <span class="title">mysql_fetch_fields</span><span class="params">(MYSQL_RES* res)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="MySQL-创建用户"><a href="#MySQL-创建用户" class="headerlink" title="MySQL 创建用户"></a>MySQL 创建用户</h2><p><strong>创建用户语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;范围&#x27;IDENTIFIED BY&#x27;密码&#x27;</span><br></pre></td></tr></table></figure><ul><li>范围包括 ip, localhost , % </li><li>ip只能从指定地址上登陆</li><li>localhost只能本机登录</li><li>% 表示任何地址都能路</li></ul><p>创建用户后需要授权操作表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT privileges ON databasename.tablename TO &#x27;用户名&#x27;@&#x27;范围&#x27;</span><br></pre></td></tr></table></figure><p>privileges权限</p><ul><li>SELECT,INSERT,UPDATE, DELETE</li><li>CREATE,DROP, ALTER,EXECUTE</li><li>INDEX,REFERENCES,ALTER ROUTINE</li><li>CREATE ROUTINE,CREATE TEMPORARY,</li><li>SHOW VIEW, LOCK TAQBLES</li><li>ALL</li></ul><p>databasename是库的名字，可以填入*代表所有</p><p>tablename 是表的名字，同样可以填入*代表所有。</p><h2 id="再学习库与表等数据创建之前需要学会的"><a href="#再学习库与表等数据创建之前需要学会的" class="headerlink" title="再学习库与表等数据创建之前需要学会的"></a>再学习库与表等数据创建之前需要学会的</h2><h3 id="首先就是备份"><a href="#首先就是备份" class="headerlink" title="首先就是备份"></a>首先就是备份</h3><p>mysql的命令语句也可以使用&gt;&gt; 和&lt;&lt; 导入和导出数据库数据。</p><p>使用 SELECT … INTO OUTFILE 语句导出数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `table_name` INTO OUTFILE &#x27;./data.txt&#x27;;</span><br></pre></td></tr></table></figure><p>或是输出为CSV格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `table_name` INTO OUTFILE &#x27;./data.txt&#x27;;</span><br><span class="line"> FIELDS TERMINATED BY&#x27;,&#x27;ENCLOSED BY&#x27;&#x27;&#x27;&#x27;</span><br><span class="line"> LINES TERNUBATED BY&#x27;\r\n&#x27;;</span><br></pre></td></tr></table></figure><p>在下面的例子中，生成一个文件，各值用逗号隔开，该格式可以被许多程序使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT a,b,a+b INTO OUTFILE &#x27;./data.text&#x27;</span><br><span class="line">FIELDS TERMINATED BY &#x27;,&#x27; OPTIONALLY ENCLOSED BY &#x27;&#x27;&#x27;&#x27;</span><br><span class="line">LINES TERMINATED BY&#x27;\n&#x27;</span><br><span class="line">FROM `test_table`;</span><br></pre></td></tr></table></figure><p>需要注意的是，文件的路径，与权限。(特别是LINUX。干啥都要提权。)</p><p>windows需要写绝对路径，MySQL 安装时 my.ini 中有个设置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Secure File Priv.</span></span><br><span class="line"><span class="attr">secure-file-priv</span>=<span class="string">&quot;C:/ProgramData/MySQL/MySQL Server 8.0/Uploads&quot;</span></span><br></pre></td></tr></table></figure><p>输出的安全的绝对路径+ 文件名。</p><h3 id="然后就是恢复"><a href="#然后就是恢复" class="headerlink" title="然后就是恢复"></a>然后就是恢复</h3><p>其实与备份一样,输入也是需要安全的绝对路径和文件名才可以恢复</p><p>MySQL提供了LOAD DATA INFILE 语句来插入数据。以下实例中将从当前目录中读取文件dump.txt ，将该文件中的数据插入到当前数据库的mytbl表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA LOCAl INFILE &#x27;dump.txt&#x27; INTO TABLE `mytbl`;</span><br></pre></td></tr></table></figure><p>如果需要指定读取的列值的分割符和行尾标记，但是默认的标记是定位符和换行符。</p><p>量个命令的FIELDS和LINES子句的语法是一样的。同时被指定是，FIELDS必须在LINES前</p><p>FIELD三种子句 TERMINATED BY | OPTIONALLY | ENCLOSED BY | ESCAPED BY 用户必须指定其中的一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD  DATA LOCAL INFILE &#x27;dump.txt&#x27; INTO TABLE `mytbl`</span><br><span class="line">FIELDS TERMINATED BY&#x27;:&#x27;</span><br><span class="line">LINES TERMINATED BY&#x27;\r\b&#x27;;</span><br></pre></td></tr></table></figure><p>LOAD DATA默认情况下是按照数据文件中的列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，需要指定列的顺序。</p><p>列的顺序是abc 但是插入表应为bca</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA LOCAL INFILE &#x27;dump.txt&#x27;</span><br><span class="line">INTO TABLE `mytbl`(b,c,a);</span><br></pre></td></tr></table></figure><p>以上是5版本的处理方式，而8的版本指定会报错，这是由于8的安全机制所导致的</p><p>在8的版本中，想要上传文件给服务器SQL ，需要进行额外的设置。</p><ul><li><p>客户端进行连接数据库时，FLAG 设置为 CLIENT_LOCAL_FILES；</p></li><li><p>LOAD DATA 语句出现1148错误的处理方式为：</p><ul><li><p>服务端设置全局的 LOCAL_INFILE 参数为 1 ；</p></li><li><p>并且服务端本地执行如下CMD命令(必须服务端拿到文件)</p></li><li><p>```shell<br>mysqlimport.exe -u root -p password —local databasename<br>“C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/table_test.txt”<br>—fields-terminated-by=”,” —lines-terminated-by=”\r\n”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## MySQL仓库基操</span><br><span class="line"></span><br><span class="line">### 创建仓库</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">CREATE DATABASE databasename</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>databasename为要创建的库名字，创建好后需要赋予库的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL ON databasename.tablename  privileges TO &#x27;user&#x27;@&#x27;范围&#x27;</span><br></pre></td></tr></table></figure><h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE databasename</span><br></pre></td></tr></table></figure><h3 id="切换库"><a href="#切换库" class="headerlink" title="切换库"></a>切换库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE databasename</span><br></pre></td></tr></table></figure><h2 id="MySQL表基操"><a href="#MySQL表基操" class="headerlink" title="MySQL表基操"></a>MySQL表基操</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>:red_circle:<strong>注意：表的语句是 `` 不是 ‘’ </strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `tablename` (</span><br><span class="line">`列名称` 数据类型 #关键字列表 #默认值</span><br><span class="line">......</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>关键字列表:</p><ul><li>AUTO_INCREMENT  自动递增 适用于整型数据</li><li>NOT NULL 非空</li><li>NULL 可谓空</li><li>PRIMARY KEY 是主键 ，<strong>是主键需要指定数据的长度，且该数据类型必须是定长的数据类型。</strong></li><li>UNSIGEND 无符号</li><li>DEFAULT 默认值</li><li>UNIQUE 唯一，要么为NULL要么唯一</li><li>ZEROFILL  0填充，如果没有指定，默认填充0</li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE `tablename`</span><br></pre></td></tr></table></figure><h2 id="MySQL数据基操"><a href="#MySQL数据基操" class="headerlink" title="MySQL数据基操"></a>MySQL数据基操</h2><p>想MySQL 数据表插入数据通用的 INSERT INTO SQL 语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `table_name`(field1, field2, .... ,fieldN)</span><br><span class="line">VALUES</span><br><span class="line">(value1, value2, .... ,valueN);</span><br></pre></td></tr></table></figure><p>如果是字符型数据用””表明，需要注意使用转义字符 ， 和源码的编码问题。</p><h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM `table_name` #WHERE Clause</span><br><span class="line">DELETE FROM `table_name` WHERE `field` = value</span><br></pre></td></tr></table></figure><ul><li>如果没有指定where的子句，MySQL表中的所有记录将被全部删除</li></ul><h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `table_name` SET field1=new-value1,field2=new-value2, ....</span><br><span class="line">#WHERE Clause</span><br></pre></td></tr></table></figure><ul><li>你可以同时更新一个或者多个字段。</li><li>你可以在WHERE子句中指定任何条件</li><li>你可以在一个单独表中同时更新数据</li><li>当你需要更新数据表中的指定行的数据是，WHERE 子句是非常有用的。</li></ul><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT `table_name1`.column_name,`table_name2`.cloumn_name...</span><br><span class="line">FORM `table_name1`,`table_name2` ...</span><br><span class="line">#WHERE Clause</span><br><span class="line">#LIMIT N OFFSET M</span><br></pre></td></tr></table></figure><ul><li>查询语句可以查询多个表，表之间都好分割，并且可以使用WHERE来设定查询条件</li><li>可以使用*号代替其他字段</li><li>可以使用LIMIT来设定范围记录数 </li><li>OFFSET M指定开始查询的数据偏移量</li></ul><p>mysql_use_result 这个函数，执行后，需要执行一次fetch，才能得到结果。</p><p>mysql_store_result 这个函数，执行后立刻查询，可以立刻得到结果。</p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1,expression2, ... ,expression_n</span><br><span class="line">FORM tables</span><br><span class="line">#WHERE conditions</span><br><span class="line">UNION #ALL| DISTNCT</span><br><span class="line">SELECT expression1,expression2, ... ,expression_n</span><br><span class="line">FORM tables</span><br><span class="line">#WHERE conditions</span><br></pre></td></tr></table></figure><ul><li>expression1,expression2, … ,expression_n 表示要检索的列</li><li>tables 要检索的数据表</li><li>WHERE 可选的检索条件</li><li>DISTINCT　可选，删除结果集中重复的数据。默认情况下默认DISTINCT</li><li>ALL　可选，返回所有的数据（包括重复</li></ul><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>当数据库的表的接近百万级，数据查询的需求远远大于数据更新的需求时，可以建立索引，牺牲一定的内存占用，来提高查询效率</p><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>最基本的索引，没有任何的限制。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure><p>索引列的值必须唯一，但也允许有空值，如果是组合索引，则列值的组合必须唯一。</p><h3 id="乱码统一编码设置"><a href="#乱码统一编码设置" class="headerlink" title="乱码统一编码设置"></a>乱码统一编码设置</h3><p>用于设置本地控制体编码的接口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;en_GB.UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建表之后执行以下</p><p>SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES &#x27;utf8&#x27;;</span><br><span class="line">SET CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><p><strong>并且编译源码本身也要统一编码UTF8（无签名）.</strong></p><h2 id="MySQL事物"><a href="#MySQL事物" class="headerlink" title="MySQL事物"></a>MySQL事物</h2><p>处理复杂的业务，复杂数据的处理，需要事务。</p><p>在MySQL中只有使用了Inoodb 数据库引擎的数据库或表才支持事物。</p><p>事物的处理可以用来维护数据库的完整性，保证成堆的SQL语句要么全部执行要么全部不执行</p><p>因此，事物用来管理insert update delete语句，并且需具有以下特性</p><ul><li>一致性</li><li>原子性</li><li>隔离性：多个并发事务的处理，隔离也有不同级别，读未提交，读提交，可重复读，串行化。</li><li>持久性</li></ul><p>事物控制语句</p><ul><li>BEGIN 或 STARTTRANSACTION 显式的开启一个事物；</li><li>COMMIT 也可以使用 COMMINT WORK，两者等价。提交事务，并使数据库修改成为永久性修改</li><li>ROLLBACK/ROLLBACK WORK ，回滚，结束用户的食物，并撤销正在进行所有未提交的修改。</li><li>SAVEPOINT identifier， 在事物中创建一个保存点,一个事务可有多个保存点</li><li>RELEASE SAVEPOINT identifier 释放保存点。无保存点报错</li><li>ROLLBACK TO identifier 回滚至保存点。</li><li>SET TRANSANCITION 用来设置事物的隔离级别。</li></ul><p>事物的处理的主要方法</p><ul><li><p>BEGIN ROLLBACK  COMMIT 来实现</p></li><li><p>用SET 改变MySQL的自动提交模式</p><ul><li>SET AUTOCOMMIT=0; 禁止自动提交 </li><li>SET AUTOCOMMIT=1; 开启自动提交</li></ul><p>C++ 操作MySQL中常常禁用自动提交后进行事物操作，最后在手动提交后，再重新开启自动提交。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> STDCALL <span class="title">mysql_commit</span><span class="params">(MYSQL* mysql)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> STDCALL <span class="title">mysql_rollback</span><span class="params">(MYSQL* mysql)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> STDCALL <span class="title">mysql_autocommit</span><span class="params">(MYSQL* mysql, <span class="type">bool</span> auto_mode)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h3><p>单独把这个拿出来说，是因为，对于自增的整形数据，ROLLBACK之后继续插入的数据。自增的值是继续被ROLLBACK的值。需要注意  </p><h2 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h2><p>创建一个触发器的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON `table_name` FOR EACH ROW trigger_stmt</span><br></pre></td></tr></table></figure><ul><li>trigger_name 触发器名称</li><li>trigger_time 触发器时机 <ul><li>BEFORE / AFTER</li></ul></li><li>trigger_event 触发事件<ul><li>INSERT</li><li>DELETE</li><li>UPDATA</li></ul></li><li>table_name  触发器要建立在哪个表。</li><li>trigger_stmt 触发器的程序体，可以是一条SQL语句或者是用 BEGIN 和 END 包含的多条语句</li></ul><p>根据触发器 time 和 event 的组合，可以有六种触发器。 </p><h2 id="MySQL内置函数"><a href="#MySQL内置函数" class="headerlink" title="MySQL内置函数"></a>MySQL内置函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><div class="table-container"><table><thead><tr><th><strong>函数</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>ASCII(s)</td><td>返回字符串 s 的第一个字符的 ASCII 码。</td><td>返回 CustomerName 字段第一个字母的 ASCII 码：  <code>SELECT ASCII(CustomerName) AS NumCodeOfFirstChar``FROM Customers;</code></td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串 s 的字符数</td><td>返回字符串 RUNOOB 的字符数  <code>SELECT CHAR_LENGTH(&quot;RUNOOB&quot;) AS LengthOfString;</code></td></tr><tr><td>CHARACTER_LENGTH(s)</td><td>返回字符串 s 的字符数</td><td>返回字符串 RUNOOB 的字符数  <code>SELECT CHARACTER_LENGTH(&quot;RUNOOB&quot;) AS LengthOfString;</code></td></tr><tr><td>CONCAT(s1,s2…sn)</td><td>字符串  s1,s2 等多个字符串合并为一个字符串</td><td>合并多个字符串  <code>SELECT CONCAT(&quot;SQL &quot;, &quot;Runoob &quot;, &quot;Gooogle &quot;, &quot;Facebook&quot;) AS ConcatenatedString;</code></td></tr><tr><td>CONCAT_WS(x,  s1,s2…sn)</td><td>同  CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符</td><td>合并多个字符串，并添加分隔符：  <code>SELECT CONCAT_WS(&quot;-&quot;, &quot;SQL&quot;, &quot;Tutorial&quot;, &quot;is&quot;, &quot;fun!&quot;)AS ConcatenatedString;</code></td></tr><tr><td>FIELD(s,s1,s2…)</td><td>返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</td><td>返回字符串 c 在列表值中的位置：  <code>SELECT FIELD(&quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);</code></td></tr><tr><td>FIND_IN_SET(s1,s2)</td><td>返回在字符串s2中与s1匹配的字符串的位置</td><td>返回字符串 c 在指定字符串中的位置：  <code>SELECT FIND_IN_SET(&quot;c&quot;, &quot;a,b,c,d,e&quot;);</code></td></tr><tr><td>FORMAT(x,n)</td><td>函数可以将数字 x 进行格式化 “#,###.##”, 将 x 保留到小数点后 n 位，最后一位四舍五入。</td><td>格式化数字 “#,###.##” 形式：  <code>SELECT FORMAT(250500.5634, 2);   -- 输出 250,500.56</code></td></tr><tr><td>INSERT(s1,x,len,s2)</td><td>字符串  s2 替换 s1 的 x 位置开始长度为 len 的字符串</td><td>从字符串第一个位置开始的 6 个字符替换为 runoob：  <code>SELECT INSERT(&quot;google.com&quot;, 1, 6, &quot;runnob&quot;); -- 输出：runoob.com</code></td></tr><tr><td>LOCATE(s1,s)</td><td>从字符串 s 中获取 s1 的开始位置</td><td>获取 b 在字符串  abc 中的位置：  <code>SELECT LOCATE(&#39;st&#39;,&#39;myteststring&#39;); -- 5</code>  返回字符串 abc 中 b 的位置：  <code>SELECT LOCATE(&#39;b&#39;, &#39;abc&#39;) -- 2</code></td></tr><tr><td>LCASE(s)</td><td>将字符串 s 的所有字母变成小写字母</td><td>字符串 RUNOOB 转换为小写：  <code>SELECT LCASE(&#39;RUNOOB&#39;) -- runoob</code></td></tr><tr><td>LEFT(s,n)</td><td>返回字符串 s 的前 n 个字符</td><td>返回字符串 runoob 中的前两个字符：  <code>SELECT LEFT(&#39;runoob&#39;,2) -- ru</code></td></tr><tr><td>LOWER(s)</td><td>将字符串 s 的所有字母变成小写字母</td><td>字符串 RUNOOB 转换为小写：  <code>SELECT LOWER(&#39;RUNOOB&#39;) -- runoob</code></td></tr><tr><td>LPAD(s1,len,s2)</td><td>在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len</td><td>将字符串 xx 填充到  abc 字符串的开始处：  <code>SELECT LPAD(&#39;abc&#39;,5,&#39;xx&#39;) -- xxabc</code></td></tr><tr><td>LTRIM(s)</td><td>去掉字符串 s 开始处的空格</td><td>去掉字符串 RUNOOB开始处的空格：  <code>SELECT LTRIM(&quot;  RUNOOB&quot;) AS LeftTrimmedString;-- RUNOOB</code></td></tr><tr><td>MID(s,n,len)</td><td>从字符串 s 的 n 位置截取长度为 len  的子字符串，同 SUBSTRING(s,n,len)</td><td>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：  <code>SELECT MID(&quot;RUNOOB&quot;, 2, 3) AS ExtractString; -- UNO</code></td></tr><tr><td>POSITION(s1  IN s)</td><td>从字符串 s 中获取 s1 的开始位置</td><td>返回字符串 abc 中  b 的位置：  <code>SELECT POSITION(&#39;b&#39; in &#39;abc&#39;) -- 2</code></td></tr><tr><td>REPEAT(s,n)</td><td>将字符串 s 重复 n 次</td><td>将字符串 runoob 重复三次：  <code>SELECT REPEAT(&#39;runoob&#39;,3) -- runoobrunoobrunoob</code></td></tr><tr><td>REPLACE(s,s1,s2)</td><td>将字符串 s2 替代字符串 s 中的字符串  s1</td><td>将字符串 abc 中的字符 a 替换为字符 x：  <code>SELECT REPLACE(&#39;abc&#39;,&#39;a&#39;,&#39;x&#39;) --xbc</code></td></tr><tr><td>REVERSE(s)</td><td>将字符串s的顺序反过来</td><td>将字符串 abc 的顺序反过来：  <code>SELECT REVERSE(&#39;abc&#39;) -- cba</code></td></tr><tr><td>RIGHT(s,n)</td><td>返回字符串 s 的后 n 个字符</td><td>返回字符串 runoob 的后两个字符：  <code>SELECT RIGHT(&#39;runoob&#39;,2) -- ob</code></td></tr><tr><td>RPAD(s1,len,s2)</td><td>在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len</td><td>将字符串 xx 填充到  abc 字符串的结尾处：  <code>SELECT RPAD(&#39;abc&#39;,5,&#39;xx&#39;) -- abcxx</code></td></tr><tr><td>RTRIM(s)</td><td>去掉字符串 s 结尾处的空格</td><td>去掉字符串 RUNOOB 的末尾空格：  <code>SELECT RTRIM(&quot;RUNOOB   &quot;) AS RightTrimmedString;  -- RUNOOB</code></td></tr><tr><td>SPACE(n)</td><td>返回  n 个空格</td><td>返回 10 个空格：  <code>SELECT SPACE(10);</code></td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果  s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1</td><td>比较字符串：  <code>SELECT STRCMP(&quot;runoob&quot;, &quot;runoob&quot;); -- 0</code></td></tr><tr><td>SUBSTR(s,  start, length)</td><td>从字符串 s 的 start 位置截取长度为  length 的子字符串</td><td>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：  <code>SELECT SUBSTR(&quot;RUNOOB&quot;, 2, 3) AS ExtractString; -- UNO</code></td></tr><tr><td>SUBSTRING(s,  start, length)</td><td>从字符串 s 的 start 位置截取长度为  length 的子字符串</td><td>从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：  <code>SELECT SUBSTRING(&quot;RUNOOB&quot;, 2, 3) AS ExtractString; -- UNO</code></td></tr><tr><td>SUBSTRING_INDEX(s,  delimiter, number)</td><td>返回从字符串 s 的第 number 个出现的分隔符 delimiter 之后的子串。   如果 number 是正数，返回第 number 个字符左边的字符串。   如果 number 是负数，返回第(number 的绝对值(从右边数))个字符右边的字符串。</td><td><code>SELECT SUBSTRING_INDEX(&#39;a*b&#39;,&#39;*&#39;,1) -- a``SELECT SUBSTRING_INDEX(&#39;a*b&#39;,&#39;*&#39;,-1)  -- b``SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(&#39;a*b*c*d*e&#39;,&#39;*&#39;,3),&#39;*&#39;,-1)  -- c</code></td></tr><tr><td>TRIM(s)</td><td>去掉字符串 s 开始和结尾处的空格</td><td>去掉字符串 RUNOOB 的首尾空格：  <code>SELECT TRIM(&#39;  RUNOOB  &#39;) AS TrimmedString;</code></td></tr><tr><td>UCASE(s)</td><td>将字符串转换为大写</td><td>将字符串 runoob 转换为大写：  <code>SELECT UCASE(&quot;runoob&quot;); -- RUNOOB</code></td></tr><tr><td>UPPER(s)</td><td>将字符串转换为大写</td><td>将字符串 runoob 转换为大写：  <code>SELECT UPPER(&quot;runoob&quot;); -- RUNOOB</code></td></tr></tbody></table></div><h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><div class="table-container"><table><thead><tr><th><strong>函数名</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回  x 的绝对值</td><td>返回 -1 的绝对值：  <code>SELECT ABS(-1) -- 返回1</code></td></tr><tr><td>ACOS(x)</td><td>求 x  的反余弦值(参数是弧度)</td><td><code>SELECT ACOS(0.25);</code></td></tr><tr><td>ASIN(x)</td><td>求反正弦值(参数是弧度)</td><td><code>SELECT ASIN(0.25);</code></td></tr><tr><td>ATAN(x)</td><td>求反正切值(参数是弧度)</td><td><code>SELECT ATAN(2.5);</code></td></tr><tr><td>ATAN2(n,  m)</td><td>求反正切值(参数是弧度)</td><td><code>SELECT ATAN2(-0.8, 2);</code></td></tr><tr><td>AVG(expression)</td><td>返回一个表达式的平均值，expression 是一个字段</td><td>返回 Products 表中Price 字段的平均值：  <code>SELECT AVG(Price) AS AveragePrice FROM Products;</code></td></tr><tr><td>CEIL(x)</td><td>返回大于或等于 x 的最小整数</td><td><code>SELECT CEIL(1.5) -- 返回2</code></td></tr><tr><td>CEILING(x)</td><td>返回大于或等于 x 的最小整数</td><td><code>SELECT CEILING(1.5); -- 返回2</code></td></tr><tr><td>COS(x)</td><td>求余弦值(参数是弧度)</td><td><code>SELECT COS(2);</code></td></tr><tr><td>COT(x)</td><td>求余切值(参数是弧度)</td><td><code>SELECT COT(6);</code></td></tr><tr><td>COUNT(expression)</td><td>返回查询的记录总数，expression 参数是一个字段或者 * 号</td><td>返回 Products 表中 products 字段总共有多少条记录：  <code>SELECT COUNT(ProductID) AS NumberOfProducts FROM Products;</code></td></tr><tr><td>DEGREES(x)</td><td>将弧度转换为角度</td><td><code>SELECT DEGREES(3.1415926535898) -- 180</code></td></tr><tr><td>n DIV m</td><td>整除，n  为被除数，m 为除数</td><td>计算 10 除于 5：  <code>SELECT 10 DIV 5; -- 2</code></td></tr><tr><td>EXP(x)</td><td>返回  e 的 x 次方</td><td>计算 e 的三次方：  <code>SELECT EXP(3) -- 20.085536923188</code></td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于 x 的最大整数</td><td>小于或等于 1.5 的整数：  <code>SELECT FLOOR(1.5) -- 返回1</code></td></tr><tr><td>GREATEST(expr1,  expr2, expr3, …)</td><td>返回列表中的最大值</td><td>返回以下数字列表中的最大值：  <code>SELECT GREATEST(3, 12, 34, 8, 25); -- 34</code>  返回以下字符串列表中的最大值：  <code>SELECT GREATEST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;);  -- Runoob</code></td></tr><tr><td>LEAST(expr1,  expr2, expr3, …)</td><td>返回列表中的最小值</td><td>返回以下数字列表中的最小值：  <code>SELECT LEAST(3, 12, 34, 8, 25); -- 3</code>  返回以下字符串列表中的最小值：  <code>SELECT LEAST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;);  -- Apple</code></td></tr><tr><td>LN</td><td>返回数字的自然对数，以 e 为底。</td><td>返回 2 的自然对数：  <code>SELECT LN(2); -- 0.6931471805599453</code></td></tr><tr><td>LOG(x) 或 LOG(base, x)</td><td>返回自然对数(以 e 为底的对数)，如果带有 base 参数，则 base 为指定带底数。</td><td><code>SELECT LOG(20.085536923188) -- 3``SELECT LOG(2, 4); -- 2</code></td></tr><tr><td>LOG10(x)</td><td>返回以  10 为底的对数</td><td><code>SELECT LOG10(100) -- 2</code></td></tr><tr><td>LOG2(x)</td><td>返回以  2 为底的对数</td><td>返回以 2 为底 6 的对数：  <code>SELECT LOG2(6); -- 2.584962500721156</code></td></tr><tr><td>MAX(expression)</td><td>返回字段 expression 中的最大值</td><td>返回数据表 Products 中字段 Price 的最大值：  <code>SELECT MAX(Price) AS LargestPrice FROM Products;</code></td></tr><tr><td>MIN(expression)</td><td>返回字段 expression 中的最小值</td><td>返回数据表 Products 中字段 Price 的最小值：  <code>SELECT MIN(Price) AS MinPrice FROM Products;</code></td></tr><tr><td>MOD(x,y)</td><td>返回  x 除以 y 以后的余数</td><td>5 除于 2 的余数：  <code>SELECT MOD(5,2) -- 1</code></td></tr><tr><td>PI()</td><td>返回圆周率(3.141593）</td><td><code>SELECT PI() --3.141593</code></td></tr><tr><td>POW(x,y)</td><td>返回  x 的 y 次方</td><td>2 的 3 次方：  <code>SELECT POW(2,3) -- 8</code></td></tr><tr><td>POWER(x,y)</td><td>返回  x 的 y 次方</td><td>2 的 3 次方：  <code>SELECT POWER(2,3) -- 8</code></td></tr><tr><td>RADIANS(x)</td><td>将角度转换为弧度</td><td>180 度转换为弧度：  <code>SELECT RADIANS(180) -- 3.1415926535898</code></td></tr><tr><td>RAND()</td><td>返回  0 到 1 的随机数</td><td><code>SELECT RAND() --0.93099315644334</code></td></tr><tr><td>ROUND(x)</td><td>返回离  x 最近的整数</td><td><code>SELECT ROUND(1.23456) --1</code></td></tr><tr><td>SIGN(x)</td><td>返回  x 的符号，x 是负数、0、正数分别返回 -1、0 和 1</td><td><code>SELECT SIGN(-10) -- (-1)</code></td></tr><tr><td>SIN(x)</td><td>求正弦值(参数是弧度)</td><td><code>SELECT SIN(RADIANS(30)) -- 0.5</code></td></tr><tr><td>SQRT(x)</td><td>返回x的平方根</td><td>25 的平方根：  <code>SELECT SQRT(25) -- 5</code></td></tr><tr><td>SUM(expression)</td><td>返回指定字段的总和</td><td>计算 OrderDetails 表中字段 Quantity 的总和：  <code>SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails;</code></td></tr><tr><td>TAN(x)</td><td>求正切值(参数是弧度)</td><td><code>SELECT TAN(1.75); -- -5.52037992250933</code></td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数值 x 保留到小数点后 y 位的值（与  ROUND 最大的区别是不会进行四舍五入）</td><td><code>SELECT TRUNCATE(1.23456,3) -- 1.234</code></td></tr></tbody></table></div><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><div class="table-container"><table><thead><tr><th><strong>函数名</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>ADDDATE(d,n)</td><td>计算起始日期 d 加上 n 天的日期</td><td><code>SELECT ADDDATE(&quot;2017-06-15&quot;, INTERVAL 10 DAY);-&gt;2017-06-25</code></td></tr><tr><td>ADDTIME(t,n)</td><td>时间  t 加上 n 秒的时间</td><td><code>SELECT ADDTIME(&#39;2011-11-11 11:11:11&#39;, 5)-&gt;2011-11-11 11:11:16 (秒)</code></td></tr><tr><td>CURDATE()</td><td>返回当前日期</td><td><code>SELECT CURDATE();-&gt; 2018-09-19</code></td></tr><tr><td>CURRENT_DATE()</td><td>返回当前日期</td><td><code>SELECT CURRENT_DATE();-&gt; 2018-09-19</code></td></tr><tr><td>CURRENT_TIME</td><td>返回当前时间</td><td><code>SELECT CURRENT_TIME();-&gt; 19:59:02</code></td></tr><tr><td>CURRENT_TIMESTAMP()</td><td>返回当前日期和时间</td><td><code>SELECT CURRENT_TIMESTAMP()-&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>CURTIME()</td><td>返回当前时间</td><td><code>SELECT CURTIME();-&gt; 19:59:02</code></td></tr><tr><td>DATE()</td><td>从日期或日期时间表达式中提取日期值</td><td><code>SELECT DATE(&quot;2017-06-15&quot;);  -&gt; 2017-06-15</code></td></tr><tr><td>DATEDIFF(d1,d2)</td><td>计算日期 d1-&gt;d2 之间相隔的天数</td><td><code>SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;)-&gt; -32</code></td></tr><tr><td>DATE_ADD(d，INTERVAL expr type)</td><td>计算起始日期 d 加上一个时间段后的日期</td><td><code>SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;,1)-&gt; 2011-11-12 11:11:11  (默认是天)`` ``SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;, INTERVAL 5 MINUTE)-&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似)</code></td></tr><tr><td>DATE_FORMAT(d,f)</td><td>按表达式 f的要求显示日期 d</td><td><code>SELECT DATE_FORMAT(&#39;2011-11-11 11:11:11&#39;,&#39;%Y-%m-%d %r&#39;)-&gt; 2011-11-11 11:11:11 AM</code></td></tr><tr><td>DATE_SUB(date,INTERVAL  expr type)</td><td>函数从日期减去指定的时间间隔。</td><td>Orders 表中 OrderDate 字段减去 2 天：  <code>SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate``FROM Orders</code></td></tr><tr><td>DAY(d)</td><td>返回日期值 d 的日期部分</td><td><code>SELECT DAY(&quot;2017-06-15&quot;); -&gt; 15</code></td></tr><tr><td>DAYNAME(d)</td><td>返回日期 d 是星期几，如 Monday,Tuesday</td><td><code>SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;)-&gt;Friday</code></td></tr><tr><td>DAYOFMONTH(d)</td><td>计算日期 d 是本月的第几天</td><td><code>SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;)-&gt;11</code></td></tr><tr><td>DAYOFWEEK(d)</td><td>日期  d 今天是星期几，1 星期日，2 星期一，以此类推</td><td><code>SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;)-&gt;6</code></td></tr><tr><td>DAYOFYEAR(d)</td><td>计算日期 d 是本年的第几天</td><td><code>SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;)-&gt;315</code></td></tr><tr><td>EXTRACT(type  FROM d)</td><td>从日期  d 中获取指定的值，type 指定返回的值。    type可取值为：   ·      MICROSECOND  ·      SECOND  ·      MINUTE  ·      HOUR  ·      DAY  ·      WEEK  ·      MONTH  ·      QUARTER  ·      YEAR  ·      SECOND_MICROSECOND  ·      MINUTE_MICROSECOND  ·      MINUTE_SECOND  ·      HOUR_MICROSECOND  ·      HOUR_SECOND  ·      HOUR_MINUTE  ·      DAY_MICROSECOND  ·      DAY_SECOND  ·      DAY_MINUTE  ·      DAY_HOUR  ·      YEAR_MONTH</td><td><code>SELECT EXTRACT(MINUTE FROM &#39;2011-11-11 11:11:11&#39;) -&gt; 11</code></td></tr><tr><td>FROM_DAYS(n)</td><td>计算从  0000 年 1 月 1 日开始 n 天后的日期</td><td><code>SELECT FROM_DAYS(1111)-&gt; 0003-01-16</code></td></tr><tr><td>HOUR(t)</td><td>返回  t 中的小时值</td><td><code>SELECT HOUR(&#39;1:2:3&#39;)-&gt; 1</code></td></tr><tr><td>LAST_DAY(d)</td><td>返回给给定日期的那一月份的最后一天</td><td><code>SELECT LAST_DAY(&quot;2017-06-20&quot;);-&gt; 2017-06-30</code></td></tr><tr><td>LOCALTIME()</td><td>返回当前日期和时间</td><td><code>SELECT LOCALTIME()-&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>LOCALTIMESTAMP()</td><td>返回当前日期和时间</td><td><code>SELECT LOCALTIMESTAMP()-&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>MAKEDATE(year,  day-of-year)</td><td>基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期</td><td><code>SELECT MAKEDATE(2017, 3);-&gt; 2017-01-03</code></td></tr><tr><td>MAKETIME(hour,  minute, second)</td><td>组合时间，参数分别为小时、分钟、秒</td><td><code>SELECT MAKETIME(11, 35, 4);-&gt; 11:35:04</code></td></tr><tr><td>MICROSECOND(date)</td><td>返回日期参数所对应的微秒数</td><td><code>SELECT MICROSECOND(&quot;2017-06-20 09:34:00.000023&quot;);-&gt; 23</code></td></tr><tr><td>MINUTE(t)</td><td>返回  t 中的分钟值</td><td><code>SELECT MINUTE(&#39;1:2:3&#39;)-&gt; 2</code></td></tr><tr><td>MONTHNAME(d)</td><td>返回日期当中的月份名称，如 November</td><td><code>SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;)-&gt; November</code></td></tr><tr><td>MONTH(d)</td><td>返回日期d中的月份值，1 到 12</td><td><code>SELECT MONTH(&#39;2011-11-11 11:11:11&#39;)-&gt;11</code></td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td><td><code>SELECT NOW()-&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>PERIOD_ADD(period,  number)</td><td>为 年-月  组合日期添加一个时段</td><td><code>SELECT PERIOD_ADD(201703, 5);  -&gt; 201708</code></td></tr><tr><td>PERIOD_DIFF(period1,  period2)</td><td>返回两个时段之间的月份差值</td><td><code>SELECT PERIOD_DIFF(201710, 201703);-&gt; 7</code></td></tr><tr><td>QUARTER(d)</td><td>返回日期d是第几季节，返回 1 到 4</td><td><code>SELECT QUARTER(&#39;2011-11-11 11:11:11&#39;)-&gt; 4</code></td></tr><tr><td>SECOND(t)</td><td>返回  t 中的秒钟值</td><td><code>SELECT SECOND(&#39;1:2:3&#39;)-&gt; 3</code></td></tr><tr><td>SEC_TO_TIME(s)</td><td>将以秒为单位的时间 s 转换为时分秒的格式</td><td><code>SELECT SEC_TO_TIME(4320)-&gt; 01:12:00</code></td></tr><tr><td>STR_TO_DATE(string,  format_mask)</td><td>将字符串转变为日期</td><td><code>SELECT STR_TO_DATE(&quot;August 10 2017&quot;, &quot;%M %d %Y&quot;);-&gt; 2017-08-10</code></td></tr><tr><td>SUBDATE(d,n)</td><td>日期  d 减去 n 天后的日期</td><td><code>SELECT SUBDATE(&#39;2011-11-11 11:11:11&#39;, 1)-&gt;2011-11-10 11:11:11 (默认是天)</code></td></tr><tr><td>SUBTIME(t,n)</td><td>时间  t 减去 n 秒的时间</td><td><code>SELECT SUBTIME(&#39;2011-11-11 11:11:11&#39;, 5)-&gt;2011-11-11 11:11:06 (秒)</code></td></tr><tr><td>SYSDATE()</td><td>返回当前日期和时间</td><td><code>SELECT SYSDATE()-&gt; 2018-09-19 20:57:43</code></td></tr><tr><td>TIME(expression)</td><td>提取传入表达式的时间部分</td><td><code>SELECT TIME(&quot;19:30:10&quot;);-&gt; 19:30:10</code></td></tr><tr><td>TIME_FORMAT(t,f)</td><td>按表达式 f 的要求显示时间 t</td><td><code>SELECT TIME_FORMAT(&#39;11:11:11&#39;,&#39;%r&#39;)11:11:11 AM</code></td></tr><tr><td>TIME_TO_SEC(t)</td><td>将时间  t 转换为秒</td><td><code>SELECT TIME_TO_SEC(&#39;1:12:00&#39;)-&gt; 4320</code></td></tr><tr><td>TIMEDIFF(time1,  time2)</td><td>计算时间差值</td><td><code>SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;);-&gt; 00:00:01</code></td></tr><tr><td>TIMESTAMP(expression,  interval)</td><td>单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和</td><td><code>SELECT TIMESTAMP(&quot;2017-07-23&quot;, &quot;13:10:11&quot;);-&gt; 2017-07-23 13:10:11</code></td></tr><tr><td>TO_DAYS(d)</td><td>计算日期 d 距离 0000 年 1 月 1 日的天数</td><td><code>SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;)-&gt; 366</code></td></tr><tr><td>WEEK(d)</td><td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td><td><code>SELECT WEEK(&#39;2011-11-11 11:11:11&#39;)-&gt; 45</code></td></tr><tr><td>WEEKDAY(d)</td><td>日期  d 是星期几，0 表示星期一，1 表示星期二</td><td><code>SELECT WEEKDAY(&quot;2017-06-15&quot;);-&gt; 3</code></td></tr><tr><td>WEEKOFYEAR(d)</td><td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td><td><code>SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;)-&gt; 45</code></td></tr><tr><td>YEAR(d)</td><td>返回年份</td><td><code>SELECT YEAR(&quot;2017-06-15&quot;);-&gt; 2017</code></td></tr><tr><td>YEARWEEK(date,  mode)</td><td>返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推</td><td><code>SELECT YEARWEEK(&quot;2017-06-15&quot;);-&gt; 201724</code></td></tr></tbody></table></div><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><div class="table-container"><table><thead><tr><th><strong>函数名</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回  x 的二进制编码</td><td>15 的 2 进制编码:  <code>SELECT BIN(15); -- 1111</code></td></tr><tr><td>BINARY(s)</td><td>将字符串 s 转换为二进制字符串</td><td><code>SELECT BINARY &quot;RUNOOB&quot;;-&gt; RUNOOB</code></td></tr><tr><td><code>CASE expression``  WHEN condition1 THEN result1``  WHEN condition2 THEN result2``  ...``  WHEN conditionN THEN resultN``  ELSE resultEND</code></td><td>CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。</td><td><code>SELECT CASE ``　　WHEN 1 &gt; 0``　　THEN &#39;1 &gt; 0&#39;``　　WHEN 2 &gt; 0``　　THEN &#39;2 &gt; 0&#39;``　　ELSE &#39;3 &gt; 0&#39;``　　END-&gt;1 &gt; 0</code></td></tr><tr><td>CAST(x AS  type)</td><td>转换数据类型</td><td>字符串日期转换为日期：  <code>SELECT CAST(&quot;2017-08-29&quot; AS DATE);-&gt; 2017-08-29</code></td></tr><tr><td>COALESCE(expr1,  expr2, …., expr_n)</td><td>返回参数中的第一个非空表达式（从左向右）</td><td><code>SELECT COALESCE(NULL, NULL, NULL, &#39;runoob.com&#39;, NULL, &#39;google.com&#39;);-&gt; runoob.com</code></td></tr><tr><td>CONNECTION_ID()</td><td>返回服务器的连接数</td><td><code>SELECT CONNECTION_ID();-&gt; 4292835</code></td></tr><tr><td>CONV(x,f1,f2)</td><td>返回  f1 进制数变成 f2 进制数</td><td><code>SELECT CONV(15, 10, 2);-&gt; 1111</code></td></tr><tr><td>CONVERT(s  USING cs)</td><td>函数将字符串 s 的字符集变成 cs</td><td><code>SELECT CHARSET(&#39;ABC&#39;)-&gt;utf-8  `` ``SELECT CHARSET(CONVERT(&#39;ABC&#39; USING gbk))-&gt;gbk</code></td></tr><tr><td>CURRENT_USER()</td><td>返回当前用户</td><td><code>SELECT CURRENT_USER();-&gt; guest@%</code></td></tr><tr><td>DATABASE()</td><td>返回当前数据库名</td><td><code>SELECT DATABASE();  -&gt; runoob</code></td></tr><tr><td>IF(expr,v1,v2)</td><td>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</td><td><code>SELECT IF(1 &gt; 0,&#39;正确&#39;,&#39;错误&#39;)  -&gt;正确</code></td></tr><tr><td><a href="https://www.runoob.com/mysql/mysql-func-ifnull.html">IFNULL(v1,v2)</a></td><td>如果  v1 的值不为 NULL，则返回 v1，否则返回 v2。</td><td><code>SELECT IFNULL(null,&#39;Hello Word&#39;)-&gt;Hello Word</code></td></tr><tr><td>ISNULL(expression)</td><td>判断表达式是否为 NULL</td><td><code>SELECT ISNULL(NULL);-&gt;1</code></td></tr><tr><td>LAST_INSERT_ID()</td><td>返回最近生成的 AUTO_INCREMENT 值</td><td><code>SELECT LAST_INSERT_ID();-&gt;6</code></td></tr><tr><td>NULLIF(expr1,  expr2)</td><td>比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1</td><td><code>SELECT NULLIF(25, 25);-&gt;</code></td></tr><tr><td>SESSION_USER()</td><td>返回当前用户</td><td><code>SELECT SESSION_USER();-&gt; guest@%</code></td></tr><tr><td>SYSTEM_USER()</td><td>返回当前用户</td><td><code>SELECT SYSTEM_USER();-&gt; guest@%</code></td></tr><tr><td>USER()</td><td>返回当前用户</td><td><code>SELECT USER();-&gt; guest@%</code></td></tr><tr><td>VERSION()</td><td>返回数据库的版本号</td><td><code>SELECT VERSION()-&gt; 5.6.34</code></td></tr></tbody></table></div><h2 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ConnectSQL</span><span class="params">(MYSQL*&amp; pDB,<span class="type">const</span> <span class="type">char</span>* host ,<span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span> * password, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">unsigned</span> <span class="type">int</span> port = <span class="number">3306</span>,<span class="type">const</span> <span class="type">char</span>* unix = <span class="literal">NULL</span>,<span class="type">unsigned</span> <span class="type">long</span> flag = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    MYSQL* mysql = <span class="keyword">new</span> <span class="built_in">MYSQL</span>();</span><br><span class="line">    pDB = <span class="built_in">mysql_init</span>(mysql);</span><br><span class="line">    <span class="keyword">if</span> (pDB == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;init_falied&quot;</span> &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pDB = <span class="built_in">mysql_real_connect</span>(pDB, host, user, password, name, port, unix, flag);</span><br><span class="line">    <span class="keyword">if</span> (!pDB)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;connect mysql&quot;</span> &lt;&lt; pDB &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowResult</span><span class="params">(MYSQL_RES* res)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> nFields = <span class="built_in">mysql_num_fields</span>(res);</span><br><span class="line">    my_ulonglong nRows = <span class="built_in">mysql_num_rows</span>(res);</span><br><span class="line">    MYSQL_FIELD* fields = <span class="built_in">mysql_fetch_fields</span>(res);</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        row = <span class="built_in">mysql_fetch_row</span>(res);</span><br><span class="line">        <span class="keyword">if</span> (row != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; nFields; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;type:&quot;</span> &lt;&lt; fields[i].type &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; fields[i].name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; row[i] &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (row != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExecuteSQL</span><span class="params">(MYSQL* pDB,<span class="type">const</span> std::string&amp; sql,BOOL isShowRes = FALSE)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">mysql_real_query</span>(pDB, sql.<span class="built_in">c_str</span>(), (<span class="type">unsigned</span> <span class="type">long</span>)sql.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;mysql error:&quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(pDB) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MYSQL_RES* res = <span class="literal">NULL</span>;</span><br><span class="line">    res = isShowRes?<span class="built_in">mysql_store_result</span>(pDB):<span class="built_in">mysql_use_result</span>(pDB);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ShowResult</span>(res);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;===================================&quot;</span> &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;en_GB.UTF-8&quot;</span>);</span><br><span class="line">    MYSQL* pDB = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">ConnectSQL</span>(pDB, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;suailuo&quot;</span>, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        std::string sql;</span><br><span class="line">        sql = <span class="string">&quot;CREATE USER IF NOT EXISTS &#x27;hello&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;GRANT ALL ON *.* TO &#x27;hello&#x27;@&#x27;localhost&#x27;;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;CREATE DATABASE test1&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;GRANT ALL ON test1.* TO &#x27;hello&#x27;@&#x27;localhost&#x27;;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;USE test1&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;CREATE TABLE IF NOT EXISTS `table_test`(&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;`编号` NVARCHAR(16) PRIMARY KEY,&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;`age` INT NOT NULL DEFAULT 18&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;)ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test`(`编号`,`age`) VALUES(\&quot;9527\&quot;,35);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test`(`编号`,`age`) VALUES(\&quot;9528\&quot;,99);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test`(`编号`,`age`) VALUES(\&quot;9529\&quot;,17);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        <span class="comment">//sql = &quot;DELETE FROM `table_test` WHERE `编号`=\&quot;9528\&quot;;&quot;;</span></span><br><span class="line">        <span class="comment">//ret = ExecuteSQL(pDB, sql);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个日志表</span></span><br><span class="line">        sql = <span class="string">&quot;CREATE TABLE IF NOT EXISTS `logs`(&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;`Id` INT(16) NOT NULL AUTO_INCREMENT,&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;`log` VARCHAR(255) DEFAULT NULL COMMENT \&quot;日志说明\&quot;,&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;PRIMARY KEY(`Id`)&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT = \&quot;日志\&quot;;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        <span class="comment">//创建触发器</span></span><br><span class="line">        sql = <span class="string">&quot;CREATE TRIGGER hello_log AFTER INSERT ON `table_test` FOR EACH ROW \n \</span></span><br><span class="line"><span class="string">            BEGIN\n \</span></span><br><span class="line"><span class="string">            DECLARE s1 VARCHAR(40)character set utf8;\n \</span></span><br><span class="line"><span class="string">            DECLARE s2 VARCHAR(20)character set utf8;\n \</span></span><br><span class="line"><span class="string">            SET s2 = \&quot; is created\&quot;;\n \</span></span><br><span class="line"><span class="string">            SET s1 = CONCAT(NEW.`编号`, s2);\n \</span></span><br><span class="line"><span class="string">            INSERT INTO logs(log) values(s1);\n \</span></span><br><span class="line"><span class="string">            END;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这一段就是事物</span></span><br><span class="line">        <span class="built_in">mysql_autocommit</span>(pDB, <span class="literal">false</span>);</span><br><span class="line">        sql = <span class="string">&quot;UPDATE `table_test` SET age=55 WHERE `编号`=\&quot;9528\&quot;;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;UPDATE `table_test` SET age=55 WHERE `age`&lt;18;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test`(`编号`,`age`) VALUES(\&quot;9521\&quot;,127);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mysql_rollback(pDB);</span></span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test`(`编号`,`age`) VALUES(\&quot;9521\&quot;,127);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;CREATE TABLE IF NOT EXISTS `table_test2`(&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;`职业` NVARCHAR(16) PRIMARY KEY,&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;`age` INT NOT NULL DEFAULT 18&quot;</span>;</span><br><span class="line">        sql += <span class="string">&quot;)ENGINE=InnoDB DEFAULT CHARSET=utf8;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test2`(`职业`,`age`) VALUES(\&quot;8529\&quot;,17);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line">        sql = <span class="string">&quot;INSERT INTO `table_test2`(`职业`,`age`) VALUES(\&quot;9529\&quot;,17);&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mysql_commit</span>(pDB);</span><br><span class="line">        <span class="built_in">mysql_autocommit</span>(pDB, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//事物结尾。</span></span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;SELECT * FROM `table_test`;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql,TRUE);</span><br><span class="line">        sql = <span class="string">&quot;SELECT age FROM `table_test`UNION ALL SELECT age FROM `table_test2`;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql,TRUE);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;SELECT age FROM `table_test`UNION ALL SELECT age FROM `table_test2`;&quot;</span>;</span><br><span class="line">        ret = <span class="built_in">ExecuteSQL</span>(pDB, sql, TRUE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//sql = &quot;DROP TABLE test1.`table_test`;&quot;;</span></span><br><span class="line">        <span class="comment">//ret = ExecuteSQL(pDB, sql);</span></span><br><span class="line">        <span class="comment">//sql = &quot;DROP DATABASE test1;&quot;;</span></span><br><span class="line">        <span class="comment">//ret = ExecuteSQL(pDB, sql);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_close</span>(pDB);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pDB;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试| “主打的是一个叛逆”</title>
      <link href="/2023/07/03/mianshi02/"/>
      <url>/2023/07/03/mianshi02/</url>
      
        <content type="html"><![CDATA[<h1 id="面试-“主打的是一个叛逆”"><a href="#面试-“主打的是一个叛逆”" class="headerlink" title="面试 | “主打的是一个叛逆”"></a>面试 | “主打的是一个叛逆”</h1><blockquote><p>面试官：你周围的同学都学什么语言呢？</p><p>我： JAVA ，前端比较多。</p><p>面试官：那你为什么要选C++？</p><p>我：主打的是一个叛逆吧啊哈哈…..</p><p>……</p></blockquote><p>遇到的实习岗位的几个面试题，<del>有一个代码题我忘了是啥了</del>，和一些比较关键的问题吧</p><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><p>没什么好说的，不允许使用额外内存那就用指针换呗，用c的写法，用的两个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>* cstr)</span>&#123;</span><br><span class="line">     <span class="type">int</span> length = <span class="keyword">sizeof</span>(str);<span class="comment">//这里我使用的是sizeof</span></span><br><span class="line">    <span class="type">char</span> *left = str;</span><br><span class="line">    <span class="type">char</span> *right = str + length - <span class="number">2</span> ;<span class="comment">//不需要反转字符串\0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换左右两个字符</span></span><br><span class="line">        <span class="type">char</span> temp = *left;</span><br><span class="line">        *left = *right;</span><br><span class="line">        *right = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h3><p>这玩意，写了个伪代码出来（题目上写着伪代码也可）。思路没毛病，递归，求当前节点的最大深度（迭代也可以），比较左右子数的最大深度就行。</p><h4 id="递归的实现"><a href="#递归的实现" class="headerlink" title="递归的实现"></a>递归的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//定义一个二叉树节点结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//根为0就为0</span></span><br><span class="line">    <span class="type">int</span> leftDepth = <span class="built_in">MaxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> rightDepth = <span class="built_in">MaxDepth</span>(root-&gt;right);</span><br><span class="line">    <span class="type">int</span> depth = <span class="built_in">maxDepth</span>(root);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代的实现"><a href="#迭代的实现" class="headerlink" title="迭代的实现"></a>迭代的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//用队列存放二叉树结构</span></span><br><span class="line">    std::queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> levelSize = q.<span class="built_in">size</span>(); <span class="comment">// 当前层的节点数</span></span><br><span class="line">        <span class="comment">// 将当前层的所有节点出队，并将下一层的节点入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; ++i) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++; <span class="comment">// 深度加一，表示已经遍历完一层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增序列子串长度"><a href="#最长递增序列子串长度" class="headerlink" title="最长递增序列子串长度"></a>最长递增序列子串长度</h3><p>草稿上想了一会补出来了使用的滑动窗口双指针的方法，有很多小问题。并且我感觉动态规划也是可以做到的，参照下方的最大回文子串实现</p><h4 id="滑动窗口的实现"><a href="#滑动窗口的实现" class="headerlink" title="滑动窗口的实现"></a>滑动窗口的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestSubSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 左指针</span></span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">1</span>; <span class="comment">// 最长递增子序列的长度</span></span><br><span class="line">    <span class="type">int</span> curLen = <span class="number">1</span>; <span class="comment">// 当前子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">1</span>; right &lt; n; ++right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] &gt; nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">            curLen++;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, curLen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            curLen = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划的题解"><a href="#动态规划的题解" class="headerlink" title="动态规划的题解"></a>动态规划的题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">int</span> <span class="title">longestSubSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个动态规划数组，dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化最大长度为1</span></span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums[i] 大于 nums[j]，则可以将 nums[i] 添加到以 nums[j] 结尾的子序列中</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = std::<span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新最大长度</span></span><br><span class="line">        maxLen = std::<span class="built_in">max</span>(maxLen, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大回文子串"><a href="#最大回文子串" class="headerlink" title="最大回文子串"></a>最大回文子串</h3><p>暴力写法想了半天天，感觉暴力相当的捞。不是代码捞，是写代码的人捞，现在重新回顾一下发现LeetCode以前还做过，丢人了我去，这题我甚至还超过动态规划的题解 。<del>超过也不见得能当场写出来就是了</del></p><p>暴力的写法当时没有写完，时间不够了，（在题目下方写了个动归，面试官看了看没说话 XP）总得来说就是。两个for循环找子串，把所有满足的子串存起来，最后比较最大子串并返回。</p><h4 id="暴力的写法"><a href="#暴力的写法" class="headerlink" title="暴力的写法"></a>暴力的写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isHuiwen</span><span class="params">(string &amp;s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[start] != s[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestHuiwenSub</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    string longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isHuiwen</span>(s, i, j) &amp;&amp; (j - i + <span class="number">1</span>) &gt; longest.<span class="built_in">length</span>()) &#123;</span><br><span class="line">                longest = s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抄的动态规划的题解"><a href="#抄的动态规划的题解" class="headerlink" title="抄的动态规划的题解"></a>抄的动态规划的题解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">// 记录最长回文子串的起始位置</span></span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">1</span>; <span class="comment">// 记录最长回文子串的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个字符都是回文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - len; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">                        maxLen = len;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针的解法"><a href="#双指针的解法" class="headerlink" title="双指针的解法"></a>双指针的解法</h4><p>我感觉双指针也是没有问题的。在评论区翻找一会确实发现了双指针的写法（内核是中心扩展），也顺便贴上来，并做好注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">// 记录最长回文子串的起始位置</span></span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">1</span>; <span class="comment">// 记录最长回文子串的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 以当前字符为中心向左右扩展</span></span><br><span class="line">        <span class="type">int</span> left = i, right = i;</span><br><span class="line">        <span class="comment">// 向右扩展</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; s[right] == s[right + <span class="number">1</span>]) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向外扩展，直到不是回文串为止</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; right &lt; n - <span class="number">1</span> &amp;&amp; s[left - <span class="number">1</span>] == s[right + <span class="number">1</span>]) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算当前回文子串的长度</span></span><br><span class="line">        <span class="type">int</span> curLen = right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 更新最长回文子串的信息</span></span><br><span class="line">        <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">            maxLen = curLen;</span><br><span class="line">            start = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br></pre></td></tr></table></figure><h2 id="面试提问与回答"><a href="#面试提问与回答" class="headerlink" title="面试提问与回答"></a>面试提问与回答</h2><h3 id="32位下的进程模型"><a href="#32位下的进程模型" class="headerlink" title="32位下的进程模型"></a>32位下的进程模型</h3><blockquote><p>面试官：32位下的进程模型你知道吗？</p><p>我：嗯，代码段那些吗？</p><p>面试官： 地址，内存位置（我这里也记不太清是怎么问的了）</p><p>我： 首先是内核，然后是栈，未使用内存 ，嗯有4G， 用户区有3G，我要不画一下吧。</p></blockquote><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/1704997-20200611170632371-1875253540.png" alt="img"></p><p>除了栈区和堆区地址生长方向画反了（但是我嘴上说对了栈是向上，堆区是向下），动态库加载去跟未用空间画反了以外，嗯，应该跟该图一致。</p><h3 id="C-特性"><a href="#C-特性" class="headerlink" title="C++特性"></a>C++特性</h3><blockquote><p>面试官：C++11 14 17 20 这些特性有了解吗？</p><p>我：我比较了解 C++11 ，20 的特性有看了一些，比如说，协程，和import 关键词 模块导入等等</p><p>面试官：也就是说主用 C++11 了？你常用常见的C++特性有哪些呢？</p><p>我：最常用的就是 智能指针了吧</p><p>面试官：说说看，比如 Shared_ptr 和 unique_ptr  和 week_ptr的区别，和你怎么作用呢</p><p>我： 顾名思义的，共享就是共享，但是只有一份，共享指针维护了一个引用变量，如果有人引用就++，这个++是原子操作，但是这个指针本身并不是线程安全的。嗯，唯一就是唯一，只能有一个人用也只有一份，弱，嗯，我实际不怎么用，但是一般配合Shared_ptr的解决循环引用的问题。</p><p>面试官：还有呢？</p><p>我： 还有lambda函数 ，qt里常常用，连接信号的槽函数，我常常是使用lambda写的。</p></blockquote><h3 id="视频服务器实现"><a href="#视频服务器实现" class="headerlink" title="视频服务器实现"></a>视频服务器实现</h3><blockquote><p>面试官：你这个项目服务器部署在Linux？用到了什么模块？能说说吗</p><p>我：嗯，有http模块 ，数据库模块，使用的是sqlite3 也可以是 MySQL，都提供了不同的借口。<br>嗯、还有一个日志模块，异步的，通过封装好的进程类使用，进程之间通过本地套接字进行通信。<br>嗯，利用http模块，哦，还有开源的openssl库，利用md5的加密签名吧，跟数据库模块实现了一个客户端登录的验证。</p></blockquote><h3 id="vlc"><a href="#vlc" class="headerlink" title="vlc"></a>vlc</h3><blockquote><p>面试官：你这个项目的客户端，是用的vlc的客户端？那你的基于Qt是在哪里体现的呢？</p><p>我：不是不是，嗯，我用的不是vlc现成的客户端，虽然vlc现成的客户端界面也是qt写的就是了，<br>我主要是使用官网开源编译的sdk,并进行了一个封装，在qt里进行调用，自己写的界面。</p><p>面试官：也就是说是个换皮咯？</p><p>我：嗯对对对</p><p>面试官：能给我看看界面，比如截图什么的吗？</p><p>我：呃，那个，手机里并没有存，，但是笔记本里有，没有带来。</p></blockquote><h3 id="RTSP，视频的推拉流的处理"><a href="#RTSP，视频的推拉流的处理" class="headerlink" title="RTSP，视频的推拉流的处理"></a>RTSP，视频的推拉流的处理</h3><blockquote><p>面试官：我看你的这个视频服务器，用到了什么协议，视频流推拉流怎么处理</p><p>我：用到了 RTSP的协议， 嗯视频编码用到了 H264, </p><p>面试官：嗯嗯，你这个服务器利用RTSP 拉流给客户端，那你的客户端是怎么处理这个视频流的？</p><p>我：这个，，，嗯，我刚刚说了我封装了VLC 现有的SDK，我对底层的实现怎么处理这个视频流没有太多了解，我只进行了一个封装函数的调用，就是拉流，这一块我不太清楚。。直接就是输入RTSP//地址就调用了。</p></blockquote><p>这里回答是有误的，目前我对这一块的理解不深，暂时没有什么头绪，等我整明白了在更新本段。</p><h3 id="Epoll-select-poll-的区别"><a href="#Epoll-select-poll-的区别" class="headerlink" title="Epoll select poll 的区别"></a>Epoll select poll 的区别</h3><blockquote><p>面试官：你说说Epoll select  poll的区别？</p><p>我：嗯 首先，在系统上，epoll 只能在Linux下使用，select可以在Windows和Linux都可以使用</p><p>可以处理的IO socket select有个上限，具体的值是1024,但是实际上嗯，他也可以修改，epoll没有这个限制，嗯epoll的….</p><p>面试官：你说的这些不是重点，主要是机制</p><p>我： 嗯，哦， epoll是事件驱动的，但是select 嗯。。。好像也是啊。嗯epoll有两种不同的触发方式？边沿和水平？边沿的触发是</p><p>面试官：(打断)这也不是关键。</p><p>我：嗯，epoll他底层不是线性的找事件，我记得，内核维护一个红黑树队列好像找事件特别快。select维护的是个数组，需要遍历轮序，找事件比较慢？</p><p>面试官： （似乎听不下去了）select 的轮询是线性的，监视的文件描述符需要都遍历一遍时间复杂度是 O(n)。epoll呢轮询不是线性的，一有事件就立即返回。时间复杂度一般是O(1);</p></blockquote><p>正确答案：</p><ol><li><strong>性能差异</strong>：<ul><li><code>select</code>：在调用 <code>select</code> 函数后，它会遍历所有的文件描述符，查找其中是否有事件就绪，这导致其性能在处理大量文件描述符时较差。</li><li><code>epoll</code>：<code>epoll</code> 使用了更高效的数据结构，可以在事件就绪时立即返回，而不需要遍历所有的文件描述符。这使得 <code>epoll</code> 在处理大量文件描述符时具有更好的性能。。</li></ul></li><li><strong>事件触发方式</strong>：<ul><li><code>select</code>：<code>select</code> 使用水平触发（LT）方式，即当文件描述符上有数据可读或可写时，会一直通知应用程序，直到应用程序处理完数据。这可能会导致频繁的事件通知，需要应用程序自行管理缓冲区。</li><li><code>epoll</code>：<code>epoll</code> 支持水平触发（LT）和边缘触发（ET）两种触发方式。边缘触发只在状态变化时通知应用程序，需要应用程序自行管理缓冲区，而水平触发会一直通知应用程序直到数据读取完毕或写入完毕。</li></ul></li><li><strong>文件描述符数量限制</strong>：<ul><li><code>select</code>：根据操作系统的不同，<code>select</code> 通常有文件描述符数量的限制，这个限制通常是较小的，例如1024或2048个。</li><li><code>epoll</code>：<code>epoll</code> 没有文件描述符数量的限制，可以处理大量文件描述符，因此适用于高性能服务器应用程序。</li></ul></li><li><strong>支持的事件类型</strong>：<ul><li><code>select</code>：主要用于监视可读、可写和异常等基本事件。</li><li><code>epoll</code>：支持多种事件类型，包括可读、可写、错误、边缘触发等。这使得 <code>epoll</code> 更灵活，可以更精细地控制事件的处理。</li></ul></li></ol><p>总的来说，<code>epoll</code> 在性能和功能上通常优于 <code>select</code>，特别适用于需要处理大量文件描述符的高性能服务器应用程序。但需要注意的是，<code>epoll</code> 是Linux特有的，不跨平台，而 <code>select</code> 在不同操作系统上都有支持。因此，选择使用哪种机制取决于应用程序的需求和目标平台。</p><p>UDP 问到了，跟上一篇文章一样说的，面试官也没有给予反馈。</p><p>还有一些情景题，面试官并没有进行评价，不知道是答的错还是对，有点蛋疼。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做题，还是不习惯纸上写，没有IDE 脑子一片混沌，诶，只能努力适应吧，面试的表达能力，还是不太行，专业术语用的少了些</p><p>笔试，技术面1 技术面2，人事面，然后回去等通知，通知是待定，正在商议。有点无语。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试| “年轻人再拷打拷打”</title>
      <link href="/2023/07/02/mianshi01/"/>
      <url>/2023/07/02/mianshi01/</url>
      
        <content type="html"><![CDATA[<h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><p>隔了几天，重新回忆回忆我到底面了啥，我写了啥，我说了啥。</p><blockquote><p>面试官：看了项目都是玩具代码</p><p>我： 嗯嗯嗯（小鸡啄米）</p><p>面试官：你毕业6月份，两个月你怎么不找工作呢？</p><p>我：在学您说的玩具代码。</p><p>面试官：没什么比在实际项目中学习最好的，年轻人再拷打拷打吧</p></blockquote><h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><h3 id="前置-与后置-的实现"><a href="#前置-与后置-的实现" class="headerlink" title="前置++与后置++的实现"></a>前置++与后置++的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前置递增运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">// 实现递增操作</span></span><br><span class="line">        ++value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回递增后的对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载后置递增运算符</span></span><br><span class="line">    MyClass <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="function">MyClass <span class="title">temp</span><span class="params">(value)</span></span>;</span><br><span class="line">        <span class="comment">// 实现递增操作</span></span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">return</span> temp;  <span class="comment">// 返回递增前的对象的副本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="memcpy的简单实现"><a href="#memcpy的简单实现" class="headerlink" title="memcpy的简单实现"></a>memcpy的简单实现</h3><p>嘛，就按照字节一个一个copy呗。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里应该可以用static_cast 装一下，美名其曰更安全。</span></span><br><span class="line">    <span class="type">char</span>* dest_char = (<span class="type">char</span>*)dest;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* src_char = (<span class="type">const</span> <span class="type">char</span>*)src;</span><br><span class="line">    <span class="comment">// 检查源和目标内存是否重叠</span></span><br><span class="line">    <span class="keyword">if</span> (dest_char == src_char) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从源内存复制到目标内存按一个字节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        dest_char[i] = src_char[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h3><p>将一个unsigned long val 字节序转换 假设 0值为0x123456<br>我这题写了一个方式，并说出了大小端区别，主机和网络字节序的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我写的union方法</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">converter</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> bytes[<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    converter c;</span><br><span class="line">    c.value = <span class="number">0x123456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法就是中规中矩 的 按照大小端区别倒换一下</span></span><br><span class="line"></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> value = <span class="number">0x123456</span>;</span><br><span class="line"> <span class="type">char</span> bytes[<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>); ++i) &#123;</span><br><span class="line">        bytes[i] = （<span class="type">char</span>*)((value &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ps :这里补个检测大小端的代码，利用GCC编译器提供的宏来处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Little-Endian\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Big-Endian\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown Endian\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="string类的实现"><a href="#string类的实现" class="headerlink" title="string类的实现"></a>string类的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写了一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str; <span class="comment">// 字符串存储</span></span><br><span class="line">    <span class="type">size_t</span> length; <span class="comment">// 字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        length = <span class="built_in">strlen</span>(s);<span class="comment">//这里问了怎么实现的strlen ，我的回答是以\0判断字符串结尾。</span></span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        length = other.length;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串长度</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取C字符串</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载赋值运算符</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] str;</span><br><span class="line">            length = other.length;</span><br><span class="line">            str = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="项目内容："><a href="#项目内容：" class="headerlink" title="项目内容："></a>项目内容：</h2><h3 id="UDP-穿透-NAT环境"><a href="#UDP-穿透-NAT环境" class="headerlink" title="UDP 穿透 NAT环境"></a>UDP 穿透 NAT环境</h3><ul><li>你是利用UDP穿透实现的跨局域网的控制吗？</li></ul><p>嗯，是的，但是我实际上没有完成这项功能，因为，NAT 的环境的复杂性，我没有再继续进行测试，做了个初步的调查，UDP穿透是可行的跨局域网的手段。嗯， NAT 是 Net Address translation 吧，就是网络地址转换，还有一个NAPT，网络地址端口转换，这几个协议，忘记是哪个层的了，应该是物理层，在路由器这块的，是解决IPv4资源不够用的方法，也有隔离保护的作用。NAT有全开放的，有锥形限制的，只限制IP的，和只限制端口的，两者都限制的。都需要一个公网服务器帮助进行穿透。</p><h3 id="屏幕控制"><a href="#屏幕控制" class="headerlink" title="屏幕控制"></a>屏幕控制</h3><ul><li>关于这个屏幕控制，具体实现是怎样的？</li></ul><p>主要完成了就是，被控端的屏幕的显示，鼠标控制。屏幕画面来源于TCP 包传输，该包包含了被控端的屏幕图片帧数据。这个帧数据是通过，嗯WINDOWS的GDI 的系统函数，屏幕截图的函数拿到的，并编码为png在进行打包传递，这里我测试了两种图片编码格式 jpg 和png ，png占优。控制端，接受到并进行解包显示，使用到定时器的事件，不是，是MFC 的 消息，这个客户端是在WINDOWS下基于MFC实现的，嗯，这个功能是开启个线程下完成的，保证显示屏幕功能不阻塞接受包解包的功能。</p><p>鼠标控制就是利用WINDOWS 的 消息事件来实现的。需要考虑到被控屏幕和鼠标操作实际消息触发的位置，进行一个偏移转换。</p><h3 id="MFC-与-MVC"><a href="#MFC-与-MVC" class="headerlink" title="MFC 与 MVC"></a>MFC 与 MVC</h3><ul><li>你确定你这个远程控制的项目是MFC 不是MVC 你没有搞错吗？</li></ul><p>我确定就是MFC做的远程控制。</p><p>MVC是 model view control 就是模块层 视图层 控制层，远控的客户端也是基于MVC架构实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一些笔试题，也不难，考察的都是C++基础。职业规划都讲的挺清楚，入职后谁来带，公司的业务，公司的状态，公司的后续计划，面试官都主动的告知我，让我一度有种已经拿到offer的感觉，告诉我后续等人事 HR详说，结果过了两天，了无音信。。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试|“主打就是一个真诚”</title>
      <link href="/2023/07/01/mianshi/"/>
      <url>/2023/07/01/mianshi/</url>
      
        <content type="html"><![CDATA[<h1 id="关于我面试啥也不会胡说八道这件事"><a href="#关于我面试啥也不会胡说八道这件事" class="headerlink" title="关于我面试啥也不会胡说八道这件事"></a>关于我面试啥也不会胡说八道这件事</h1><p>进行一个简单的面试记录，记录面试遇到的所有问题，奇葩言论<del>大多来源于我</del></p><h2 id="“主打就是一个真诚”"><a href="#“主打就是一个真诚”" class="headerlink" title="“主打就是一个真诚”"></a>“主打就是一个真诚”</h2><blockquote><p>面试官：你觉得深圳怎么样<br>我：一个字 快<br>面试官： 感觉 有活力开放的？<br>我： 感觉，前途一片灰暗<br>面试官：……</p><p>嗯，等通知。</p></blockquote><h3 id="出大问题的问题"><a href="#出大问题的问题" class="headerlink" title="出大问题的问题"></a>出大问题的问题</h3><blockquote><p>面试官：类的成员变量 使用 const进行修饰与使用static修饰</p><p>我： stiaic修饰需要在类外进行定义，因为在类中不是定义而是声明，const，嗯，常量表示不可修改。</p><p>面试官： static呢？还有吗？初始化呢？</p><p>我：嗯，，好像C++17有个特性 static inline 成员变量 可以在类里定义，其他的忘了。</p></blockquote><p><strong>正确答案</strong>：static的最大的作用没讲出来：表示这是一个静态成员变量，它属于类而不是类的实例。类的共享成员变量。它在程序启动时分配内存，放在data段中 并在整个程序生命周期内存在。</p><blockquote><p>面试官： 关于MySql 的联表查询，你会写出的SQL 语句</p><p>我：我知道关键字 union 和join。 </p><p>面试官：UINION 不是，你说说看join ，又有几种JION。</p><p>我： 哦哦，想起来了，UINION 是查询select的时候用到的 不过JION 的我忘了。</p><p>面试官： ……</p></blockquote><p><strong>正确答案</strong>：MySQL支持不同类型的JOIN操作，包括INNER JOIN、LEFT JOIN、RIGHT JOIN和FULL JOIN，</p><ol><li><p><strong>INNER JOIN（内连接）</strong>：INNER JOIN返回两个表中匹配的行，且仅返回匹配的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy codeSELECT employees.name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">INNER JOIN departments ON employees.department_id = departments.id;</span><br></pre></td></tr></table></figure></li><li><p><strong>LEFT JOIN（左连接）</strong>：LEFT JOIN返回左边表中的所有行以及与右边表中匹配的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.customer_name, orders.order_id</span><br><span class="line">FROM customers</span><br><span class="line">LEFT JOIN orders ON customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure></li><li><p><strong>RIGHT JOIN（右连接）</strong>：RIGHT JOIN返回右边表中的所有行以及与左边表中匹配的行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT orders.order_id, customers.customer_name</span><br><span class="line">FROM orders</span><br><span class="line">RIGHT JOIN customers ON orders.customer_id = customers.customer_id;</span><br></pre></td></tr></table></figure></li><li><p><strong>FULL JOIN（全连接）</strong>：FULL JOIN返回两个表中的所有行，如果没有匹配的行，则返回NULL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT customers.customer_name, orders.order_id</span><br><span class="line">FROM customers</span><br><span class="line">FULL JOIN orders ON customers.customer_id = orders.customer_id;</span><br></pre></td></tr></table></figure></li></ol><p>这些是最常见的JOIN类型。要执行联表查询，需要指定连接条件，这是连接两个表的基础</p><blockquote><p>面试官：关于MySql ，如果你要存储一个Age 的field，你会写出的SQL 语句</p><p>我：我只记得要数据类型的指定</p><p>面试官：你指定什么呢？</p><p>我：整形吧INTIGER</p><p>面试官：还有呢</p><p>我： 也可以VARCHAR， 哦，好像还要指定大小</p><p>面试官： 然后呢</p><p>我：呃，忘了</p><p>面试官：还有<strong>TINYINT</strong> <strong>SMALLINT</strong> <strong>MEDIUMINT</strong> <strong>BIGINT</strong></p><p>我：哦哦，你说我就想起来了</p><p>…..</p></blockquote><p><strong>正确示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons (PersonID INT PRIMARY KEY,    FirstName VARCHAR(50),    LastName VARCHAR(50),    Age INT );</span><br></pre></td></tr></table></figure><blockquote><p>面试官：关于Qt QApplication 是？</p><p>我： 我只知道是Qt程序初始化的必要的类。</p><p>面试官：…… 你确定？</p><p>我： 我只会调库查QAsistance,其他不会就现查（瘫坐</p><p>面试官： ……</p></blockquote><p><strong>正确答案</strong>：QApplication对象是Qt GUI应用程序的核心。它管理应用程序的控制流和主要设置。在英语中，我们通常会说 “The QApplication object is the heart of the Qt application. It manages the GUI application’s control flow and main settings.”（QApplication对象是Qt应用程序的核心。它管理GUI应用程序的控制流和主要设置）。<br>———————————————<br>CSDN：<a href="https://blog.csdn.net/qq_21438461/article/details/131830930">https://blog.csdn.net/qq_21438461/article/details/131830930</a></p><blockquote><p>面试官：C++如何处理或者实现http请求</p><p>我： 刚刚我说了，我只会调库，比如Qt 下我就调QNetworkAccessManager，可以实现GET 与 POST等请求，或者引用第三方的开源库 curl 等</p><p>面试官：我要发个XML 该怎么做</p><p>我：我记得POST请求头里修改个啥，具体我忘了</p></blockquote><p><strong>正确示例：提交表单</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit_user_info</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/xml</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>123</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">email</span>&gt;</span>john@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>我： 嗯，我记得有个xmake , vcpkg</p><p>面试官：好处</p><p>我： 版本控制方便吧，环境配置，迁移能方便些？</p><p>面试官：然后呢？</p><p>我：但我没用过，我都是git clone 别人的 然后 编译静态库或者动态库。我是调库小子</p><p>面试官：…</p></blockquote><p><strong>正确答案</strong>：xmake 是个构建工具，并不是包管理工具，但简单包管理是它的功能之一，<strong>vcpkg 和 conan</strong> 是很好的包管理器 可以更方便地安装依赖关系，并决定所安装的版本，两种包管理器都适用于各种平台，</p><p>C++ 的包因为编译器版本不同，库不同，系统环境不同，C++ 标准不同等复杂的编译变量，需要一个好的包管理器进行管理。在多人开发的大型项目中，能够解决很多环境问题。</p><blockquote><p>面试官：单例</p><p> 我：嗯，简单的说就是，类的构造函数都是私有的了，外没法直接调用构造，所以需要一个嵌套的类进行辅助的初始化和析构吧。。应该，我记得有两种写法，一种是懒汉，一种是饿汉</p><p>面试官： 多线程下，单例需要加锁吗？</p><p>我：嗯，我记得，不需要吧，main函数之前创建的来着？忘了，应该是不用吧</p><p>面试官：如果是调用的时候才创建，多线程同时调用不就会出现线程安全问题吗？</p><p> 我：是哦，懒汉还是饿汉不用我也分不清了。按照您这么说那指定是要用到同步机制锁等方式来解决的的。</p><p>面试官：…….</p></blockquote><p><strong>正确答案</strong>：懒汉是不需要加锁的，饿汉是需要使用同步机制锁的方式来避免线程安全问题。懒汉在程序开始执行main函数之前，已经初始化好了，并且只初始化了一次就不会再进行初始化，而饿汉不同，饿汉是因为 调用外部接口的时候才创建，就会出现线程安全问题。初始化很费劲的时候常常使用 懒汉 的写法。</p><h3 id="面试的总结：脑子犯浑。"><a href="#面试的总结：脑子犯浑。" class="headerlink" title="面试的总结：脑子犯浑。"></a>面试的总结：脑子犯浑。</h3><p><del>这下我知道为什么面试官最后要自夸他很温和了。。。</del></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++注解|智能指针与原生指针</title>
      <link href="/2023/04/08/cbase05/"/>
      <url>/2023/04/08/cbase05/</url>
      
        <content type="html"><![CDATA[<h1 id="C-注解"><a href="#C-注解" class="headerlink" title="C++ 注解"></a>C++ 注解</h1><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>C++11，再管理动态分配内存上，引入的智能指针。哥们理解为，是原生指针raw point 的高级封装。</p><p>C++98 就提供了auto_ptr，但是，到了C++11后，不再建议使用，摒弃了auto_ptr，而是提供了unique_ptr ， share_ptr与weak_ptr等</p><p>动态内存分配，能够有效的避免内存泄露的问题</p><p>多线程，多进程的动态分配内存中，常常可能因为某些原因，在释放内存，delete指针指向的内存之前，崩溃，异常捕获，造成内存泄露，悬挂指针问题</p><p>（当然还有可能忘记delete，这个就是程序员的问题了）</p><p>智能指针，将无需记住稍后释放这些new的内存，在智能指针过期时，这些内存将自动释放,你可以不用再担心释放问题（%90）</p><p>智能指针是具有线程安全的，shared指针中有个引用计数，并且引用计数的增加是原子操作。</p><p>需要注意的是，raw原生指针，与智能指针最好不要混用。</p><p>错误示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//原生指针</span></span><br><span class="line"><span class="type">double</span> * raw_ptr = <span class="keyword">new</span> <span class="built_in">double</span> (<span class="number">3.14</span>);</span><br><span class="line"><span class="comment">//将原生指针指向赋予给了一个唯一指针</span></span><br><span class="line"><span class="keyword">auto</span> uni_ptr = make_unique&lt;<span class="built_in">double</span>(raw_ptr);</span><br><span class="line"><span class="comment">//将原生指针的内存释放了</span></span><br><span class="line"><span class="keyword">delete</span> raw_ptr;</span><br></pre></td></tr></table></figure><p>正常编译，但是运行就会出现段错误, </p><p>可见，uni_ptr 并不能知道自己指向的内存已经释放，然后自动释放的时候二次调用这个产生的悬挂指针.</p><p>同理 ,分别定义了两个唯一指针，有了原生指针的参与，并不能保证指向的值是唯一的，所以也会触发段错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">double</span>&gt; ptr_uni1;</span><br><span class="line">ptr_uni1 = <span class="built_in">unique_ptr</span>&lt;<span class="type">double</span>&gt;(raw_ptr);</span><br><span class="line">unique_ptr&lt;<span class="type">double</span>&gt; ptr_uni2;</span><br><span class="line">ptr_uni2 = <span class="built_in">unique_ptr</span>&lt;<span class="type">double</span>&gt;(raw_ptr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++注解|右值引用与移动语义</title>
      <link href="/2023/04/05/cbase04/"/>
      <url>/2023/04/05/cbase04/</url>
      
        <content type="html"><![CDATA[<h1 id="C-注解"><a href="#C-注解" class="headerlink" title="C++注解"></a>C++注解</h1><h1 id="右值引用与移动语义"><a href="#右值引用与移动语义" class="headerlink" title="右值引用与移动语义"></a>右值引用与移动语义</h1><p>C++11提供的新特性，相当有用，节省了很多开销，生了很多事。（ps:越来越感觉C++ 11的很多新特性有意在淡化raw指针的影响，有点java）</p><p>首先来大概了解一下什么事右值</p><h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>右值，通常人们说放在等号 右边的值就是右值。</p><p>但是这只片面的，并不全面。</p><p>我们来看看传统的左值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的左值引用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line"><span class="type">int</span>&amp; la = a;</span><br><span class="line"><span class="type">int</span>&amp; lb = b;</span><br><span class="line"><span class="type">int</span>&amp; lc = c;</span><br></pre></td></tr></table></figure><p>a 就是左值，一个符号，有地址（在栈上），而10  本身就是一个右值。没有办法&amp;取地址，一个常量。</p><p>a+b 实际上也是一个常量公式，也没办法取地址,也是只能放右边。</p><p>具体详细可以看<a href="https://zh.cppreference.com/w/cpp/language/value_category">cppreference</a>对值类别的分类。</p><p>而我们使用的右值引用后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; ra = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rc = a + b;  <span class="comment">// 右值引用</span></span><br><span class="line">  cout &lt;&lt; ra &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; rc &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 在右值引用后，原本的右值的就有了地址</span></span><br><span class="line">  cout &lt;&lt; &amp;ra &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; &amp;rc &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>可以打出右值引用的地址位置了。</p><h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>右值引用的提出，减少了很多不必要的内存开销，假设：当我们传递一个右值时，右值是一个比较大的自定义类（或者字符串），当我们使用值传递，或者拷贝构造时，会同样的构造一个同样临时变量，再传递给一个左值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里拿string 假设无移动构造,但是有拷贝构造</span></span><br><span class="line"><span class="function">string <span class="title">func</span><span class="params">(<span class="type">const</span> string temp)</span></span>&#123;</span><br><span class="line">    string tempret = temp;</span><br><span class="line">    <span class="keyword">return</span> tempret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="comment">//假设a对象管理着有2000000个字符</span></span><br><span class="line">    <span class="function">string <span class="title">b</span><span class="params">(temp)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">c</span><span class="params">(func(b))</span></span>;</span><br><span class="line">    string d = <span class="built_in">func</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果使用拷贝构造 或者赋值拷贝，单是临时对象的new和delete的内存操作就会执行好多次,而且调用一次200000个字符。这个内存IO 开销，是很耗资源的，并且很多都是无用功。</p><p>C++ 是个追求高效，性能的语言，就引入了右值引入这个概念，进而引入了移动构造。</p><p><strong>不过，其实编译器本身也很聪明，也会消除 无用功的的额外工作，消除构建临时参数对象(copy elision)，不过，通过使用右值引用，用户可以自己指出何时使用移动语义，而不是通过编译器来优化。</strong></p><h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><p>对比一下常见的拷贝构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Myclass</span> (<span class="type">const</span> Myclass &amp; f)&#123;</span><br><span class="line"><span class="comment">//m_ptr 为成员变量 Myclass*;</span></span><br><span class="line">m_ptr = <span class="keyword">new</span> <span class="built_in">Myclass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Myclass</span> ( Myclass &amp;&amp; f)&#123;</span><br><span class="line"><span class="comment">//m_ptr 为成员变量 Myclass*</span></span><br><span class="line">m_ptr = f.m_ptr;</span><br><span class="line">f.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，是函数参数的不同，可以发现，参数接受的是一个右值</p><p>其二，不再需要进行内存的申请，而是直接使用右值拥有的内存，然后将原有的成员变量的指针赋值为空值的操作，所以也没有const修饰符。</p><h2 id="移动赋值"><a href="#移动赋值" class="headerlink" title="移动赋值"></a>移动赋值</h2><p>同理， 赋值构造，当然也就有移动赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Myclass&amp;  <span class="keyword">operator</span>=( Myclass &amp;&amp; f)&#123;</span><br><span class="line"><span class="comment">//m_ptr 为成员变量 Myclass*;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;f)&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_ptr;</span><br><span class="line">m_ptr = f.m_ptr;</span><br><span class="line">f.m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，先检查自己是否是自己给自己赋值，如果是，直接返回自己本身。</p><p>首先就是释放原有的指针，避免出现悬挂指针，然后就是简单的赋值操作。</p><p>当然了，也不能是const,因为改变了引用对象</p><h2 id="使用移动语义"><a href="#使用移动语义" class="headerlink" title="使用移动语义"></a>使用移动语义</h2><p>当我们想让自己的类对象构造，或者赋值，等操作，一般直觉的都会使用左值传入使用，编译器也就会默认调用拷贝构造等一般的左值引用函数。</p><p>当我们就想指定传入的左值以右值的方式调用右值引用函数，</p><p>我们可以使用运算符静态转换static_cast&lt;&gt;，将传入对象的类型强制转换为类型&amp;&amp; 右值。</p><p>不过，C++ 11提供了一个强制移动的转换函数 std::move。也可以达到更简单的效果。（函数实现也是调用的static_cast&lt;&gt;，结合了模板)</p><p>在C++Primer Plus中说道：</p><p><strong>对大多数程序员来说，右值引用带来的主要好处并非是让他们能够编写写使用右值引用的代码，而是能够使用，利用右值引用实现移动语义的库代码，比如说，更好的使用和理解标准库容器等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++注解|隐式声明的那些函数。</title>
      <link href="/2023/04/03/cbase03/"/>
      <url>/2023/04/03/cbase03/</url>
      
        <content type="html"><![CDATA[<h1 id="C-注解"><a href="#C-注解" class="headerlink" title="C++注解"></a>C++注解</h1><h1 id="构造函数相关"><a href="#构造函数相关" class="headerlink" title="构造函数相关"></a>构造函数相关</h1><h1 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h1><p>在使用自己定义的类实现某些操作时，可能会出现这样的报错。</p><p><strong>error C2280</strong>: attempting to reference a deleted function</p><p>表示 被引用的函数已被删除的报错</p><p>并且表明该函数为拷贝赋值函数。可你发现，你根本就没有定义这个么函数，引用，和被删除的前提就是它之前存在过？那么我们问题就来了。</p><p>拷贝赋值函数：Tile &amp;Tile::operator =(const Tile &amp;)</p><p><strong>注： Tile 不是模板。</strong></p><h1 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h1><p>我们将问题定位在这个拷贝赋值函数上，探讨关于拷贝复制函数是如何出现的</p><p>我们都知道，（假设 自定义的名字为Tile）</p><p>C++的构造函数有：</p><ul><li>默认构造函数 （无参）</li><li>析构函数 （无参）</li><li>拷贝构造函数 <ul><li>（const  Tile &amp;）return Tile&amp;</li></ul></li><li>拷贝赋值函数   <ul><li>operator= (const Tile &amp;) return Tile&amp;</li><li>operator= ( Tile &amp;) return Tile&amp;</li></ul></li><li><p>移动构造函数</p><ul><li>（  Tile &amp;&amp;）return Tile&amp;</li></ul></li><li><p>移动赋值函数</p><ul><li>operator= ( Tile &amp;) return Tile&amp;&amp;</li></ul></li></ul><p>生成这些特殊成员函数（或不生成）的规则比较复杂，每个特殊成员函数有几种不同的状态，对状态进行判断：</p><ul><li>隐式声明还是用户声明</li><li>默认提供还是用户提供</li><li>正常状态还是删除状态</li></ul><p>需要知道的原则：</p><ul><li>隐式声明的必然是默认提供的；</li><li>默认提供的才可能被删除；</li><li>用户提供的也必然是用户声明的。</li></ul><p>C++默认构造函数是否提供的情况：</p><ul><li><p>如果自定义了一个任意的构造函数,系统将不在提供默认无参构造</p></li><li><p>如果自定了一个普通构造函数,系统还会提供一个拷贝构造</p></li></ul><ul><li>如果自定义了一个拷贝构造.系统将不在提供默认拷贝构造</li></ul><ul><li>如果自定义一个析构函数,系统将不在提供默认的析构函数</li></ul><ul><li>没有初始化的非静态 const 数据成员和引用类型数据成员:导致默认提供的默认构造函数被删除。</li></ul><ul><li>非静态的 const 数据成员和引用类型数据成员:导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。</li></ul><ul><li>用户如果没有自己提供一个拷贝构造函数，编译器会隐式声明一个。</li></ul><ul><li>用户如果没有自己提供一个拷贝赋值函数，编译器会隐式声明一个。</li></ul><ul><li>用户如果自己声明了一个移动构造函数或移动赋值函数：则默认提供的拷贝构造函数和拷贝赋值函数被删除。</li></ul><ul><li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数：编译器会隐式声明一个移动构造函数。</li></ul><ul><li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数：编译器会隐式声明一个移动赋值函数。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>参考<a href="https://stackoverflow.com/questions/24921149/error-c2280-attempting-to-reference-a-deleted-function-trying-to-call-vector-e">stack overflow</a> 问答帖子</p><p>引用其中的回复</p><p>The error clearly mentions <code>Tile &amp;Tile::operator =(const Tile &amp;)</code>, so it’s about the assignment operator, not the move-assignment operator. You need to implement it for <code>Tile</code>. You’re also missing <code>Tile</code>‘s copy-constructor.</p><p>Quote from <a href="http://en.cppreference.com/w/cpp/language/as_operator#Deleted_implicitly-declared_copy_assignment_operator">here</a> :（这也是从cpprereference中原文）</p><blockquote><p>The implicitly-declared or defaulted copy assignment operator for class T is defined as deleted in any of the following is true:</p><ul><li>T has a non-static data member that is const</li><li>T has a non-static data member of a reference type.</li><li>T has a non-static data member that cannot be copy-assigned (has deleted, inaccessible, or ambiguous copy assignment operator)</li><li>T has direct or virtual base class that cannot be copy-assigned (has deleted, inaccessible, or ambiguous move assignment operator)</li><li>T has a user-declared move constructor</li><li>T has a user-declared move assignment operator</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++注解|程序的编译链接</title>
      <link href="/2023/04/02/cbase02/"/>
      <url>/2023/04/02/cbase02/</url>
      
        <content type="html"><![CDATA[<h1 id="C-注解"><a href="#C-注解" class="headerlink" title="C++注解"></a>C++注解</h1><h1 id="程序的编译链接原理"><a href="#程序的编译链接原理" class="headerlink" title="程序的编译链接原理"></a>程序的编译链接原理</h1><p>我们需要理解分析编译的过程理解打好坚实的C++基础，需要理解.o文件的格式组成，可执行文件的组成格式又是什么样子，理解符号表的输出符号，符号何时分配虚拟地址。这些能够帮助我们在出现问题时， 能够深入理解并快速找到问题</p><p>以下结合示例演示大概原理</p><p>工程结构为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── sum01.cpp</span><br><span class="line">└── test01.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure><p> sum01：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gdata = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test01:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> gdata;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> data = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = gdata;</span><br><span class="line">  <span class="type">int</span> b = data;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>进行编译过程大局分为三个阶段</p><p>所有的源文件都是单独编译的</p><ol><li>预编译</li><li>编译</li><li>汇编</li></ol><p>这三个步骤最终得到</p><p>二进制的可<strong>重定位</strong>的目标文件</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>处理 #开头的命令 ，常见的define ，include  等</p><p><strong>需要注意的是</strong></p><p><strong>#pragma lib   #pragma link 等等，这几个并不是在预编译的时间处理，而是在链接阶段</strong></p><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>语法分析</p><p>语义分析</p><p>代码优化</p><p>这就是编译器的基础必须的工作了</p><p>而代码优化 是一个可选的操作，我们可以在编译命令中添加指定 优化参数，比如 O1 O2 O3 </p><p>这里我们执行生成.o文件指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o *.cpp -g</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加入-g 是为了可调式状态下方便看到对应的代码</span></span><br></pre></td></tr></table></figure><p>得到两个文件我们可以观察两个文件的符号表（输入指令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -t *.out</span><br></pre></td></tr></table></figure><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20221214172722339.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20221214172745797.png" alt=""></p><p>可以看到各个符号所分配的段<strong>注：l 为local g 为global</strong></p><p>我们观察两个文件的代码段生成的对应的汇编语言指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">extern int gdata;</span><br><span class="line">int sum(int, int);</span><br><span class="line">int data = 20;</span><br><span class="line">int main() &#123;</span><br><span class="line">   0:   f3 0f 1e fa             endbr64 </span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">  int a = gdata;</span><br><span class="line">   c:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 12 &lt;main+0x12&gt;</span><br><span class="line">  12:   89 45 f4                mov    %eax,-0xc(%rbp)</span><br><span class="line">  int b = data;</span><br><span class="line">  15:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1b &lt;main+0x1b&gt;</span><br><span class="line">  1b:   89 45 f8                mov    %eax,-0x8(%rbp)</span><br><span class="line">  int ret = sum(a, b);</span><br><span class="line">  1e:   8b 55 f8                mov    -0x8(%rbp),%edx</span><br><span class="line">  21:   8b 45 f4                mov    -0xc(%rbp),%eax</span><br><span class="line">  24:   89 d6                   mov    %edx,%esi</span><br><span class="line">  26:   89 c7                   mov    %eax,%edi</span><br><span class="line">  28:   e8 00 00 00 00          call   2d &lt;main+0x2d&gt;</span><br><span class="line">  2d:   89 45 fc                mov    %eax,-0x4(%rbp)</span><br><span class="line">  return 0;</span><br><span class="line">  30:   b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  35:   c9                      leave  </span><br><span class="line">  36:   c3                      ret</span><br><span class="line">  </span><br><span class="line">  ########################################################</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;_Z3sumii&gt;:</span><br><span class="line">int gdata = 10;</span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">   0:   f3 0f 1e fa             endbr64 </span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">   b:   89 75 f8                mov    %esi,-0x8(%rbp)</span><br><span class="line">  return a + b;</span><br><span class="line">   e:   8b 55 fc                mov    -0x4(%rbp),%edx</span><br><span class="line">  11:   8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  14:   01 d0                   add    %edx,%eax</span><br><span class="line">  16:   5d                      pop    %rbp</span><br><span class="line">  17:   c3                      ret    </span><br><span class="line">  </span><br></pre></td></tr></table></figure><p><strong>不难发现，所有的符号都没有分配虚拟地址，而链接的工作就是将两个独立的文件进行整合，从而分配虚拟地址</strong></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>生成相应平台的汇编指令</p><p>最终生成可重定位的目标文件</p><p>符号表（section table）与各种段（.text, .data .bss等) elf头</p><p>更详细的部分就需要深入 书籍csapp，《程序员的自我修养》</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>而编译之后就要进行链接</p><p>链接的大体概念就是将单独编译的目标文件们与各类库文件（比如静态库文件）整合为可执行程序</p><p>而链接也分为两个核心的步骤</p><ol><li>合并解析</li><li>符号重定位</li></ol><p>最终得到可执行的文件</p><p>我们输入链接指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ld -e main *.o</span><br><span class="line"><span class="comment">#指定main函数 为程序入口</span></span><br></pre></td></tr></table></figure><p>可以得到一个可执行文件 a. out </p><h3 id="合并解析"><a href="#合并解析" class="headerlink" title="合并解析"></a>合并解析</h3><p>所有.o文件的各种段的合并</p><p>符号表合并后，进行符号解析。</p><p>相应段进行合并 .text &lt;=&gt; .text</p><p>符号解析</p><p><strong>所有对符号的引用都要找到该符号定义的地方</strong></p><p>实际上敲代码编译不通过 常犯的就是符号未定义和符号重定义的问题</p><p>需要注意的是：<strong>此时的符号是没有分配任何地址的，特指这个链接的符号解析阶段</strong></p><p>观察a.out的汇编代码和编译的.o文件的汇编代码进行对比我们可以发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">a.out：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_Z3sumii&gt;:</span><br><span class="line">int gdata = 10;</span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">  401000:       f3 0f 1e fa             endbr64 </span><br><span class="line">  401004:       55                      push   %rbp</span><br><span class="line">  401005:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  401008:       89 7d fc                mov    %edi,-0x4(%rbp)</span><br><span class="line">  40100b:       89 75 f8                mov    %esi,-0x8(%rbp)</span><br><span class="line">  return a + b;</span><br><span class="line">  40100e:       8b 55 fc                mov    -0x4(%rbp),%edx</span><br><span class="line">  401011:       8b 45 f8                mov    -0x8(%rbp),%eax</span><br><span class="line">  401014:       01 d0                   add    %edx,%eax</span><br><span class="line">  401016:       5d                      pop    %rbp</span><br><span class="line">  401017:       c3                      ret    </span><br><span class="line"></span><br><span class="line">0000000000401018 &lt;main&gt;:</span><br><span class="line">extern int gdata;</span><br><span class="line">int sum(int, int);</span><br><span class="line">int data = 20;</span><br><span class="line">int main() &#123;</span><br><span class="line">  401018:       f3 0f 1e fa             endbr64 </span><br><span class="line">  40101c:       55                      push   %rbp</span><br><span class="line">  40101d:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  401020:       48 83 ec 10             sub    $0x10,%rsp</span><br><span class="line">  int a = gdata;</span><br><span class="line">  401024:       8b 05 d6 2f 00 00       mov    0x2fd6(%rip),%eax        # 404000 &lt;gdata&gt;</span><br><span class="line">  40102a:       89 45 f4                mov    %eax,-0xc(%rbp)</span><br><span class="line">  int b = data;</span><br><span class="line">  40102d:       8b 05 d1 2f 00 00       mov    0x2fd1(%rip),%eax        # 404004 &lt;data&gt;</span><br><span class="line">  401033:       89 45 f8                mov    %eax,-0x8(%rbp)</span><br><span class="line">  int ret = sum(a, b);</span><br><span class="line">  401036:       8b 55 f8                mov    -0x8(%rbp),%edx</span><br><span class="line">  401039:       8b 45 f4                mov    -0xc(%rbp),%eax</span><br><span class="line">  40103c:       89 d6                   mov    %edx,%esi</span><br><span class="line">  40103e:       89 c7                   mov    %eax,%edi</span><br><span class="line">  401040:       e8 bb ff ff ff          call   401000 &lt;_Z3sumii&gt;</span><br><span class="line">  401045:       89 45 fc                mov    %eax,-0x4(%rbp)</span><br><span class="line">  return 0;</span><br><span class="line">  401048:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  40104d:       c9                      leave  </span><br><span class="line">  40104e:       c3                      ret    </span><br></pre></td></tr></table></figure><h3 id="符号重定位"><a href="#符号重定位" class="headerlink" title="符号重定位"></a>符号重定位</h3><p>符号的重定位（重定向）</p><p>对比两份.o文件的符号表，发现生成的.out 文件中两个引用全局符号放到了各自应该所在的段，不再是*UND* </p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20221214180351934.png" alt=""></p><p>并且给所有的符号分配虚拟地址</p><p>观察elf头</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20221214175752354.png" alt=""></p><p>从elf头，可以发现文件类型变为了可执行文件 入口点地址 就是 main函数指令地址</p><p>观察可以发现</p><p>最终的可执行文件 可以发现与.o 文件的内里格式几乎一致，但是不同的是多了一个</p><p> program headers （程序头）</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20221214180032201.png" alt=""></p><p>而这个程序头的作用告诉系统需要把那些内容加载到内存当中，</p><p>可以发现最先执行映射的就是.text 与.data段（其他段是GDB 特有的调试段节</p><p>所以最终执行程序的时候</p><p>就是将a.out 中的个个段映射到系统给进程分配的空间上执行</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++注解|类中的浅拷贝与深拷贝</title>
      <link href="/2023/04/01/cbase01/"/>
      <url>/2023/04/01/cbase01/</url>
      
        <content type="html"><![CDATA[<h1 id="类与深拷贝与浅拷贝测试"><a href="#类与深拷贝与浅拷贝测试" class="headerlink" title="类与深拷贝与浅拷贝测试"></a>类与深拷贝与浅拷贝测试</h1><p>测试构建类中的成员变量该类的指针，所出现的问题，与解决过程。</p><p>编译器 GCC lastest x64</p><p>系统 Linux Ubuntu22LTS</p><h2 id="错误示例一"><a href="#错误示例一" class="headerlink" title="错误示例一"></a>错误示例一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    A* test;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        a  = <span class="number">0</span>;</span><br><span class="line">        test = <span class="keyword">new</span> <span class="built_in">A</span>(); </span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">   a = num;</span><br><span class="line">   <span class="keyword">this</span>-&gt;test = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(test != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">delete</span> test;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    A a = b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在执行简单的拷贝时，我们使用编译器默认提供的拷贝构造函数。</p><p>编译的时候，确实没问题啊,但是一运行就开始报错了。返回一个段错误</p><p>众所周知段错误通常是因为访问了非法的内存而导致的。</p><p>不过这个问题的根本原因并不是调用了原本的构造函数。而是：在类的初始化构造函数中初始化了该类的指针。</p><p>由于new会调用构造函数，在构造函数中，又会在调用一次构造函数。而构造函数中又初始化了…….如此这般递归套娃，无限调用导致内存溢出？最终访问了非法的内存。</p><p>我们将初始化为空指针，心想这些构造函数总不能出问题了吧。</p><p>接着我们来到了错误示例二</p><h2 id="错误示例二"><a href="#错误示例二" class="headerlink" title="错误示例二"></a>错误示例二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> public:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  A* test;</span><br><span class="line"></span><br><span class="line">  A() &#123;</span><br><span class="line">   a = <span class="number">0</span>;</span><br><span class="line">   test = nullptr;</span><br><span class="line">  &#125;;</span><br><span class="line">   A(<span class="type">int</span> num) &#123;</span><br><span class="line">   a = num;</span><br><span class="line">   this-&gt;test = new A();</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  ~A() &#123;</span><br><span class="line">    <span class="keyword">if</span> (test != nullptr) &#123;</span><br><span class="line">      delete test;</span><br><span class="line">      test = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  A b;</span><br><span class="line">  A a = b;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b.a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出错问题这下定位到了析构函数上。可以发现堆栈调用了两次析构函数，但是第二次析构出现的段错误。</p><p>我们都知道编译器在类中默认提供一个拷贝构造。A(const A&amp; ) ，当你没有定义时，就会提供，该默认拷贝构造实际就是一个简单的<strong>浅拷贝</strong></p><p>所有值复制一遍给新的实例，指针成员变量也是同样的地址， 在析构时候呢，当然就会出现多次析构同一个内存对象问题。</p><p>析构顺序，当然是先进后出，第一次a先执行依次析构函数，由于test指针中的地址与a是相等的，都指向同一块内存，析构的时候，先把指向的内存给先析构了。到了b再来执行析构函数的时候由于test 的值还是原来的地址值，就会在调用依次析构delete， 二次delete同一个内存肯定是要出事的。</p><p>所以解决方法就是：我们主动提供一个拷贝构造函数</p><p>实现一个<strong>深拷贝</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;test = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line"><span class="comment">//这里的复制内存内容的操作省略，可以memcpy也可以什么都不做。</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;a = a.a;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这下不报错了，可以正常运行。</p><h2 id="额外测试"><a href="#额外测试" class="headerlink" title="额外测试"></a>额外测试</h2><p>我们都知道，编译器除了提供一个默认的拷贝构造以外，C+11之后还会默认提供一个operator=(const A&amp;)函数（其实也是一个简单的浅拷贝！）。所以我们来测试一个简单的函数然回值为类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在main函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="built_in">func</span>() = a;</span><br></pre></td></tr></table></figure><p>乍一眼， 可能会觉得奇怪，函数的返回值不是一个空么，不是一个妥妥的左值，为啥还能编译通过呢</p><p>可以观察到编译器给出了一个提示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: implicitly-declared ‘constexpr A&amp; A::operator=(<span class="type">const</span> A&amp;)’ is deprecated [-Wdeprecated-copy]</span><br><span class="line">   <span class="number">36</span> |   func() = a;</span><br></pre></td></tr></table></figure><p>可以发现确实编译器提供了一个返回引用的重载函数，所以左值又变右值了。</p><p>但是这下我们运行该程序，析构函数又报错了,而且观察堆栈，发现居然调用了三次析构函数，这是怎么回事捏，让我们来解析一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>() = a;</span><br></pre></td></tr></table></figure><p>到底发生了啥。</p><p>首先先调用 了一个有参构造，说明，先执行的是函数。（栈上）</p><p>然后又调用了一个无参构造，是有参构造里的成员的变量的无参初始化（堆上）。然后 将a 复制给这个匿名对象。</p><p><strong>注意：</strong></p><p>当这条语句执行完毕，跳到下一条语句，执行<strong>析构</strong>，先析构栈上的，然后<strong>再析构</strong> 匿名对象指针指向的内存地址，此时该地址是a 对象的地址。</p><p>所以，当最后要析构（第三次析构）a对象了里的地址时，就又出现了二次delete！</p><p><strong>解决方案：</strong></p><p>所以我们需要在主动自己提供一个operator=函数，将</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> A&amp; operator=(<span class="type">const</span> A&amp; s) &#123;</span><br><span class="line">   this.a = s.a;</span><br><span class="line">   this-&gt;test = new A();</span><br><span class="line"><span class="comment">//这里的复制内存内容的操作省略，可以memcpy也可以什么都不做。</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重新编译运行没有问题！这下就解决了重载= 的浅拷贝的问题。</p><p><strong>tip:在类中成员变量如果有指针，必须保证用户提供正确的重载= 操作符函数 和 拷贝构造函数！</strong></p><h2 id="最后问题"><a href="#最后问题" class="headerlink" title="最后问题"></a>最后问题</h2><p>额外测试中似乎已经给出完美答案了，但是实际上，我在继续测试的时候发现，利用内存泄露检测工具valgrind 发现了<strong>内存泄露</strong>,这是怎么一回事呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --log-file=mem.log --leak-check=full ./outDebug</span><br></pre></td></tr></table></figure><p>定位发现，居然是func函数中构造的临时对象中申请的内存没有释放。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func() = a;</span><br></pre></td></tr></table></figure><p>func()中明确了先调用其中的a的构造有参构造函数，而有参构造函数中又new了一次调用的无参构造。</p><p>然后又调用了一次重载运算符，由于我们提供了修改的重载运算符，所以这次会再次分配了一次内存，指向了新的地址，之前的地址就再也没有关联所以，自动析构的时候就会无视该地址，最终导致内存溢出！。</p><p>问题根源如此，解决方式已然清晰明了。</p><p>再修改重载=运算符函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; s) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;调用重载=函数 mythis %p \n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;s)&#123;</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;a = s.a;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;test != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;test;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;test = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">  <span class="comment">//这里的复制内存内容的操作省略，可以memcpy也可以什么都不做。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再进行一次编译运行内存检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">==66394== Memcheck, a memory error detector</span><br><span class="line">==66394== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.</span><br><span class="line">==66394== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==66394== Command: ./outDebug /usr/bin/env /bin/sh /tmp/Microsoft-MIEngine-Cmd-sn4tmhv3.qov</span><br><span class="line">==66394== Parent PID: 21040</span><br><span class="line">==66394== </span><br><span class="line">==66394== </span><br><span class="line">==66394== HEAP SUMMARY:</span><br><span class="line">==66394==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==66394==   total heap usage: 5 allocs, 5 frees, 73,776 bytes allocated</span><br><span class="line">==66394== </span><br><span class="line">==66394== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==66394== </span><br><span class="line">==66394== For lists of detected and suppressed errors, rerun with: -s</span><br><span class="line">==66394== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>再无错误，问题结束。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础08 | Socket简单的概念</title>
      <link href="/2023/03/31/linux08/"/>
      <url>/2023/03/31/linux08/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="Socket的简单概念"><a href="#Socket的简单概念" class="headerlink" title="Socket的简单概念"></a>Socket的简单概念</h2><p>sock的本质，可以理解为高级管道？，也是伪文件。</p><p>有两端，有两个，成对的，是封装好的。</p><p>也可以理解为实际上一个文件描述符指向两个管道文件的缓冲区，一个读一个写。文件描述符服务端一个，客户端一个，然后完成全双工通信</p><h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>大端：低地址存高位，高地址存低位</p><p>小端：低地址存地位，高地址存高位</p><p>在计算机中一般数据结构存储都是小端存储法</p><p>网络字节流则是大端法存储。（历史遗留问题）</p><p>所以呢我们使用库函数做网络字节序和字节序进行转换</p><ul><li>htonl</li><li>htons</li><li>ntohl</li><li>ntohs</li></ul><p>n是net网络</p><p>h是host主机</p><p>l是长整32位数,ipv4用</p><p>s是短整16位数,port用</p><h2 id="ip地址转换函数"><a href="#ip地址转换函数" class="headerlink" title="ip地址转换函数"></a>ip地址转换函数</h2><p>前置函数</p><p>都支持ipv4 ipv6</p><p>inet_ntop</p><p>ip转二进制</p><p>inet_pton</p><p>二进制转ip</p><h2 id="sockaddr的数据结构"><a href="#sockaddr的数据结构" class="headerlink" title="sockaddr的数据结构"></a>sockaddr的数据结构</h2><p>原始的已经废弃了：struct sockaddr，毕竟一开始只是为了ipv4的，没想着拓展，用着用着不好用，换了其他新的。<br>如此就会出现历史遗留问题比如说使用如下函数：<br><strong>bind</strong></p><p><strong>accept</strong></p><p><strong>connect</strong></p><p>传值的类型需要进行强转</p><p>现在是struct sockaddr_in(搞不懂为啥不直接代替，而是加了一个in)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">               <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">               <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Internet address. */</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">               <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure><p>为啥 in_addr 这个结构体只有一个成员，估计以前遗留的被删了，要么就是为了扩展。</p><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br></pre></td></tr></table></figure><ul><li>domain <ul><li>常用的三个宏</li><li>AF_INET ipv4</li><li>AF_INET6 ipv6</li><li>AF_UNIX 本机传输linux下</li></ul></li><li>type<ul><li>SOCK_STREAM 流 (tcp)</li><li>SOCK_DGRM 数据报（udp）</li></ul></li><li>protocol 协议<ul><li>传值为0是默认协议</li></ul></li><li>成功返回文件描述符</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>)</span><br></pre></td></tr></table></figure><p>bind 绑定的意思，将网络参数，地址绑定到创建的socket 文件上</p><ul><li>sockfd 文件描述符</li><li>addr 结构体sockaddr* 需要注意要进行类型强转哦</li><li>addrlen addr的长度</li></ul><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span><br></pre></td></tr></table></figure><p>注意，这玩意不是监听，而是指定允许多少个客户端同时建立连接</p><p>，处于三次握手的队列和刚刚建立三次握手队列的链接数和。</p><ul><li>backlog</li></ul><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span> *addrlen)</span></span><br></pre></td></tr></table></figure><ul><li>乍一看跟bind的参数是一样的，但是注意：</li><li>第二个参数是传参参数：传出客户端的ip地址</li><li>第三个比较特别，这是一个传入传出的参数，先读一次再写一次</li><li>返回值 成功返回一个 <strong>新的</strong> socket的文件描述符，这个文件描述符，<strong>用来与客户端的服务端之间的通信</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RETURN VALUE</span><br><span class="line">       On  success,  these  system  calls return a file descriptor for the ac‐</span><br><span class="line">       cepted socket (a nonnegative integer).  On error, -1 is returned, errno</span><br><span class="line">       is set appropriately, and addrlen is left unchanged.</span><br></pre></td></tr></table></figure><p>man文档中也有表明</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>建立连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>客户端用，主动用来与服务端建立连接，都是传入参数，都挺简单</p><ul><li>传入一个服务端的addr</li><li>大小</li></ul><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>话不多说直接上代码，比较简单的程序</p><p>服务端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SER_PORT  6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SER_IPV4 <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd;</span><br><span class="line">    <span class="comment">//服务端地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="comment">//创建socket</span></span><br><span class="line">    lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//指定ip协议族ipv4</span></span><br><span class="line">    serv_addr.sin_family  = AF_INET;</span><br><span class="line">    <span class="comment">//主机端口号，这里需要网络序列转换存储</span></span><br><span class="line">    serv_addr.sin_port = htons(SER_PORT);</span><br><span class="line">    <span class="comment">//INADDR_ANY是与一个系统提供的宏，表示是一个有效的任意值，同养也需要存储转换</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//绑定套接字地址数据</span></span><br><span class="line">    bind(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">//设定默认连接队列上限128</span></span><br><span class="line">    listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">//传出函数，这个是客户端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="comment">//定义一个传出的客户端地址的长度，传入传出参数</span></span><br><span class="line">    <span class="type">socklen_t</span> clinet_addrlen;</span><br><span class="line">    <span class="comment">//预订默认长度的值</span></span><br><span class="line">    clinet_addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">//接受函数调用，开始阻塞知道，客户端连接</span></span><br><span class="line">    <span class="type">int</span> cfd = accept(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;clinet_addrlen);</span><br><span class="line">    <span class="comment">//指定一个缓冲数据存放</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//读客户端发送数据</span></span><br><span class="line">        <span class="type">int</span> n = read(cfd, buf, BUFSIZ);</span><br><span class="line">        <span class="comment">//字符大小写转换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    write(cfd, buf, n); </span><br><span class="line">    close(lfd);</span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SER_PORT  6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SER_IPV4 <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cfd;</span><br><span class="line">    <span class="comment">//创建套接字文件没啥可说的</span></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//bind可以不绑定，让系统帮你调用bind，客户端限定</span></span><br><span class="line">    <span class="comment">//定义服务器的地址，地址长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> serv_addrlen;</span><br><span class="line">    <span class="comment">//初始化，方式结构体创建失败，良好习惯</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="comment">//协议族于服务端一致</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//serv_addr.sin_addr.s_addr = htons(SER_IPV4);</span></span><br><span class="line">    <span class="comment">//可以直接转换换成以下写法,转换成下面的写法，请求的地址不对</span></span><br><span class="line">    inet_pton(AF_INET, SER_IPV4, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">//端口</span></span><br><span class="line">    serv_addr.sin_port = htons(SER_PORT);</span><br><span class="line">    <span class="comment">//输入缓冲</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="comment">//发起连接</span></span><br><span class="line">    <span class="type">int</span> ret = connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//客户端的处理逻辑</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        fgets(buf, BUFSIZ, <span class="built_in">stdin</span>);</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="type">int</span> n = read(cfd, buf, BUFSIZ);</span><br><span class="line">        write(STDOUT_FILENO, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上调用的函数基本上错误都给省了没有实现，所以会有一些，意料之外的结果。</p><p>在IO 函数中，曾提了一两嘴关于read 和write在操作网络字节流的一些需要注意的点。</p><p>手动修改write 和read 函数调用方式，能够避免出现，数据一次没读全需要分包的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//write</span></span><br><span class="line"><span class="type">ssize_t</span> write_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> buflen = <span class="built_in">strlen</span>(buf) ;</span><br><span class="line"><span class="keyword">while</span>(buflen&gt; wirte_len)&#123;</span><br><span class="line">    <span class="type">ssize_t</span> retwrite = write(cfd, buf+ write_len,buflen - write_len);</span><br><span class="line">    <span class="keyword">if</span>(retwrite =&lt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    wirte_len += retwrite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//read</span></span><br><span class="line"><span class="type">ssize_t</span> read_len = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> buflen = <span class="built_in">strlen</span>(buf) ;</span><br><span class="line"><span class="keyword">while</span>(buflen&gt; read_len)&#123;</span><br><span class="line">    <span class="type">ssize_t</span> retread = read(cfd, buf+ read_len,buflen - read_len);</span><br><span class="line">    <span class="keyword">if</span>(retread &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        close(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(retread == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//Todo：判断信号错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    read_len += retread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你说，一般不会出现错误，没有特别需求就不进行检查吧</p><p>不怕一万就怕万一，一个健壮的代码，需要考虑所有可能的情况。</p><p>比如说端口号在调用结束后会有一段时间的time_wait的状态，再执行服务器，实际上是无法bind绑定端口的。</p><p>实际上如果想偷懒，这里可以做一个错误函数封装。</p><p>封装一下容易出错的函数。这个出错函数并非只能在一次项目中使用，在别的项目中，一样可以调出来使用。</p><p>这里就不全部放出来了。我封装的东西还蛮多的。至于为什么直接封装成首字母大小的原因，就是比较方便查看man文档</p><h3 id="readn"><a href="#readn" class="headerlink" title="readn"></a>readn</h3><p>由于socket的read write 操作不同一般的文件的io操作</p><p>socket上文件读写常会比函数调用指定的字节少</p><p>（网络波动之类的原因，比如丢包什么的。或者写端根本没这么多字节的等等），</p><p>再判断的时候如果 只是小于0就认为错误是比较草率的。有些并非是错误的情况，依然会被杀死。</p><p>还有的可能就是socket的缓冲区已经到达了极限容量，无法执行读写操作，或者被信号中断。</p><p>遇到这种情况，就必须再次调用read以写入或输出剩余的字符，</p><p>所以就需要readn（可以理解为read调用n次）</p><p>根据网络UNIX 网络编程卷一中，提供了readn 和writen的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> nleft;<span class="comment">//剩下的字节数</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;<span class="comment">//读取的字节数</span></span><br><span class="line">    <span class="type">char</span> *ptr;<span class="comment">//指向读取的目标的缓冲区</span></span><br><span class="line">    ptr = vptr;</span><br><span class="line">    nleft =  n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)&#123;<span class="comment">//大于0说明读一次还没读完</span></span><br><span class="line">        <span class="keyword">if</span>((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)&#123;<span class="comment">//被信号中断那就重新读取</span></span><br><span class="line">                nread = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//其他情况直接返回错误</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;readn error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nread == <span class="number">0</span>)&#123;<span class="comment">//等于零就说明读取完了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//大于零的情况，说明多读n次还没完,</span></span><br><span class="line">        nleft -= nread;<span class="comment">//更新剩下字节的值</span></span><br><span class="line">        ptr += nread;<span class="comment">//文件指针偏移。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;<span class="comment">//返回实际读取的字节数;一般循环跳出后nleft其实是0；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="writen"><a href="#writen" class="headerlink" title="writen"></a>writen</h3><p>实现思想与readn一样。这里就不进行解释了。直接上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> nleft;</span><br><span class="line">    <span class="type">int</span> nwritten;</span><br><span class="line">    nleft = n;</span><br><span class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        nwritten == write(fd, ptr, nleft);</span><br><span class="line">        <span class="keyword">if</span>(nwritten &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nwritten;</span><br><span class="line">        &#125;</span><br><span class="line">        nleft -= nwritten;</span><br><span class="line">        ptr += nwritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础11 | IO函数</title>
      <link href="/2023/03/30/linux11/"/>
      <url>/2023/03/30/linux11/</url>
      
        <content type="html"><![CDATA[<h1 id="IO-函数"><a href="#IO-函数" class="headerlink" title="IO 函数"></a>IO 函数</h1><p>文件基本操作</p><ul><li>打开</li><li>读取</li><li>写入</li><li>关闭</li></ul><p>需要引入如下头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是上面的函数实际上是通过多参数va_list实现的，C 库函数函数中没有函数重载。</p><ul><li><strong>const char * pathname</strong><ul><li>可以填写相对路径和绝对路径</li></ul></li><li><strong>int flags（常用</strong><ul><li>O_CREAT  当文件不存在创建。</li><li>O_RDONLY, 顾名思义，只读</li><li>O_WRONLY 只写</li><li>O_RDWR. 读写都有</li><li>O_APPEND 在文件末尾write添加</li><li>O_TRUNC 当文件不存在创建并清零。（常用在管道</li><li>O_CLOEXEC 是原子操作 ,当执行exec 自动关闭该文件描述符，防止EXEC后的子进程调用该文件描述符。</li></ul></li><li><strong>mode_t mode</strong><ul><li>当文件不存在创建时，需要有mode值，也就是文件的权限</li><li>S_IRWXU | S_IRWXG | S_IRWXO 分别对应<br>00700|00070|00007（也可以知直接填数字，这样更快</li><li>S_I 固定开头 ，中间有三个W（写） R（读） X（执行） 有三个固定结尾 USR（用户） GRP（组） OTH（其他人）</li></ul></li><li><strong>return int</strong> <ul><li>返回 成功 0 失败-1 并且perror()打印错误 ;</li></ul></li></ul><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>int fd</strong><ul><li>文件描述符，不止是普通文件，也是socket or fifo ,甚至可以是 stderr,stdout ,stdin</li></ul></li><li><strong>void * buf</strong><ul><li>要读的数据存入哪</li><li>这玩意可以进行偏移，单位是字节（多进程拷贝啥的。</li><li>可以是结构体，实现方式其实是用<a href="ELF">ELF</a>格式解析。</li><li>网络数据包之类的 比如socket 传递的包</li></ul></li><li><strong>size_t count</strong><ul><li>要读的数据大小。</li></ul></li><li><p><strong>return ssize_t</strong></p><ul><li><p>实际读了多少字节</p></li><li><p>读完读到文件尾返回0 ，没读到文件结尾但是成功读取返回成功读取的字节数（一般文件）</p><p>当读取的是socket的文件描述符时。需要注意的是，返回0有很多个意义。</p><ul><li><p>对端或者本端关闭socket文件描述符或者读到FIN(没差)。</p></li><li><p>对端客户端关闭后导致的服务端的read即使返回值为0，服务端也可以继续进行写。 </p></li><li><p>当读取小于0可以检查信号位，检测是否是信号中断影响</p></li></ul></li></ul></li></ul><h4 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h4><blockquote><p>在<a href="https://baike.baidu.com/item/计算机科学/9132?fromModule=lemma_inlink">计算机科学</a>中，是一种用于<a href="https://baike.baidu.com/item/二进制文件/996661?fromModule=lemma_inlink">二进制文件</a>、<a href="https://baike.baidu.com/item/可执行文件/2885816?fromModule=lemma_inlink">可执行文件</a>、<a href="https://baike.baidu.com/item/目标代码/9407934?fromModule=lemma_inlink">目标代码</a>、<a href="https://baike.baidu.com/item/共享库/5101825?fromModule=lemma_inlink">共享库</a>和<a href="https://baike.baidu.com/item/核心转储/16772089?fromModule=lemma_inlink">核心转储</a>格式文件的<a href="https://baike.baidu.com/item/文件格式/6156907?fromModule=lemma_inlink">文件格式</a>。</p><p>是UNIX系统实验室（USL）作为<a href="https://baike.baidu.com/item/应用程序二进制接口/497638?fromModule=lemma_inlink">应用程序二进制接口</a>（Application Binary Interface，<a href="https://baike.baidu.com/item/ABI/10912305?fromModule=lemma_inlink">ABI</a>）而开发和发布的，也是<a href="https://baike.baidu.com/item/Linux/27050?fromModule=lemma_inlink">Linux</a>的主要可执行文件格式。</p><p>1999年，被86open项目选为<a href="https://baike.baidu.com/item/x86架构/7470217?fromModule=lemma_inlink">x86架构</a>上的类<a href="https://baike.baidu.com/item/Unix操作系统/851445?fromModule=lemma_inlink">Unix操作系统</a>的二进制文件标准格式，用来取代<a href="https://baike.baidu.com/item/COFF/8999517?fromModule=lemma_inlink">COFF</a>。因其<a href="https://baike.baidu.com/item/可扩展性/8669999?fromModule=lemma_inlink">可扩展性</a>与灵活性，也可应用在其它处理器、<a href="https://baike.baidu.com/item/计算机系统/7210959?fromModule=lemma_inlink">计算机系统</a>架构的操作系统上。</p></blockquote><p>ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p><hr><p><strong>结构体信息通常都放在ELF header中</strong></p><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>int fd</strong><ul><li>文件描述符，不止是普通文件，也是socket or fifo ,甚至可以是 stderr,stdout ,stdin</li></ul></li><li><strong>void * buf</strong><ul><li>要读的数据存入哪</li><li>这玩意可以进行偏移，单位是字节（多进程拷贝啥的。</li><li>可以是结构体。</li><li>网络数据包之类的 比如socket 传递的包</li></ul></li><li><strong>size_t count</strong><ul><li>要读的数据大小。</li></ul></li><li><strong>return ssize_t</strong><ul><li>实际读了多少字节</li></ul></li></ul><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>关闭文件描述符，释放进程的PCB中资源</p><p>需要注意的是，close不是单纯的关闭文件描述符，在设计多个进程共用一套PCB时，close关闭的文件描述符的操作是将，该当前进程下的文件描述符的<strong>引用计数</strong>（类似Windows下HANDLE句柄 ）减1，当彻底为<strong>零</strong>时，才是彻底释放进程中的PCB的资源和所占用的内存资源。</p><h2 id="文件描述符的操作函数"><a href="#文件描述符的操作函数" class="headerlink" title="文件描述符的操作函数"></a>文件描述符的操作函数</h2><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>复制文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>实际上就是输出重定向常用函数</p><p><strong>返回新的文件描述符</strong></p><p>dup2可以指定重定向指定的文件描述符</p><h3 id="fsync"><a href="#fsync" class="headerlink" title="fsync"></a>fsync</h3><p>文件数据同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>强制将缓存中的数据写入磁盘</p><p>要求写入立刻生效，谨慎调用</p><p>调用的需要：</p><p>硬盘和内存之间的交互有两个缓存区，交互这两个缓存区是同步的，在从缓存区传到硬盘或内存中。</p><p>当需要立刻将数据写入文件操作执行完成，可以调用该函数。</p><p>但是调用这个是会占用是时间的，根据你的缓存调度速度，硬件配置等因素。</p><h2 id="文件读写位置指针"><a href="#文件读写位置指针" class="headerlink" title="文件读写位置指针"></a>文件读写位置指针</h2><p>钟硕肘子， 文件呢，读取的时候，又有提供一个指针的，指向文件内数据的位置。</p><p>我们可以通过lseek函数将指针进行位置偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>int fd</strong> </p><ul><li>要操作的文件的描述符</li></ul></li><li><p><strong>off_t offset</strong></p><ul><li>偏移量 or 读写位置</li></ul></li><li><p><strong>int whence</strong></p><ul><li>可以理解为操作设置</li><li>SEEK_SET<ul><li>设置当前读写位置为offset</li></ul></li><li>SEEK_CUR<ul><li>将当前的读写位置偏移offset字节</li><li>有读权限的话，即使偏移的位置没有值也会补0补到偏移的指针位置，否则就会失败</li></ul></li><li>SEEK_END<ul><li>指向末尾后，在偏移offset字节</li></ul></li></ul></li><li><p><strong>return off_t</strong></p><ul><li><blockquote><p>Upon successful completion, lseek() returns the resulting offset  location  as  measured  in bytes from the beginning of the file.  On error, the value (off_t) -1 is returned and errno is set to indicate  the  error.</p></blockquote></li><li><p>翻译过来就是成功返回处理后的从0开始的读写位置</p></li><li><p>失败返回-1并 返回error</p></li></ul></li></ul><h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemp</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkostemps</span><span class="params">(<span class="type">char</span> *template, <span class="type">int</span> suffixlen, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>man文档描述：</p><blockquote><pre><code>  The  mkstemp() function generates a unique temporary filename from tem‐   plate, creates and opens the file, and returns an open file  descriptor   for the file.   The  last six characters of template must be &quot;XXXXXX&quot; and these are replaced with a string that makes the filename unique.  Since it will  be modified,  template  must  not  be a string constant, but should be declared as a character array.   The file is created with permissions 0600, that is, read plus write for   owner  only.  The returned file descriptor provides both read and write   access to the file.  The file is opened with the open(2)  O_EXCL  flag,   guaranteeing that the caller is the process that creates the file.</code></pre></blockquote><p>翻译总结下来得出：</p><ul><li>生成一个临时的temp 文件，并且放回fd该文件的文件描述符</li><li>该文件的生命周期，通常是close()结束，不保证数据长期有效</li><li><strong>char * temporary</strong> <ul><li>有固定的内容，尾部必须是“XXXXXX”前面倒是无所谓。</li></ul></li></ul><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">flock</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> operation)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给文件上锁，放置文件在进程同步中出现访问问题。（防止篡改</p><ul><li><p><strong>int operation</strong></p><ul><li>LOCK_SH 建立共享锁定，可以超过多个进程使用进入访问这个锁，虽然都可以访问这个锁，但是只能读，不可以写。</li><li>LOCK_EX  建立互斥锁定，只能有一个程序使用这个文件。</li><li>LOCK_UN 解锁文件访问状态。实际上文件close或异常关闭的时候也是可以自动解锁的。（有时差，并不是立刻解锁（比如网络套接字有协议方面的等待。</li><li>LOCK_NB 非阻塞锁，如果无法建立锁定，不会等待阻塞进程他会立刻返回进程。</li></ul></li></ul><ul><li><p><strong>return int </strong></p><ul><li>成功返回0 失败返回-1并输出error</li></ul></li></ul><p>在消息分发与事件处理起很大的作用</p><h3 id="文件锁特性测试"><a href="#文件锁特性测试" class="headerlink" title="文件锁特性测试"></a>文件锁特性测试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* fileName = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line">  <span class="type">int</span> fd = open(fileName, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line">  <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> wret = write(fd, <span class="string">&quot;hallorye!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;hallorye!&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; write: %dflock:%d\n&quot;</span>, wret, flock(fd, LOCK_EX));</span><br><span class="line">    sleep(<span class="number">6</span>);</span><br><span class="line">    flock(fd, LOCK_UN);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    perror(<span class="string">&quot;open error &quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个程序，开两个进程，可以发现当第一个进程结束后，第二个进程才开始对这个文件进行写的操作。</p><p>但是当其他不同的进程并没有给这文件加锁，而是直接进行打开写入也是可以成功的，无视锁的限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* fileName = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(fileName, O_CREAT | O_RDWR, S_IRWXU | S_IRWXG | S_IRWXO);</span><br><span class="line"><span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="type">int</span> wret = write(fd, <span class="string">&quot;hallorye!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;hallorye!&quot;</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; write: %d\n&quot;</span>, wret);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  perror(<span class="string">&quot;open error &quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明文件锁这玩意，只有对其进行认知，设置的进程有效，是一个建议锁，其他进程因为不知道锁，就相当于没有，可以直接写入。</p><p>那么问题来了，如果，我将 写入与上锁语句顺序修改又会如何呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flock(fd, LOCK_EX)；</span><br><span class="line"><span class="type">int</span> wret = write(fd, <span class="string">&quot;hallorye!&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;hallorye!&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>总结：一样， 其他没有认知的进程一样可以直接进行写入访问。所以文件锁不过是建议锁罢了</strong></p><h2 id="FCNTL"><a href="#FCNTL" class="headerlink" title="FCNTL"></a>FCNTL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件控制函数</p><p>可变参数函数。</p><ul><li><strong>int fd</strong><ul><li>要操作的文件描述符</li></ul></li><li><strong>int cmd</strong><ul><li><strong>F_DUPFD</strong> ，dup fd 作用与dup类似，将旧的文件描述符复制到新的位置，这个新的位置根据后方传入的arg ,大于或等于，并且未使用的文件描述符的位置，不是重定向，虽然共享同一块进程控制块PCB（文件表项），但是新描述符又自己的的一套文件描述符标志,其中FD_CLOEXEC （close on exec, not on-fork）文件描述符标志清除（执行exec后的新进程不会自动释放fd，也能使用这个fd（<strong>管道</strong>））。<strong>返回值成功返回新的文件描述符</strong></li><li><strong>F_GETFD</strong> 取FD 文件标志 ，一般是用来判断FD_CLOEXEC，返回值就是标志；</li><li><strong>F_SETFD</strong> 设置FD 的文件标志 。</li><li><strong>F_GETFL</strong> 取得文件描述符的状态标志，也就是读写权限的标志 O_APPEND,之列的</li><li><strong>F_SETFL</strong> 设置FD 文件状态标志：不过只能设置三个位 O_APPEND,O_NONBLOCK （非阻塞访问）,O_ASYNC：（异步访问）</li><li><strong>F_GETLK</strong> 得到锁状态</li><li><strong>F_SETLK</strong> 设置文件锁状态。此时传入的flock 结构的I_type 值必须是F_RDLC,(读锁)F_WRLCK (写锁)，F_UNLCK 解锁状态。</li><li><strong>F_SETLKW(wait)</strong> 同上，区别不同的是，当无法设置锁的时候，他会一直等待锁的权限阻塞进程，直到成功return 0。或者，直到信号影响为止，返回-1 错误码为EINTR。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础12 | 文件和目录函数</title>
      <link href="/2023/03/29/linux12/"/>
      <url>/2023/03/29/linux12/</url>
      
        <content type="html"><![CDATA[<h1 id="LINUX-文件和目录函数"><a href="#LINUX-文件和目录函数" class="headerlink" title="LINUX 文件和目录函数"></a>LINUX 文件和目录函数</h1><p>与Linux 系统库函数 提供的open有些许不同，这次来讲解关于stdio.h C库种对文件的处理,但是本质上其实还是对open是进行的封装的。</p><p>从本院角度来看，两者的区别显而易见</p><ul><li><code>open</code>是UNIX系统调用函数（包括LINUX等），返回的是文件描述符（File Descriptor），它是文件在文件描述符表里的索引。</li><li><code>fopen</code>是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api。返回的是一个指向文件结构的指针。 </li></ul><p>如果从文件IO的角度来看：</p><ul><li>前者属于低级IO函数，</li><li>后者属于高级IO函数。</li></ul><p>低级和高级的简单区分标准是：谁离系统内核更近。低级文件IO运行在内核态，高级文件IO运行在用户态。</p><p>再跨平台这一块，当然还是fopen 比较OK</p><p>这一系列函数一样也是</p><p>对文件进行操作</p><p>打开，关闭，创建，删除，拓展，压缩等。</p><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;<span class="comment">//文件描述符</span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;<span class="comment">//文件输出重定向</span></span><br></pre></td></tr></table></figure><p>提供了这么几个函数，我们来看看参数</p><ul><li>const char * pathname<ul><li>文件的绝对路径</li></ul></li><li>char *mode <ul><li>r 只读，文本文件。</li><li>r+ 读写打开</li><li>w truncate file截断这个文件 并且将其初始0长度，再只写打开， 如果文件不存在也会创建。（<strong>文件原有数据会消失</strong>）<strong>搭配r 就不会截断</strong>。</li><li>w+  文件不存在创建，<strong>存在就截断为0重写</strong>。<strong>搭配r 就不会截断</strong>。</li><li>a 追加当文件不存在创建，文件流的指针指向文件末尾 </li><li>a+ 初始化文件流读的指针定位到 </li><li>b 二进制打开</li><li>t 文本打开（默认都有）</li></ul></li><li>return FILE* <ul><li>返回结构体指针，当失败是返回nullptr</li></ul></li></ul><p>fdopen 就是将fd，文件描述符转会为fd的简单操作。</p><ul><li><p>坑：不知道为什么open 打开的文件fd 再用fdopen 打开后无法写入和读取即使都rw权限拉满&gt;</p></li><li><p>问题： fread 参数没整对，</p></li><li><p>```c<br>NAME</p><pre><code>   fread, fwrite - binary stream input/output</code></pre><p>SYNOPSIS</p><pre><code>   #include &lt;stdio.h&gt;   size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);   size_t fwrite(const void *ptr, size_t size, size_t nmemb,                 FILE *stream);</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - size_t size 参数 : 读取的 基本单元 字节大小 , 单位是字节 , 一般是 buffer 缓冲的单位大小 ;</span><br><span class="line"></span><br><span class="line">    如果 buffer 缓冲区是 char 数组 , 则该参数的值是 sizeof(char) ;</span><br><span class="line">    如果 buffer 缓冲区是 int 数组 , 则该参数的值是 sizeof(int) ;</span><br><span class="line"></span><br><span class="line">    //错误就在于我直接sizeof(整个数组大小)了；</span><br><span class="line"></span><br><span class="line">fileno 函数就是反之将FILE* 转换为fd。</span><br><span class="line"></span><br><span class="line">freopen 后方多的这个参数呢其实就是文件重定向前的位置。一般常用三个值</span><br><span class="line"></span><br><span class="line">- stdout </span><br><span class="line">- stdin</span><br><span class="line">- stderr</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">   </span><br><span class="line">   FILE* test3 = freopen(&quot;1.txt&quot;, &quot;w+&quot;, stdout);</span><br><span class="line">   if (test3 == nullptr) &#123;</span><br><span class="line">   perror(&quot;文件3打开失败捏！&quot;);</span><br><span class="line">   exit(0);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;%s(%d):%s\n&quot;, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>//可以打开文件发现stdout的内容被重定向到文件中了。</p><h2 id="fread-and-fwrite"><a href="#fread-and-fwrite" class="headerlink" title="fread and fwrite"></a>fread and fwrite</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       fread, fwrite - binary stream input/output</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb,</span></span><br><span class="line"><span class="params">                     FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>void* ptr<ul><li>fread读取的buf缓冲区，你可以new 堆上或者在栈上。大小最大么，根据系统，位数，来定。在堆上32位 4G 能单次分配2G 左右，64位呢能8G左右，相对于Windows， linux管理方式下 能使用的更多一点。 </li></ul></li><li>size_t size<ul><li>每次读取的字节数量： 怎么读的，按照多少字节分单位。每一次多少个大小</li><li>fread wirte  每次写的字节数量</li></ul></li><li>size_t nmemb<ul><li>要读多少次。</li><li>要写多少次。</li></ul></li><li>FILE * stream<ul><li>要被操作的文件结构体指针。</li></ul></li><li>return size_t<ul><li>需要注意的是：</li><li>根据所设定的单位读了多少次,从0开始t 。</li><li>On  success,  fread()  and  fwrite() return the number of items read or<pre><code>written.  This number equals the number of bytes transferred only  whensize  is 1.  If an error occurs, or the end of the file is reached, thereturn value is a short item count (or zero).</code></pre></li></ul></li></ul><p>​                                                                                                                                                                                                                                                                                                                                文件流操作。</p><p>tip:</p><p>硬盘的读取，柱头，盘片，扇区。（这是机械硬盘才有的概念）所以就为了方便读取，则分盘符供给硬盘盒软盘使用。所以A，B，是分给软盘使用。而硬盘则分配了C盘</p><p>文件流的操作实际上就是与硬盘的读写取相对应，多少nmemb其实对应硬盘多少转，多少个扇区，然后size 对应磁头的偏移位置，每读写一次偏移多少。</p><h2 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       fgetc, fgets, getc, getchar, ungetc - input of characters and strings</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些函数，所调用的文件结构体 必须以t模式打开，因为，判断条件为EOF 或者n ， \0，当文件中没有EOF ，可能会出现意料之外的事。</p><p>需要注意的事中间需要在对一个文件进行读写时，需要注意文件内置的指针位置。获取位置可以用ftell 我们可以用fseek进行调整。rewind初始化到头的位置等。</p><h2 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将知道哪个字符或者字符串写入文件流中，当然了，是从文件指针的位置开始传。</p><p><strong>需要注意的是，由于这是C库函数，当然对C 类的字符串支持OK，其他类型的字符串的结尾 必须得是\0或者空</strong> </p><p>编译的时候编译器会将该函数报为不安全的函数，可能会导致栈溢出，等问题。所以呢提供了fputs_s稍微安全一点的函数来代替。</p><h2 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h2><pre><code>   Note  that fflush() flushes only the user-space buffers provided by the   C library.  To ensure that the data is physically stored  on  disk  the   kernel  buffers  must  be  flushed  too,  for  example, with sync(2) or   fsync(2).</code></pre><p>作用与fsync类似，同样是将缓存区的数据写入内存中，确保写到内存里，操作的时间消耗是不可控的。</p><h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p>每个文件进行读写时，都会内置一个文件指针，通过文件指针的操作我们可以随心所欲的修改文件数据的读写位置。</p><h3 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>fseek 函数说实话，作用跟lseek没差别，参数都一样。</p><p>需要注意的是fgetpos 的作用是64位的文件指针，64X的系统下文件的大小通常单次读写大小实际上很大，原有函数对64位的支持不是很好，所以就可以使用fgetpos64，来跳转64x位下的大文件。</p><p>注：fseek64也有64位，所以通常最常用的还是fseek</p><h3 id="feof"><a href="#feof" class="headerlink" title="feof"></a>feof</h3><p>NAME<br>       clearerr, feof, ferror, fileno - check and reset stream status</p><p>SYNOPSIS</p><pre><code>   #include &lt;stdio.h&gt;</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileno(): _POSIX_C_SOURCE</span><br></pre></td></tr></table></figure><p>可见，该函数是用来检测并且返回设置文件流的状态</p><p><strong>feof文件未到尾部则返回 0,文件读到最后一个字节，并不会触发，即使末尾已经是空，还要再读1次，才会认为读到了eof,并返回1</strong> </p><p>ferror 则用于检测文件是否出现读写错误状态，通常用来检测上一个操作的错误问题。然后搭配clearerr清除错误状态。</p><p>clearerr清除错误状态后，在进行指针偏移的读写操作，即使超过文件范围依旧不会报错，<strong>seek本身在跳转的时和文件实际的大小不匹配一样是不会报错</strong>。</p><p>需要注意的是，文件必须需要写权限，写权限可以将文件截断后再宏建</p><h1 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h1><p>c库并没有提供文件夹的创建函数，所以这是unix内核的函数。</p><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>SYNOPSIS</p><pre><code>   #include &lt;sys/stat.h&gt; //文件的状态的结构体等   #include &lt;sys/types.h&gt; //宏，和各种类型。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdirat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</p><pre><code>   mkdirat():       Since glibc 2.10:           _POSIX_C_SOURCE &gt;= 200809L       Before glibc 2.10:           _ATFILE_SOURCE</code></pre><p><strong>相对路径，生成在当前进程的工作目录下。</strong></p><h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><pre><code>   #include &lt;unistd.h&gt;   int rmdir(const char *pathname);</code></pre><p>DESCRIPTION<br>       rmdir() deletes a directory, which must be empty.</p><p>删除文件夹，该文件夹必须是空文件夹</p><p>所以这玩意其实比较鸡肋，我们常常使用remove，这是一个C 库函数</p><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p> remove()  deletes  a  name from the filesystem.  It calls unlink(2) for files, and rmdir(2) for directories.</p><p>删除文件夹，并调用unlink 将文件夹中的文件断开连链接（硬链接，等于删除文件。当然当有进程使用，打开改文件管道，他会直到该文件关闭，再执行删除。</p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchownat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname,</span></span><br><span class="line"><span class="params">             <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>unix的系统函数，可以修改文件或者目录的用户组。</p><p>chanage owner ，修改所属， 并且<strong>修改的所属用户组，用户也必须修改。</strong></p><p>不过一般用户组和用户的代码是相等的</p><p>当然了，这还是要提权的，没有权限啥也不是。当然了，如果修改自己所属组所属用户的东西。那就不需要进行提权。</p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>链接删除,删除文件硬链接。当文件硬连接数为1 删除该文件。</p><p>UNLINK(2)                  Linux Programmer’s Manual                 UNLINK(2)</p><p>NAME<br>       unlink, unlinkat - delete a name and possibly the file it refers to</p><p>SYNOPSIS</p><pre><code>   #include &lt;unistd.h&gt;</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlinkat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><h3 id="linux文件与软硬链接"><a href="#linux文件与软硬链接" class="headerlink" title="linux文件与软硬链接"></a>linux文件与软硬链接</h3><p>在linux下，文件有着三个重要的管理结构，</p><p>文件名，inode 元数据块</p><p> 我们知道文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文<strong>件数据块 (data block)</strong>，数据块是<strong><em>记录文件真实内容的地方\</em></strong>；而元数据则是文件的<strong><em>附加属性\</em></strong>，如<strong>文件大小、创建时间、所有者等信息</strong>。在 Linux 中，元数据中的 inode 号（<strong>inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号</strong>）才是文件的<strong><em>唯一标识而非文件名\</em></strong>。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。如<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/#fig1">图.</a>展示了程序通过文件名获取文件内容的过程。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/20200318092834243.png" alt="img"></p><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，<strong>ln</strong> 命令产生硬链接。</p><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>硬链接，非同名的同一个文件引用</p><p>软连接，快捷方式。</p><h2 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">DIR *<span class="title function_">fdopendir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开文件夹。</p><p>通常只是打开后还需要搭配readdir来进行使用</p><p>将文件夹结构体指针转为dirent 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="type">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="type">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                   by all filesystem types */</span></span><br><span class="line">    <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>d_type下有这么几种文件类型。通过判断可以过滤输出所需的文件值。</p><pre><code>DT_BLK      This is a block device.          DT_CHR      This is a character device.          DT_DIR      This is a directory.          DT_FIFO     This is a named pipe (FIFO).          DT_LNK      This is a symbolic link.          DT_REG      This is a regular file.          DT_SOCK     This is a UNIX domain socket.          DT_UNKNOWN  The file type could not be determined.</code></pre><p>  All  applications  must  properly  handle  a return of DT_UNKNOWN.</p><p>不是同一个文件系统下的东西可能会返回DT_UNKNOWN</p><p>简单的示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dirsShow</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirpath)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-----%s: \n&quot;</span>, dirpath);</span><br><span class="line">  DIR* proof = opendir(dirpath);</span><br><span class="line">  <span class="keyword">if</span> (proof == nullptr) &#123;</span><br><span class="line">    perror(<span class="string">&quot;DIR open error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dirent* pCur = nullptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环遍历该文件指针</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    pCur = readdir(proof);</span><br><span class="line">    <span class="keyword">if</span> (pCur == nullptr) &#123;</span><br><span class="line">      perror(<span class="string">&quot;read Dir &quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pCur-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(pCur-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pCur-&gt;d_type &amp; DT_DIR) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):%s link = %s\n&quot;</span>, __FILE__, __LINE__, __func__,</span><br><span class="line">             pCur-&gt;d_name);</span><br><span class="line">      <span class="type">char</span> bufname[MAXNAMLEN]&#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">      <span class="built_in">snprintf</span>(bufname, MAXNAMLEN, <span class="string">&quot;%s/%s&quot;</span>, dirpath, pCur-&gt;d_name);</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">      dirsShow(bufname);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (pCur != nullptr);</span><br><span class="line">  closedir(proof);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;------------: \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现一个简单的显示子目录的所有文件夹，要实现一个tree 只需要在这个基础上修改就OK了</p><p><strong>注意</strong>：该代码中藏了个简单的小问题解决（程序逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础10 | 进程控制函数补充</title>
      <link href="/2023/03/23/linux10/"/>
      <url>/2023/03/23/linux10/</url>
      
        <content type="html"><![CDATA[<h1 id="进程是操作系统调度的最小的单位"><a href="#进程是操作系统调度的最小的单位" class="headerlink" title="进程是操作系统调度的最小的单位"></a>进程是操作系统调度的最小的单位</h1><h1 id="进程的控制函数"><a href="#进程的控制函数" class="headerlink" title="进程的控制函数"></a>进程的控制函数</h1><p>进程的控制函数大概可以这样分类</p><ul><li>创建<ul><li>fork</li><li>exec系</li></ul></li><li>结束<ul><li>正常,</li><li>意外,出现意外就需要对意外进行控制处理。</li></ul></li><li>控制<ul><li>保存环境。内存， 信号量等环境处理，响应。</li></ul></li><li>信息<ul><li>比如什么getpid之类的</li></ul></li><li>结束后的处理。</li></ul><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建进程提供了很多函数</p><p>最多的常用的EXEC 系列函数</p><p>不过EXEC 并不是真正的创建一个进程，exec会将 系统给当前进程分配的内存空间内存（用户区，比如什么.data段啦，.bss段啦之类的。替代码区等待），进行一个重新赋值替换，然而PCB 进程控制块区域不变（在系统内核区部分）</p><p>换核不换壳，该进程的pid ppid都不变</p><p>真正创建进程的这是fork函数。</p><h2 id="EXEC系列"><a href="#EXEC系列" class="headerlink" title="EXEC系列"></a>EXEC系列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><ul><li><p>const char * pathname </p><ul><li>执行文件的路径，不过只可以输入绝对路径。</li></ul></li><li>const char *arg<ul><li>第一个参数 默认填写程序自身。 第二个参数如果没有填NULL，因为默认NULL 结束</li></ul></li></ul><h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><ul><li>const char* file<ul><li>执行文件的路径，可以绝对也可以相对，相对位置为当前程序所在位置. 函数名上的p也可以体现</li></ul></li><li>const char*arg<ul><li>同上没有变化，命名l的原因，va_list 的L</li><li>执行参数 ，如果没有则为NULL；</li></ul></li></ul><h3 id="execle"><a href="#execle" class="headerlink" title="execle"></a>execle</h3><ul><li>const char * pathname <ul><li>执行文件的绝对路径</li></ul></li><li>const char* arg<ul><li>同上，以（char *）null结束</li></ul></li><li>char * const envp[]<ul><li>环境变量（输入参数），可以自行设定执行文件程序的所携带的环境变量。</li></ul></li></ul><h3 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h3><ul><li>const char * pathname <ul><li>执行文件的路径，不过只可以输入绝对路径。</li></ul></li><li>char const *argv[]<ul><li>输入参数，类型是一个argv数组的地址</li><li>参数的数组形式，第一个值也必须是自身。数组最后一个值也必须是NULL!</li></ul></li></ul><h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><ul><li>const char* file<ul><li>执行文件的路径，可以绝对也可以相对，相对位置为当前程序所在位置. 函数名上的p也可以体现</li></ul></li><li>char const *argv[]<ul><li>输入参数，类型是一个argv数组的地址</li><li>参数的数组形式，数组最后一个值也必须是NULL!</li></ul></li></ul><h3 id="execve-内核级别"><a href="#execve-内核级别" class="headerlink" title="execve(内核级别)"></a>execve(内核级别)</h3><ul><li>const char * filename <ul><li>执行文件的绝对路径,不同的是也可以相对</li></ul></li><li>char const *argv[]<ul><li>输入参数，类型是一个argv数组的地址</li><li>参数的数组形式，数组最后一个值也必须是NULL!</li></ul></li><li>char * const envp[]<ul><li>环境变量（输入参数），可以自行设定执行文件程序的所携带的环境变量。</li></ul></li></ul><p>当然还有个execvpe</p><h2 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h2><p>一个简单的函数使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> sonpid, fatherpid;</span><br><span class="line">  <span class="type">int</span> <span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">  fatherpid = getpid();</span><br><span class="line">  sonpid = fork();</span><br><span class="line">  <span class="keyword">if</span> (sonpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sonpid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is son %d !is ppid  %d!\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;is parent %d, is ppid  %d!\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    <span class="keyword">if</span> (sonpid == wait(&amp;<span class="built_in">log</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;log : %d\n&quot;</span>, <span class="built_in">log</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以从代码中得出几个信息</p><ul><li>进程与子进程，变量并不共通。</li><li>进程的子进程结束后需要收尸，否则会产生僵尸进程，因为死了但是没管他，父进程一直在自己运行。</li><li>当子进程出现异常，信号使他关闭后，父进程正常wait,得到的log值是信号编号。比如说kill -9 子进程 返回log的值为9</li></ul><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>正常退出与异常退出，大部分几乎程序的退出结束，在Linux中是不同的各种信号所影响的。</p><h2 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h2><h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>手动报错，cored umped错误,将CPU 的寄存器的值dump，发送SIGABRT signal使进程结束。</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">(scalar expression)</span>;</span><br></pre></td></tr></table></figure><p>需要调用头文件assert.h </p><blockquote><p>If expression is false (i.e., compares equal to zero), assert() prints an  error message  to  standard error and terminates the program by calling abort(3).  The error message includes the name of the file and function containing the assert() call,  the  source  code  line number of the call, and the text of the argument;</p></blockquote><p>手动断言，当scalar expression 中为 0 时， 将输入在stderror中一个断言执行的文件与代码语句所处位置。</p><h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p><strong>进程结束后调用</strong>，需要填写一个带void 参数的函数指针，调用该函数。</p><h3 id="on-exit"><a href="#on-exit" class="headerlink" title="on_exit"></a>on_exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">on_exit</span><span class="params">(<span class="type">void</span> (*function)(<span class="type">int</span> , <span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p><strong>子进程结束后调用</strong>，填写一个带int参数和void 参数的函数指针 ，调用该函数</p><h3 id="exit"><a href="#exit" class="headerlink" title="_exit"></a>_exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><pre><code>   _exit() terminates the calling process &quot;immediately&quot;.  Any open file descriptors   belonging to the process are closed.  Any children of the process are  inherited   by  init(1) (or by the nearest &quot;subreaper&quot; process as defined through the use of   the prctl(2) PR_SET_CHILD_SUBREAPER operation).  The process&#39;s parent is sent  a   SIGCHLD signal.   The  value status &amp; 0xFF is returned to the parent process as the process&#39;s exit   status, and can be collected by the parent using one of the  wait(2)  family  of   calls.   The function _Exit() is equivalent to _exit().</code></pre></blockquote><p>进程和描述符<strong>立刻</strong>关闭。并且发送一个SIGCHLD 信号关闭所有自己的子进程，然后向自己的爷爷进程告知自己的状态，这个状态 就是 status.的值&amp;0XFF（限制字节大小范围），无论子进程结束后还是自己结束后有什么on_exit 或者，atexit 通通无效，主打的就是一个immediately</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常，说白了也是信号导致的，不过异常的行为是人，也就是设计者的主观认为，是预期之外的错误。</p><p>出现异常关闭可以使用wait/waitpid收集到关闭的状态,加以分析。当然这并不是什么好办法。</p><p>c还提供了如下函数来对意外进行一个容错。</p><h3 id="setjmp"><a href="#setjmp" class="headerlink" title="setjmp"></a>setjmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作用是保存当前堆栈环境，当程序出现异常错误时，想要恢复（比如说服务器程序,通常利用该函数进行异常处理， 避免在其他函数出现崩溃后，直接就寄了，实现了一个异常捕获。</p><p>实际上C 语言中，这就是一个处理异常的方式 类似c++ 的 try catch error,</p><blockquote><pre><code>   The setjmp() function saves various information about the calling envi‐   ronment (typically, the stack pointer, the instruction pointer,  possi‐   bly  the  values  of other registers and the signal mask) in the buffer   env for later use by longjmp().  In this case, setjmp() returns 0.   The longjmp() function uses the information saved in  env  to  transfer   control  back  to  the  point  where setjmp() was called and to restore   (&quot;rewind&quot;) the stack to its state at the time of the setjmp() call.  In   addition,  and  depending on the implementation (see NOTES), the values   of some other registers and the process signal mask may be restored  to   their state at the time of the setjmp() call.</code></pre></blockquote><p>the values of some other registers and the process signal mask may be restored  to their state at the time of the setjmp() call.</p><p>需要时刻注意的是，恢复之后，正常执行的运算保存在寄存器中的值，和信号遮罩可能会重置回到第一次执行setjmp的状态。</p><p>简单代码示例：一个简单的异常捕获的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">  longjmp(jmpBuf, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">  longjmp(jmpBuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">  test02();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_deal</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (sig == SIGSEGV) &#123;</span><br><span class="line">    longjmp(jmpBuf, SIGSEGV);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">sighandler_t</span> hsig = signal_deal;</span><br><span class="line">  <span class="comment">// 注册一个段错误信号回调函数。</span></span><br><span class="line">  signal(SIGSEGV, hsig);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> jmpret = setjmp(jmpBuf);</span><br><span class="line">  <span class="keyword">if</span> (jmpret == <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="comment">// 手动段错误。</span></span><br><span class="line">    *(<span class="type">int</span>*)(<span class="literal">NULL</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jmpret == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理异常 test02\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jmpret == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理异常 test03\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jmpret == SIGSEGV) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;处理异常 段错误信号\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;主函数正常运行\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigjmpset"><a href="#sigjmpset" class="headerlink" title="sigjmpset"></a>sigjmpset</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">longjmp</span><span class="params">(jmp_buf env, <span class="type">int</span> val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure><p>作用呢同setjmp，但是呢，保存的值保存的状态更全,不仅仅是寄存器，可以是上下文：堆栈，寄存器，状态新城进程，栈每次地址。</p><blockquote><pre><code>sigsetjmp()  and  siglongjmp() also perform nonlocal gotos, but provide predictable handling of the process signal mask. If, and only if, the savesigs argument provided to sigsetjmp() is  non‐       zero, the process&#39;s current signal mask is saved in env and will be re‐       stored if a siglongjmp() is later performed with this env.</code></pre></blockquote><p>根据文档，可见，sigsetjmp不进可以实现非本地的进程跳转，（线程，进程之间也可以跳转,改变进程之间顺序）， 而且提供 可预测的，要调用（跳转的）进程信号遮罩 mask 信号屏蔽量。</p><p>常在逆向中使用。嘿嘿嘿嘿。</p><h3 id="信号捕获衍生"><a href="#信号捕获衍生" class="headerlink" title="信号捕获衍生"></a>信号捕获衍生</h3><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>int signum </p><ul><li>信号码</li></ul></li><li><p>const struct sigaction *act </p><ul><li><p>存放信号行为信息的结构体</p><ul><li>```c<pre><code>struct sigaction &#123;     void     (*sa_handler)(int);     void     (*sa_sigaction)(int, siginfo_t *, void *);     sigset_t   sa_mask;     int        sa_flags;     void     (*sa_restorer)(void); &#125;;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 第一个 表示行为的调用规则</span><br><span class="line"></span><br><span class="line">      常见的有 SIG_DFL 默认行为，SIG_IGN ：不理睬捕获这个信号。</span><br><span class="line"></span><br><span class="line">    - 第二个 这个信号的的回调函数的 函数指针。</span><br><span class="line"></span><br><span class="line">    - 当前信号遮罩，用于信号集的过滤等。。</span><br><span class="line"></span><br><span class="line">    - sa_flags 行为标志，根据不同的信号不同的回收之类的操作。</span><br><span class="line"></span><br><span class="line">    - The sa_restorer field is not intended for application use.  (POSIX does</span><br><span class="line">        not  specify a sa_restorer field.)  Some further details of the purpose</span><br><span class="line">        of this field can be found in sigreturn(2).</span><br><span class="line"></span><br><span class="line"># 信息</span><br><span class="line"></span><br><span class="line">### 进程信息常用的获取函数</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  #include &lt;sys/types.h&gt;</span><br><span class="line">   #include &lt;unistd.h&gt;</span><br><span class="line">  </span><br><span class="line">   pid_t getpid(void);</span><br><span class="line">   pid_t getppid(void);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>得到进程的pid 和得到进程的ppid 也就是parent pid 父进程的pid </p><ul><li>```c<br>pid_t getpgrp(void);                 /<em> POSIX.1 version </em>/<br>pid_t getpgrp(pid_t pid);            /<em> BSD version </em>/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不同系统内核下不同版本，得到当前的进程组id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">既然有get,那当然就有set.</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int setpgrp(void);                   /* System V version */</span><br><span class="line">  int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */</span><br></pre></td></tr></table></figure></li></ul><blockquote><pre><code>All  of  these  interfaces  are available on Linux, and are used for getting andsetting the process group ID (PGID) of a process.  The preferred, POSIX.1-speci‐fied ways of doing this are: getpgrp(void), for retrieving the calling process&#39;sPGID; and setpgid(), for setting a process&#39;s PGID.setpgid() sets the PGID of the process specified by pid  to  pgid.   If  pid  iszero, then the process ID of the calling process is used.  If pgid is zero, thenthe PGID of the process specified by pid is made the same as its process ID.  Ifsetpgid()  is  used  to  move a process from one process group to another (as isdone by some shells when creating pipelines), both process groups must  be  partof  the same session (see setsid(2) and credentials(7)).  In this case, the pgidspecifies an existing process group to be joined and  the  session  ID  of  thatgroup must match the session ID of the joining process.  The  System V-style  setpgrp(), which takes no arguments, is equivalent   to setpgid(0, 0).   The BSD-specific setpgrp() call, which takes arguments pid and pgid, is   a wrapper function that calls       setpgid(pid, pgid)   Since  glibc 2.19, the BSD-specific setpgrp() function is no longer ex‐   posed by &lt;unistd.h&gt;; calls should be replaced with the  setpgid()  call   shown above.</code></pre></blockquote><p>​    被取代为setpgid()咯。</p><p>而setpgid调用后，就会将该进程脱离父进程的组，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setpgid(pid, pid);<span class="comment">//让子进程脱离父进程</span></span><br></pre></td></tr></table></figure><p>将进程的组ID 设计为自己的ID 作为自己的组ID ，实际上。</p><h3 id="得到进程的执行优先级"><a href="#得到进程的执行优先级" class="headerlink" title="得到进程的执行优先级"></a>得到进程的执行优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> prio)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>   The  scheduling priority of the process, process group, or user, as in‐<br>   dicated by which and who is obtained with the  getpriority()  call  and<br>   set  with  the setpriority() call.  The process attribute dealt with by<br>   these system calls is the same attribute  (also  known  as  the  “nice”<br>   value) that is dealt with by nice(2).</p><p>   The  value  which  is one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER, and<br>   who  is  interpreted  relative  to  which  (a  process  identifier  for<br>   PRIO_PROCESS, process group identifier for PRIO_PGRP, and a user ID for<br>   PRIO_USER).  A zero value for who denotes  (respectively)  the  calling<br>   process,  the process group of the calling process, or the real user ID<br>   of the calling process.</p></blockquote><ul><li>int which<ul><li>三种不同宏，</li><li>PRIO_PROCESS 得到进程的优先级</li><li>PRIO_PGRP 得到进程组的优先级</li><li>PRIO_USER 得到用户的优先级</li></ul></li><li>id_t who <ul><li>当然是id了，</li></ul></li><li>set 进程组的优先级</li></ul><blockquote><p> The prio argument is a value in the range -20 to 19 (but see NOTES  be‐<br>     low).  with -20 being the highest priority and 19 being the lowest pri‐<br>     ority.  Attempts to set a priority  outside  this  range  are  silently<br>     clamped  to  the range.  The default priority is 0; lower values give a<br>     process a higher scheduling priority.</p></blockquote><p>prio通常的优先级范围从 -20 ~19 。数字越小进程优先越高。</p><p>我们常见的sleep函数呢，为了保证能够挂起指定的时间通常会将进程的优先级设为最高后设定挂起时间。 </p><p>当我们进行一个进程的调试时，发现，进程的父进程就是gdb ,而gdb进程的子进程就是该被调试的进程。</p><p>可以得知：调试也是一个进程。</p><p><strong>在修改优先级的时候，降级没问题， 而提升则是需要检查有效用户的权限。</strong></p><h1 id="结束后的处理"><a href="#结束后的处理" class="headerlink" title="结束后的处理"></a>结束后的处理</h1><p>子进程结束后的处理。一般进程结束，比如，收尸啥的。</p><p>以下是常用得函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waitid</span><span class="params">(<span class="type">idtype_t</span> idtype, <span class="type">id_t</span> id, <span class="type">siginfo_t</span> *infop, <span class="type">int</span> options)</span>;</span><br><span class="line">                <span class="comment">/* This is the glibc and POSIX interface; see</span></span><br><span class="line"><span class="comment">                   NOTES for information on the raw system call. */</span></span><br></pre></td></tr></table></figure><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>等待子进程中断或结束。防止出现僵尸进程。zone</p><p>不过这种wait只能wait一个子进程pid,无法wait多个进程，不可控的。</p><p>并且还不能设定wait的处理模式，只能阻塞等待</p><h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><p>waitpid的三个参数</p><ul><li>pid_t pid<ul><li>需要监听的pid，不同的pid值有不同的意义</li><li>返回小于-1  的值 表示 等待的所有子进程的进程组ID  比如-12323 等待组ID 为12323的 所有子进程</li><li>等于 -1 表示 等待所有子进程</li><li>0 表示等待任意调用进程组ID相同的组内的子进程。</li></ul></li><li>int *wstatus<ul><li>传出的wait statu 状态，提供了几个宏来判断状态类型。</li><li>​       WIFEXITED(wstatus) 返回 是否 普通的结束 </li><li>​       WEXITSTATUS(wstatus) 返会子进程的退出的状态码</li><li>​       WIFSIGNALED(wstatus) 返回进程 是否 是由于信号导致的结束</li><li>​       WTERMSIG(wstatus) 返回信号导致的结束的信号</li><li>​      WCOREDUMP(wstatus) 返回 是否 是CORE DUMP 而结束进程</li><li>​       WIFSTOPPED(wstatus) 返回是否是比一个a信号传递的导致的结束 与WUNTRACED 配合操作</li><li>​       WSTOPSIG(wstatus)   返回信号，造成子进程信号值，搭配WIFSOPPED 使用<ul><li>returns  the  number  of the signal which caused the child to stop.  This<pre><code>macro should be employed only if WIFSTOPPED returned true.</code></pre></li></ul></li><li>​       WIFCONTINUED(wstatus) 返回是否是因为SIGCONT. 信号导致进程挂起。 也常常与与WCONTINUED 配合操作</li></ul></li><li>int options<ul><li>wait操作<ul><li>WNOHANG 非阻塞<ul><li>return immediately if no child has exited.</li></ul></li><li>WUNTEACED 被调试 <ul><li>also return if a child has stopped (but not traced via ptrace(2)).   Status  for  traced children which have stopped is provided even if this option is not specified.</li></ul></li><li>WCONTINUED 发生了信号导致进程暂停后，<ul><li>also return if a stopped child has been resumed by delivery of SIGCONT</li></ul></li></ul></li></ul></li><li>return int <ul><li>如果回收成功一个进程后返回 该进程id</li><li>if  WNOHANG  was specified and one or more child(ren) specified by pid<pre><code>exist, but have not yet changed state, then 0 is returned</code></pre></li><li>当waitpid 为非阻塞回收时， 检测到还没有结束的子进程，返回0 表示没有回收，等待回收。</li><li>失败返回-1 并输出error；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础09 | 权限控制函数</title>
      <link href="/2023/03/20/linux09/"/>
      <url>/2023/03/20/linux09/</url>
      
        <content type="html"><![CDATA[<h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><p>都说Linux之下皆文件。</p><p>linux 在访问文件时，根据不同的用户，组，文件所有者的来设定访问权限，保护文件安全</p><p>文件类型权限</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220729170339169.png" alt="image-20220729170339169"></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220729170409280.png" alt="image-20220729170409280"></p><p>分析</p><ul><li><p>第0组</p><ul><li>d  类型（文件夹</li></ul></li><li><p>第一组 表示该文件的所有组权限</p><ul><li><p>r read （代表值为4</p></li><li><p>w write  （2</p></li><li><p>x 执行权限 （1</p></li><li>S 提权和降权</li><li>s 修改我当前的组</li><li>t 仅所有者可删除权限</li></ul></li><li><p>第二组 同组用户的权限</p></li><li><p>第三组 其他人，公共权限</p></li><li><p>而数字为，硬链接数</p></li></ul><p>在linux中常常使用chmod 修改文件的权限</p><h2 id="获取用户"><a href="#获取用户" class="headerlink" title="获取用户"></a>获取用户</h2><p>在执行权限相关函数的第一步，</p><p>当然是需要知道当前有效的用户权限</p><p>有效用户识别码/有效组别</p><p>uid_t geteuid(void);</p><p>uid_t getgid(void);</p><p>真实用户识别码，/有效组别</p><p>uid_t getuid(void);</p><p>uid_t getgid(void);</p><p><strong>有效用户表示的是这个进程启动时，是哪个用户启动的。</strong></p><p><strong>真实用户实际上就是这个进程实际上当下拥有的用户权限。</strong></p><p>实际上我们尝尝用真实用户使用权限控制，而有效用户一般只是用来检测是否是，作为判断依据。</p><ul><li>返回值为 0 表示 ROOT 是最高！</li><li>1000~10000（不包含10000）系统级别，</li><li>10000 以上 其他的比如网络上的用户</li><li>安卓的比较严格，每个应用都会分配一个用户</li></ul><p>测试发现捏：<strong>只有ROOT 的用户文件执行的进程</strong>才有更改和提权的函数的能力。其他用户，即使用chmod 7777拉满 （就算是sudo） 修改文件权限，进程运行时<strong>也没有办法修改</strong>进程的用户权限（就是使用set类的权限函数全部返回-1）。</p><p>测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 512</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">err_exit</span><span class="params">(<span class="type">char</span>* fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sysconf</span>(_SC_SAVED_IDS) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;_POSIX_SAVED_IDS effective!\n&quot;</span>);</span><br><span class="line">  <span class="type">uid_t</span> u = <span class="built_in">getuid</span>();</span><br><span class="line">  <span class="type">uid_t</span> eu = <span class="built_in">geteuid</span>();</span><br><span class="line">  <span class="type">uid_t</span> g = <span class="built_in">getgid</span>();</span><br><span class="line">  <span class="type">uid_t</span> eg = <span class="built_in">getegid</span>();</span><br><span class="line">  std::cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; eu &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; eg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> ret2 = <span class="built_in">setgid</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret2);</span><br><span class="line"></span><br><span class="line">  u = <span class="built_in">getuid</span>();</span><br><span class="line">  eu = <span class="built_in">geteuid</span>();</span><br><span class="line">  g = <span class="built_in">getgid</span>();</span><br><span class="line">  eg = <span class="built_in">getegid</span>();</span><br><span class="line">  std::cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; eu &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; eg &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结，涉及提权的函数 的程序 ，都用root权限，要么将程序所有转到root用户下（sudo chown root）, 要么用root权限执行。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础01|格式化的输入输出</title>
      <link href="/2023/03/18/linux01/"/>
      <url>/2023/03/18/linux01/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h1><p>printf 大伙太熟了这里就不细讲，给个表格自行查阅吧</p><div class="table-container"><table><thead><tr><th style="text-align:left">符号</th><th>输出</th></tr></thead><tbody><tr><td style="text-align:left">%d</td><td>int 十进制</td></tr><tr><td style="text-align:left">%u</td><td>unsinged 十进制</td></tr><tr><td style="text-align:left">%l</td><td>long</td></tr><tr><td style="text-align:left">%lld</td><td>long long</td></tr><tr><td style="text-align:left">%f</td><td>float</td></tr><tr><td style="text-align:left">%e</td><td>double 以指数形式</td></tr><tr><td style="text-align:left">%s</td><td>char*</td></tr><tr><td style="text-align:left">%g</td><td>较短的输出小数。</td></tr><tr><td style="text-align:left">p</td><td>指针</td></tr><tr><td style="text-align:left">x</td><td>十六进制</td></tr><tr><td style="text-align:left">o</td><td>八进制</td></tr></tbody></table></div><h3 id="str-print-format"><a href="#str-print-format" class="headerlink" title="str print format"></a>str print format</h3><p>sprintf()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>这玩意好用指出在于将数据整和,拼接到特定变量中， 或文件中(fprintf/fdprintf)。</p><p>为了安全起见防止数据溢出，建议使用snprintf() ，除非你很有把握</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="comment">//给定了size 放置溢出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>by the way :</p><p>今天发现了一个坑，发现在赋值的时候当需要赋值超出类型限制的值时，需要进行强制转化，否则就会报错。编译器为了内存安全死活不让你通过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">int</span> a&#123;<span class="number">0xFFFFFFFF</span>&#125;;<span class="comment">//error</span></span><br><span class="line">  <span class="type">int</span> b&#123;(<span class="type">int</span>)<span class="number">4294967295</span>&#125;;</span><br><span class="line"><span class="comment">// error: narrowing conversion of ‘4294967295’ from ‘unsigned int’ to ‘int’ [-Wnarrowing]</span></span><br></pre></td></tr></table></figure><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p>需要头文件      </p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdarg.h></h1><p>简单的使用凡事</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(ap, format);</span><br><span class="line">  <span class="built_in">vprintf</span>(format, ap);</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">4096</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="built_in">vsnprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer), format, ap);</span><br><span class="line">  <span class="built_in">perror</span>(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vsprintf</span>(buffer, format, ap); <span class="comment">//出现段错误</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>va_start 宏用来处理后续参数，出现段错误的原因也在这：</p><p>段错误：一半是对内存进行了非法的访问产生。了解这一点我们思路就可以逐渐打开了。</p><p>va_list 表示的是参数列表， 而format 这是第一个参数的值</p><p>va_start 的作用就是根据format 作为 锚点，通过指针偏移，取出后续参数。本质上，是拿着第一个参数的压栈的地址,偏移。va_start(ap,v)；执行ap = (va_list)&amp;v + _INTSIZEOF(v)。</p><p>ap+= sizeof(t类型)，让ap指向下一个参数的地址。然后返回ap-sizeof(t类型)的t类型指针，这正是第一个可变参数在堆栈里的地址。</p><p>vprintf()执行一次就会调用ap偏移指针，取出参数。</p><p>可以发现va_list 中记录了四个参数</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20230323122359209.png" alt="image-20230323122359209"></p><p>每执行依次vprintf 参数都会发生改变，也就是偏移，偏着偏着就偏过头了。。</p><p>解决就是再调用之前初始化ap   va_start(ap, format);</p><h2 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h2><p>老生常谈scanf</p><p>不过需要注意其中还有一些默认的隐藏的东西行为</p><ul><li><p>空格是默认的分隔符,当然输入的时候遇到“%d,%s,%f”时，输入的时候就必须使用逗号分隔！</p></li><li><p>不部分数据格式是可以自动正确分隔的。</p></li><li><p>比如说%c%d,反过来%d%c,也没问题…吗？测试一下</p></li><li><pre><code class="lang-c">int ret = scanf(&quot;%d%c&quot;, &amp;a, &amp;c);printf(&quot;ret = %d  %d %c\n&quot;, ret, a, c);if (isblank(c))  std::cout &lt;&lt; &quot;yes!blank\n&quot;;if (iscntrl(c))  std::cout &lt;&lt; &quot;yes!cntrl (int)c = &quot; &lt;&lt; (int)c &lt;&lt; char(10);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果嘛，就是将最后的确认 作为转义字符\n 传入c中了</span><br><span class="line"></span><br></pre></td></tr></table></figure>1324ret = 2  1324 yes!cntrl (int)c = 10</code></pre></li></ul><p>格式化输入也有跟格式化输出相对应的几个函数</p><p>比如</p><p>格式化字符串输入</p><p>sscanf()；</p><p>格式化字符串赋值</p><p>vsscanf()</p><p>vsnscanf()</p><p>格式化文件输入</p><p>vfscanf()</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础03 | 字符处理</title>
      <link href="/2023/03/10/linux03/"/>
      <url>/2023/03/10/linux03/</url>
      
        <content type="html"><![CDATA[<h1 id="linux字符"><a href="#linux字符" class="headerlink" title="linux字符"></a>linux字符</h1><p>在linux中，字符处理 也提供C 库里的函数 。</p><p>首先当然是导入ctype.h头文件</p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>常见的，</p><p>以下单纯给出了几个函数使用的代码示例，这里不再做过多介绍。</p><p>可以直接查找man文档进行查看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::string str = &#123;<span class="string">&quot;hello world \r\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> length&#123;str.<span class="built_in">length</span>()&#125;;</span><br><span class="line"><span class="keyword">while</span> (i != length) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalnum</span>(str[i]))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A - &quot;</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isalpha</span>(str[i]))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a - &quot;</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isblank</span>(str[i]))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;blank - &quot;</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">iscntrl</span>(str[i]))</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C - &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>在涉及转换方面，库函数就有很多门道</p><p>同样也是可以在man文档中进行查找</p><p>这里简单列出几种常用的，需要注意的。</p><p>str转换为数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">atoi</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">long</span> l = <span class="built_in">atol</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ll = <span class="built_in">atoll</span>(<span class="string">&quot;12312312&quot;</span>);</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">atof</span>(<span class="string">&quot;1.1234&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)&lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><ul><li>历史遗留函数 atol (在8位 ，或者16位 的系统中发挥作用) ,而在linux64 g++下 ， long long  与 long 同样占用8个字节</li><li>atof有歧义，实际上返回的是double类型</li></ul><p>以下衔接上段代码段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pEnd;</span><br><span class="line"><span class="type">double</span> d = <span class="built_in">strtod</span>(<span class="string">&quot;1.23456789&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="type">double</span> d2 = <span class="built_in">strtod</span>(<span class="string">&quot;-1.234567891abc&quot;</span>, &amp;pEnd);</span><br><span class="line">std::cout &lt;&lt; pEnd &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; f &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; d &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; d2 &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, d2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 输出可以发现 ，cout 对double 的支持不是很好，用printf，就可以多一位有效位（强一点但是不多XD</p><p>并且这样输出double ，完全达不到要求，</p><p>所以提供了ecvt 和 fcvt ,gcvt</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> decpt, sign;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">ecvt</span>(<span class="number">-0.123456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">ecvt</span>(d, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">ecvt</span>(d2, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;__________________________\n&quot;</span>;</span><br><span class="line"><span class="comment">// 另外一个fcvt</span></span><br><span class="line"><span class="comment">// 其中 与ecvt的ndigit的意义不同</span></span><br><span class="line"><span class="comment">// ，ecvt表示的是所有的有效数字，而fcvt表示小数点后的有效数字</span></span><br><span class="line"><span class="comment">// 输出是会进行补0操作，根据你锁填的ndigit的值</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fcvt</span>(<span class="number">-0.123456789</span>, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fcvt</span>(d, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fcvt</span>(d2, <span class="number">10</span>, &amp;decpt, &amp;sign) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;decpt:&quot;</span> &lt;&lt; decpt &lt;&lt; <span class="string">&quot; sign:&quot;</span> &lt;&lt; sign &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;__________________________\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有一个gcvt</span></span><br><span class="line"><span class="comment">// 这个玩意直接将这些值，无论是整数，小小数 ，直接输出为str串,</span></span><br><span class="line"><span class="comment">// ，不会根据ndigit不会补0,有多少显示多少，当然超出的依旧是要根据ndigit进行四舍五入的操作。</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">gcvt</span>(<span class="number">-0.123456789</span>, <span class="number">10</span>, buffer) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; buffer &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">gcvt</span>(d, <span class="number">10</span>, buffer) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; buffer &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">gcvt</span>(d2, <span class="number">10</span>, buffer) &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; buffer &lt;&lt; <span class="built_in">char</span>(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础07 | 同步与锁</title>
      <link href="/2022/08/23/linux07/"/>
      <url>/2022/08/23/linux07/</url>
      
        <content type="html"><![CDATA[<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>啥事同步，同时起步，协调一致的，然而不同的对象，又有不同的同步概念</p><p>设备同步，两个设备之间的一个共同时间的参考，数据库同步等等</p><p>在linxu中我们需要了解线程同步</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步即协同一致，按照预订的先后次序运行</p><p>一个线程调用一个函数时，为了保证其他线程调用时的数据一致性，不能调用其他函数</p><p>这个时候我们就需要给这个调用的数据，上一个锁，对共享的区域做一个保护</p><p>所以在linux中当多个流程操作一个共享资源时都需要加锁</p><h2 id="常用锁和常用原语"><a href="#常用锁和常用原语" class="headerlink" title="常用锁和常用原语"></a>常用锁和常用原语</h2><h3 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h3><h4 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h4><p>初始化一个互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><p>注意这个关键词restrict，指名只能使用该指针，不能通过其他指针操作内存指向</p><ul><li>pthread_mutex_t *restrict mutex 可以单纯理解为锁 ，锁上是为0,解锁为1</li><li>mutex,const pthread_mutexattr_t *restrict attr  锁的属性</li></ul><p>默认初始值为1</p><p>当不需要使用特殊配置时，可以直接使用宏变量赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>来代替该函数</p><h4 id="pthread-mutex-destory"><a href="#pthread-mutex-destory" class="headerlink" title="pthread_mutex_destory"></a>pthread_mutex_destory</h4><p>删除一个互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>一般在结束时，不再使用该锁时，进行调用删除</p><h4 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h4><p>顾名思义，上锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>可以简单理解为对锁进行减1操作</p><h4 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h4><p>顾名思义，释放锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>可以简单理解为对锁进行++操作</p><p>配合lock使用，</p><p>在不同的线程中需要访问同一个共享内存，都需要执行上锁和解锁的操作</p><p>使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">printHello</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world!\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//当调用成功mutex值为1</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, printHello, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error : %s&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD!\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);<span class="comment">//检查点在sleep具体是哪一个是随机的</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：锁的粒度应该是越小越好，访问共享操作后立即解锁</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是一种现象，而不是一种新的锁机制。</p><p>产生的原因</p><ul><li><p>没有解锁（unlock，对同一个共享内存加锁（会出现lock两次的情况</p><ul><li>可以理解为，一个唯一会开锁的小偷把自己锁在了保险库，其他同伙想进去，等待笨比解锁，而笨比被自己锁在里头了，自己又忘记了解锁密码。偷钱活动就此失败。想要打开保险库，必须触发保险库中的机关，这个机关会把保险库的小偷给杀死。</li></ul></li><li><p>两个锁造成的死锁</p><ul><li><p>有两个共享数据，线程一需要同时拿到两把锁才能访问两个共享数据，<br>假设</p><p>线程2只拿到锁1,当锁2拿到后才能释放锁1</p><p>线程1只拿到锁2,当锁1拿到后才能释放锁2</p><p>流沙河，你下来，你上来，你过来我就下去，你下来我就上去。</p></li></ul></li></ul><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); </span><br><span class="line">        b += <span class="number">100</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i m thread, a = %d , b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定一个死锁现象</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">        b += <span class="number">100</span>;  </span><br><span class="line">        pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i m main, a = %d , b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125; </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h4><ul><li>第一种死锁<ul><li>可以直接避免，只要你写的细心一点</li></ul></li><li>第二种<ul><li>调用trylock，线程一方拿不到锁时，主动释放锁</li></ul></li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>写独占，读共享。写锁的优先级更高</strong></p><p>对一个共享数据进行操作的锁，常用在读次数大于写的情况。</p><p>当线程1读操作时，其他线程也可以对其进行读操作，这是共享模式锁</p><p>当线程执行写操作上了写操作时，其他线程都无法对其进行任何操作，这是独占模式锁</p><h4 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h4><p>初始化读写锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h4><p>删除锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h4><p>设定一个读锁</p><h4 id="pthread-rwlock-wdlock"><a href="#pthread-rwlock-wdlock" class="headerlink" title="pthread_rwlock_wdlock"></a>pthread_rwlock_wdlock</h4><p>设定一个写锁</p><h4 id="pthread-rwlock-trywrlock"><a href="#pthread-rwlock-trywrlock" class="headerlink" title="pthread_rwlock_trywrlock"></a>pthread_rwlock_trywrlock</h4><p>尝试写锁，非阻塞的写法</p><h4 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a>pthread_rwlock_unlock</h4><p>解锁</p><p>其实读写锁的核心就14个字：</p><p>读时占用，写时共享，写锁优先级高</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> olda;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   olda = a;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;====write :%d olda = %d, a = %d \n&quot;</span>, i, olda, ++a);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read :%d a = %d\n&quot;</span>, i, a);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./name rtnums wtnums\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count_r = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> count_w = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tidr[count_r];</span><br><span class="line">    <span class="type">pthread_t</span> tidw[count_w];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count_w; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tidw[i], <span class="literal">NULL</span>, th_write, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_r; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tidr[i], <span class="literal">NULL</span>, th_read, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tidr[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_w; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tidw[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量本身不是锁,但是一样造成线程阻塞，说白了就是在互斥锁中进行条件判断，给多线程提供一个会合的场所</p><h4 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h4><p>阻塞等待一个条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个，老套路，一个结构体</li><li>第二个就有意思了，是一个互斥锁结构体。</li></ul><p>一个看就知道这个函数不是等闲之辈</p><p>重点就是这个函数，有三个作用</p><ul><li>阻塞等待条件变量cond满足</li><li>释放已掌握的互斥锁，实际上就是unlock(&amp;mutex);<ul><li>需要注意的是上方两个作用实际上只是一个原子操作。</li></ul></li><li>当被唤醒，pthread_cond_wait 函数返回时，解除阻塞并重新组阻塞并重新申请获取互斥锁相当于 lokc(&amp;mutex);</li></ul><p>注意这个唤醒，</p><p>有两种唤醒方式</p><ul><li>pthread_cond_signal<ul><li>唤醒一个</li></ul></li><li>pthread_cond_broadcast(广播)</li></ul><h4 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h4><p>唤醒满足条件变量的上的至少一个阻塞的线程</p><h4 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a>pthread_cond_broadcast</h4><p>唤醒所有的满足的条件变量阻塞的线程</p><h4 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="pthread_cond_timedwait"></a>pthread_cond_timedwait</h4><p>设定一个默认时间自动唤醒的wait</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>相较于一般的wait，多了一个结构体参数</p><p>const struct timespec abstime</p><ul><li>绝对时间的意思</li><li>绝对时间实际上也是相对的，从1970年1月1号0000开始计时</li><li>time_t tv_sec 秒</li><li>long tv_nsec 纳秒</li></ul><p>想要定时5秒钟实际上需要使用操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> cur =time(<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">struct</span> timespec t;</span><br><span class="line">t.tv_sec = cur + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模型实现"><a href="#生产者消费者模型实现" class="headerlink" title="生产者消费者模型实现"></a>生产者消费者模型实现</h3><p>一个典型的线程同步的模型</p><p>生产者，产品，消费者</p><p>生产者进程负责生产产品</p><p>消费者进程负责消费产品</p><p>一个简单的实现代码</p><p>这里是定义了一个简单的链表节点，一个生产者每次生产一个，一个消费者也每次消费一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)<span class="comment">//这里用while是精髓</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume ----%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        mp-&gt;num = rand() %<span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Produce ----%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> sid, cid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_create(&amp;sid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(sid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h4><p>相较于mutex，能减少不必要的竞争，如果没有释放，多个进程之间还会互相竞争</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>进化版的互斥锁，虽然也是线程库函数里的东西，但是，是<strong>可以用在进程间的锁</strong></p><p>初始化的值是N值<em>（与互斥锁默认值为1不同，N值是自己可以指定任意数值(必须是正整数)，可以理解为锁的钥匙，资源量，<em>*可以同时使用这把锁的进程数</em></em>。</p><p>出现的考量，是为了多个进程or线程需要共同访问一个的共享资源的同时，保证线程或者进程的并发性。</p><h4 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_t sem</li><li>pshared 是否在进程共享</li><li>unsigned int value 设定的值</li></ul><h4 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy"></a>sem_destroy</h4><p>对应的删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait"></a>sem_wait</h4><p>加锁函数，等同于lock,一样可以理解为—操作，当值为0时，进行阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait"></a>sem_trywait</h4><p>尝试加锁，同理trylock,非阻塞式加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h4><p>解锁，等同于unlock，一样可以理解为++操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-timedwait"><a href="#sem-timedwait" class="headerlink" title="sem_timedwait"></a>sem_timedwait</h4><p>定时加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>同样是绝对时间</p><p>直接看代码示例吧</p><p>比如说实现一个线程每隔五秒打印“hello world”，用户与输入立马打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> lock;</span><br><span class="line"><span class="type">char</span> str[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">printHello</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> ;</span></span><br><span class="line">        t.tv_sec = cur + <span class="number">5</span>;</span><br><span class="line">        sem_timedwait(&amp;lock, &amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hellp world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">scanInput</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;    </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strlen</span>(str) == <span class="number">0</span>)&#123;</span><br><span class="line">           fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;lock);</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    sem_init(&amp;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, printHello, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, scanInput, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="还是典型的消费者生产者模型"><a href="#还是典型的消费者生产者模型" class="headerlink" title="还是典型的消费者生产者模型"></a>还是典型的消费者生产者模型</h3><p>上方实现的模型的一对一的进化版</p><p>一个生产者，多个产品，一个消费者，不过此时消费者在某种意义上来说也是一种生产者的角色，生产一个空，此时公共区产品使用queue（队列）表示</p><p>一个生产者，多个产品，二个消费者，生产速率和消费速率是随机的，代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CNUM 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];</span><br><span class="line"><span class="type">sem_t</span> blank_number, product_number;</span><br><span class="line"><span class="type">sem_t</span> consumer_number;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(&amp;blank_number);</span><br><span class="line">        <span class="built_in">queue</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Produce----%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number);</span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;<span class="comment">//循环赋值</span></span><br><span class="line">        sleep(rand() % <span class="number">1</span>);<span class="comment">//模拟生产产品时间，随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(&amp;product_number);</span><br><span class="line">        sem_wait(&amp;consumer_number);</span><br><span class="line">         <span class="keyword">while</span> (<span class="built_in">queue</span>[i] == <span class="number">0</span>)&#123;</span><br><span class="line">             i = (i+<span class="number">1</span>) % NUM;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer NO.%d----%d\n&quot;</span>, j, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;</span><br><span class="line">        sem_post(&amp;consumer_number);</span><br><span class="line">        sem_post(&amp;blank_number);</span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;<span class="comment">//循环遍历</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//随机数，模拟消费者对产品的消化时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> cid[CNUM], pid;</span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM);</span><br><span class="line">    sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;consumer_number, <span class="number">0</span>, CNUM);</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CNUM; i++)&#123;  </span><br><span class="line">      pthread_create(&amp;cid[i], <span class="literal">NULL</span>, consumer, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CNUM; i++)&#123;</span><br><span class="line">        pthread_join(cid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这其实只是一对多的情况，一个生产者，多个产品，多个消费者，双方的速率也都是随机的，而且没有将“拿出”和“消耗”的产品的操作单独分开，比较简陋</strong></p><p>单纯讨论线程间的同步问题，双方速率和产品 暂且不论，有两个关键变量，生产者个数，消费者个数，就有4种情况</p><ul><li><p>一生产，一消费。</p></li><li><p>多生产，一消费。</p></li><li>一生产，多消费。</li><li>多生产，多消费。</li></ul><p>思想是一样的，每有需要进行同步的线程组，就需要设定一个锁（不是绝对，根据需要</p><p>生产者与消费者之间，就需要一个锁，而消费者与消费者之间也会需要一个锁，确保每个消费者都能拿到数据</p><h3 id="进程间的互斥量"><a href="#进程间的互斥量" class="headerlink" title="进程间的互斥量"></a>进程间的互斥量</h3><p>如果想要将这些线程库中的锁给进程使用呢？</p><p>这个时候就需要在进行锁的定义时对锁的属性进行修改</p><h4 id="进程的锁"><a href="#进程的锁" class="headerlink" title="进程的锁"></a>进程的锁</h4><p>定义一个锁属性的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mutexattr;</span><br></pre></td></tr></table></figure><p>需要对这个属性在进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_init(&amp;mutexattr);</span><br></pre></td></tr></table></figure><p>调用设置属性函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_setpshared(&amp;mutexattr， <span class="type">int</span> pshared);</span><br></pre></td></tr></table></figure><p>注意第二个参数的取值</p><ul><li>PTHREAD_PROCESS_SHARED(公开给进程使用的锁)</li><li>PTHREAD__PROCESS_PRIVATE(线程私有的锁)；</li></ul><p>当不需要使用该属性结构体时同样需要调用destroy函数对属性进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_destroy(&amp;mutexattr);</span><br></pre></td></tr></table></figure><h4 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h4><p>基于fcntl实现，说实话我都忘了咋怎么用了，隐约记得一般用来修改文件的属性。</p><p>锁的设置，区别不大其实，只不过换了个函数实现而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>需要用到的宏参，第二个参数</p><ul><li>F_SETLK 设置文件锁（trylock）</li><li>F_SETLKW 设置文件锁 （lokc) W wait</li><li>F_GETLK 获取当前文件锁 </li></ul><p>要设置的锁的结构体，同时也是第三个参数</p><p>struct flock（这里列用到的数据）</p><ul><li>…..</li><li>short l_type;<ul><li>锁的类型</li><li>F_RDLCK（读锁）</li><li>F_WRLCK（写锁）</li><li>F_UNLCK（无文件锁）</li></ul></li><li>short l_whence<ul><li>文件的指针的起始位置<ul><li>SEEK_SET</li><li>SEEK_END</li><li>SEEK_CUR</li></ul></li></ul></li><li>off_t l_start<ul><li>从哪开始出现锁的位置，相对于起始位置的偏移量</li></ul></li><li>off_t l_len<ul><li>要锁的字节量</li><li>特殊值0 ，所有的</li></ul></li><li>pid_t l_pid<ul><li>当使用F_GETlK时才会获取到该锁的进程id</li></ul></li></ul><p>使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;filelock r/w\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;文件锁文件.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_whence = SEEK_SET;</span><br><span class="line">    lock.l_start = <span class="number">0</span>;</span><br><span class="line">    lock.l_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        lock.l_type = F_RDLCK;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lock.l_type = F_WRLCK;</span><br><span class="line">    &#125;</span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get flokc\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);<span class="comment">//这个10s假设我在进行写操作 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unlock!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开了两个终端测试发现，文件锁的规则其实就是，写时独占，读时共享</p><p><strong>注意这是，进程间独占的锁机制</strong></p><p>在线程中实际上使用的读写锁</p><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><p>五个哲学家在一个餐桌上吃饭，每个人只有一根筷子，想要吃上中间的菜，一个人需要完整的一双筷子（</p><p>一个人想要吃菜，就拿下一个人的筷子（咦惹</p><p>1—-2</p><p>2—-3</p><p>3—-4</p><p>4—-5</p><p>5—-1</p><p>这个时候如果5个人同时想吃菜，五个人都拿了下一个人的筷子，自己的筷子同时也被前一个人拿走了，这个时候就出现一个一比较尴尬的状态。如果此时谁也不肯放那么就没有人能够吃菜。</p><p>代码模拟一下这个问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 5</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">       pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[COUNT];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_init(&amp;mutex[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, diner, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说我运气有点好。运行了好5秒都没出现死锁现象，还以为写错了，好在第二次进行运行时死锁了。</p><p>死锁了咋整呢？</p><p>有三种解决方案</p><ul><li>有个人主动放弃拿自己的筷子，先去拿别人的筷子，这样就能保证自己的筷子能被下一个人拿到凑成两个。</li><li>再定义一个互斥量，用来锁住其他人拿到筷子，保证有一个人拿到一双</li><li>嘶，想了想好像不知三种解决方案啊。比如什么不同的序号不同取筷子的顺序，或者定义一个为n-1的信号量，有一个人必须等待其他n个人执行拿筷子动作后都成功后才能拿筷子。等等。</li></ul><p>归根结底，只要保证有一个人肯定能够拿到一双筷子就可以实现永动。</p><p>对了忘了这里再补个进程版的哲学家问题。</p><p>这里使用信号量作为锁</p><p>当然也可以用mutex</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">nt <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">sem_t</span> *lock= mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sem_t</span>)* count, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_init(&amp;lock[i], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">           left = i;</span><br><span class="line">           right = <span class="number">0</span>;     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          left = i;</span><br><span class="line">          right = i + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;    </span><br><span class="line">            sem_wait(&amp;lock[left]);</span><br><span class="line">            sem_wait(&amp;lock[right]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 进餐\n&quot;</span>, i);</span><br><span class="line">            sem_post(&amp;lock[left]);</span><br><span class="line">            sem_post(&amp;lock[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG); </span><br><span class="line">            <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(wpid != <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_destroy(&amp;lock[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap(lock,<span class="keyword">sizeof</span>(<span class="type">sem_t</span>)*count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的事进程需要用到锁时</p><p>注意初始化的锁的属性，是否分享给进程使用。</p><h4 id="解决方案代码"><a href="#解决方案代码" class="headerlink" title="解决方案代码"></a>解决方案代码</h4><p>这里简单例一个比较简单的解决方式</p><p>再加一个锁，获取当有有人拿起筷子时，其他人都不能动</p><p>当然，这样原本好好的并行线程就给搞成串行了，能不能再优化呢？答案是可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只需要，把加的读写锁改成信号量，最多可以实现4个线程，不过有一个线程就得先当冤大头了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"><span class="type">sem_t</span> lock;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">            sem_wait(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            sem_post(&amp;lock);</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            sem_wait(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            sem_post(&amp;lock);</span><br><span class="line">            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然也可以，将奇数线程，先拿左手筷子，偶数线程先拿右手筷子，交错拿。也可以避免死锁问题</p><p>等等，思想是不变的，保证只要总有边界资源能够释放就是可以避免</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础06 | 时序竞态与守护进程</title>
      <link href="/2022/08/20/linux06/"/>
      <url>/2022/08/20/linux06/</url>
      
        <content type="html"><![CDATA[<h1 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h1><p>CPU进程之间的竞争</p><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h3><p>调用该函数的进程主动挂起，等待任意信号唤醒，然后执行这个信号的默认行为，想要让这个程序继续运行就需要对这个信号进行捕捉，执行自定义的响应函数</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    </span><br><span class="line">    act.sa_flags= <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = catch;</span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret = pause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pause sucess\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret =  alarm(<span class="number">0</span>);<span class="comment">//手动结束闹钟//当出现预期之外的信号干扰而唤醒时，提前结束这个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//还原信号捕捉函数的系统默认设置（上一个旧设置）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这里就会出现了一个比较致命的问题，设想这么个情况</p><p>假设在mysleep的闹钟函数中，</p><p>确实执行了定时器alarm函数成功定时了（这里假设只定时了1秒），准备执行pause时突然有其他进程抢占了CPU导致这个pause暂时得不到资源运行，足足停止了2秒钟没有运行，这时定时器已经发送过信号了，可这个信号是被捕捉的信号什么也不做的前提下，pause却这个时候执行了，进程挂起，可是再也收不到信号了，就会一直等啊等,导致整个进程阻塞。</p><p>在没有其他的函数处理这个时序竞态问题的话，首先想到的方法：</p><ul><li>在响应函数中，进行一个pause语句是否执行的判断（利用一个全局变量接受pause的返回值就行），如果没有执行，就再一次重置该闹钟。直到pause语句能够执行。</li></ul><p>这个方法我感觉可行，没有测试过，有能力条件的可以测试一下运行几千几万次试试效果。</p><p>第二个方法：</p><ul><li>函数sigsuspend()与信号集操作函数代替pause()的阻塞功能</li></ul><h3 id="sigsuspend"><a href="#sigsuspend" class="headerlink" title="sigsuspend"></a>sigsuspend</h3><p>函数的作用就是设定一个临时的信号屏蔽字，当收到其中一个没有被信号之前，进行一个挂起的操作pause,从而代替pause</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, susmask;</span><br><span class="line">    </span><br><span class="line">    act.sa_flags= <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = catch;</span><br><span class="line">    ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);<span class="comment">//将之前进程中的信号屏蔽字取出放入oldmask </span></span><br><span class="line">    </span><br><span class="line">    susmask = oldmask; </span><br><span class="line">    sigdelset(&amp;susmask, SIGALRM);<span class="comment">//保证这个信号在临时的信号集没有被屏蔽</span></span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret =  alarm(<span class="number">0</span>);<span class="comment">//手动结束闹钟//当出现预期之外的信号干扰而唤醒时，提前结束这个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//还原信号捕捉函数的系统默认设置（上一个旧设置）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    sigsuspend(&amp;susmask);</span><br><span class="line">    <span class="type">int</span> unslept = alarm(<span class="number">0</span>);<span class="comment">//手动结束闹钟//当出现预期之外的信号干扰而唤醒时，提前结束这个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复对信号SIGALRM的处理动作</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oldmask,<span class="literal">NULL</span>);<span class="comment">//恢复对信号进行屏蔽前的设置</span></span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时序竞态的产生原因"><a href="#时序竞态的产生原因" class="headerlink" title="时序竞态的产生原因"></a>时序竞态的产生原因</h3><p>CPU的竞争，系统负载</p><p>也表明了信号确实也不是很可靠啊</p><p>解决方法：</p><p>主动预见其产生，主动编写函数处理，原子操作</p><h3 id="全局变量的异步IO"><a href="#全局变量的异步IO" class="headerlink" title="全局变量的异步IO"></a>全局变量的异步IO</h3><p>分析父子进程交替数数程序，当前捕捉函数里的sleep取消，就会出现的必然问题（时序竞态的问题放大）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ParentCatch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am Parent %d\t%d\n&quot;</span>, getpid(), count);</span><br><span class="line">    count += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//sleep(1);   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ChildCatch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am Child %d\t%d\n&quot;</span>, getpid(), count);</span><br><span class="line">    count += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>; </span><br><span class="line">   <span class="comment">// sleep(1);    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        count = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = ChildCatch;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                kill(getppid(),SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">//保证子进程注册信号捕捉</span></span><br><span class="line">        act.sa_handler = ParentCatch;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        ParentCatch(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                kill(pid,SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常有sleep的时运行是没有问题的，可去掉sleep后运行之后可以发现，明明应该无限执行的进程，突然就死在某个数字上不动了，说明，发生了异常，这个异常的本质原因就是时序竞态，而直接原因，就是sleep被删除，没有足够时间进行CPU资源的争抢导致信号没发出去，比如子/父进程不检查flag值，也没有发送信号。</p><p>解决方法：</p><ul><li>去掉flag这个用来判断的全局变量，很显然的，flag根本没用，多此一举，直接在信号响应函数中发送信号，就没这么多屁事了</li><li>还可以使用锁，锁住这个flag全局变量。但是没必要（）</li></ul><h3 id="可重入与不可重入函数"><a href="#可重入与不可重入函数" class="headerlink" title="可重入与不可重入函数"></a>可重入与不可重入函数</h3><h4 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h4><p>一个函数在调用执行期间由于某种时序又被调用，称之为“重入”</p><p>递归函数就是一个重入函数形式</p><p>重入函数不应该含有全局变量,不要有malloc和free!</p><p>信号处理函数中有些可以重入，有些不可重入</p><p>safely called inside(可重入)</p><p>不可重入的：</p><ul><li>包含静态与全局</li><li>标准的I/O函数</li><li>有内存操作 malloc free new delete</li></ul><h3 id="子进程信号SIGCHLD"><a href="#子进程信号SIGCHLD" class="headerlink" title="子进程信号SIGCHLD"></a>子进程信号SIGCHLD</h3><p>信号的产生条件</p><ul><li>子进程终止时</li><li>子进程接收到SIGSTOP时</li><li>子进程处在停止态，接收到SIGCONT后唤醒时</li></ul><p>利用这个信号我们也可以回收子进程，不过需要注意信号集是个set集合</p><h3 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h3><p>信号也可以携带一定量的参数数据，</p><p>可以使用sigqueue函数对应kill函数</p><p>可在指定进程发送信号的同时携带参数,可以是一个int 和一个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure><h4 id="捕捉信号传参"><a href="#捕捉信号传参" class="headerlink" title="捕捉信号传参"></a>捕捉信号传参</h4><p>捕捉信号发送的参数，同样也可以使用sigaction函数 在传出参数的int&amp;</p><p>struct sigaction 的       void     (<em>sa_sigaction)(int, siginfo_t </em>, void *);</p><p>捕捉到相关信号的参数存储在 int 或者 siginfo_t* 的类型的结构体中</p><p>具体结构体可查阅man文档，需要注意的使用的时候需要配置sa_flag</p><h3 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h3><p>慢速的系统调用</p><p>会永久阻塞系统调用进程的</p><ul><li>pause</li><li>wait</li><li>read<ul><li>读空洞，读网络，读管道的时候，读设备（键盘等）</li></ul></li><li>等等</li></ul><p>其他系统调用：</p><ul><li>除了慢速系统调用都是</li></ul><p>慢速的系统调用 收到信号打断，或者唤醒</p><p>当慢速系统调用收到信号打断，就被成为终端系统调用</p><p>在慢速系统调用中我们需要对信号捕捉判断处理除了判断是否成功捕获还需要判断errno 是否为EINTR（表示慢速系统调用函数被信号打断）</p><p>打断后的处理方式通过sa_flag的配置</p><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>主进程默认创建了无数个子进程</p><p>子进程的进程组ID实际上就是主进程的PID</p><h4 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a>进程组操作函数</h4><p>getpgrp();<br>获取当前进程的进程组id</p><p>getpgid(pid);<br>获取指定进程的进程组ID</p><p>setpgid(pid,pgid);<br>设置指定进程的父进程id</p><p>结合使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        setpgid(pid, pid);<span class="comment">//让子进程脱离父进程</span></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程：id:%u \n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程的父进程的id：id:%u \n&quot;</span>, getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程的所属的进程组：id:%u \n&quot;</span>, getpgrp());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设置父进程的的进程组是自己父进程\n&quot;</span>);</span><br><span class="line">        setpgid(getpid(), getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程的所属的进程组：id:%u \n&quot;</span>, getpgrp());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的pid %u 所属进程组 %u\n&quot;</span>, getpid(), getpgrp());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的pid %u 所属进程组 %u\n&quot;</span>, getpid(), getpgrp());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h3><p>进程组是进程的集合</p><p>而进程组的集合，就是会话</p><p>创建会话</p><ul><li>创建会话的进程不能是已有的组长进程</li><li>创建会话的进程会成为一个新进程组的组长进程</li><li>需要root权限（ubuntu不需要）</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>调用进程是组长进程出错返回</li><li>建立新会话时 ，执行顺序为：fork 终止父进程，子进程调用setsid。</li></ul><p>子进程是野鸡变凤凰了，自立门户并且成为组长，会话ID也变成自己</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Daemon(精灵)进程，是linux的后台服务进程，通常独立于控制终端并且周期性执行某种任务或等待处理。</p><p>可以理解为后台服务，没有控制终端，很多服务器进程就是守护进程</p><p>一般守护进程名字末尾都是d</p><h4 id="创建一个守护进程"><a href="#创建一个守护进程" class="headerlink" title="创建一个守护进程"></a>创建一个守护进程</h4><ul><li>最关键的步骤其实就是创建会话<ul><li>创建子进程，关闭主进程，创建会话</li></ul></li><li>改变当前工作目录为根目录chdir();<ul><li>防止占用可卸载的文件系统（U盘，扩展内存卡等外设存储设备）</li><li>可以更改其他路径</li></ul></li><li>重设文件权限掩码umask一般都是0002，有特殊需要就设置</li><li>关闭文件描述符标准输出输入和出错 fd[0,1,2]<ul><li>不过一般都不关闭，而是进行重定向到黑洞NULL文件</li><li>dup2(fd[1], null)</li></ul></li><li>开始执行守护进程的核心进程</li></ul><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mydaemon</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步，子进程创建</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> sid = setsid();<span class="comment">//子进程变更为会话</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/icrad&quot;</span>);<span class="comment">//改变会话的工作目录</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">mode_t</span> mask = <span class="number">0000</span>; <span class="comment">//改变会话的文件权限掩码</span></span><br><span class="line">    umask(mask);</span><br><span class="line">    </span><br><span class="line">    close(STDIN_FILENO);  <span class="comment">//关闭一个输入端</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">//打开黑洞文件</span></span><br><span class="line">    dup2(STDIN_FILENO, STDERR_FILENO); <span class="comment">//把标准输出和错误全部都导向黑洞</span></span><br><span class="line">    dup2(STDIN_FILENO, STDOUT_FILENO);</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    mydaemon();<span class="comment">//创建一个守护进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主进程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="守护进程特性"><a href="#守护进程特性" class="headerlink" title="守护进程特性"></a>守护进程特性</h4><ul><li>不受用户注销，挂起的影响，除非你关机</li><li>快乐</li></ul><p>编写一个守护进程：每隔一定时间输出系统时间到一个文件中</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeDate</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd_r = open(<span class="string">&quot;Date.log&quot;</span>, O_CREAT|O_RDWR|O_APPEND, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd_r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案一:出错，无法写入</span></span><br><span class="line">    <span class="comment">//dup2(STDOUT_FILENO,fd_r);</span></span><br><span class="line">    <span class="comment">//execlp(&quot;date&quot;, &quot;date&quot;, NULL);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方案2</span></span><br><span class="line">    <span class="type">time_t</span> timp;</span><br><span class="line">    time(&amp;timp);</span><br><span class="line">    <span class="type">char</span>* time = asctime(localtime(&amp;timp));</span><br><span class="line">    write(fd_r,time,<span class="built_in">strlen</span>(time));</span><br><span class="line">    <span class="comment">//close(fd_r);</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mydaemon</span><span class="params">(<span class="type">int</span> sec)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步，子进程创建</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> sid = setsid();<span class="comment">//子进程变更为会话</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/icrad&quot;</span>);<span class="comment">//改变会话的工作目录</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">mode_t</span> mask = <span class="number">0000</span>; <span class="comment">//改变会话的文件权限掩码</span></span><br><span class="line">    umask(mask);</span><br><span class="line">    close(STDIN_FILENO);  <span class="comment">//关闭一个输入端</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">//打开黑洞文件</span></span><br><span class="line">    dup2(STDIN_FILENO, STDERR_FILENO); <span class="comment">//把标准输出和错误全部都导向黑洞</span></span><br><span class="line">    dup2(STDIN_FILENO, STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">settime</span>;</span></span><br><span class="line">    settime.it_interval.tv_sec = sec;</span><br><span class="line">    settime.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    settime.it_value.tv_sec = sec;</span><br><span class="line">    settime.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, writeDate);</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;settime, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入打印间隔时间\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印间隔为%ds\n&quot;</span>, time);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印间隔输入有误,默认为5秒\n&quot;</span>);</span><br><span class="line">        time = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mydaemon(time);<span class="comment">//创建一个守护进程</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础05 | 线程</title>
      <link href="/2022/08/15/linuxlwp/"/>
      <url>/2022/08/15/linuxlwp/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>LWP：light weight process</p><p>轻量级的进程，本质仍是进程（linux环境下）</p><p>与win不同，区别挺大的，实现原理都不一样。</p><p>独立的进制空间，拥有PCB</p><p>线程：也有PCB，但没有独立的地址空间（共享）</p><p>区别：在于是否共享地址空间。</p><p>进程可以理解为独居</p><p>线程可以理解为合租</p><p>linux下的最小执行单位：线程</p><p>最小的资源分配单位：进程。</p><h3 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h3><p>进程进行类似fork的操作，但是没有对父进程地址空间进行克隆clone，而是使用原有进程的三级页表，页表最终指向物理页面，中间有三次映射，也被称为三级映射</p><p>进程-&gt;虚拟地址(页目录-&gt;页表-&gt;物理页面)MMU-&gt;物理地址</p><p>不过线程不是完全使用进程的三级页表，实际上线程与进程的区别在于寄存器和栈的内容，不一样</p><p>函数指针调用分配在栈中(用户程序之间的栈)</p><p>两个指针(ebp,esp)组合规划（滑动窗口）一个栈帧，一个函数（还有局部变量等）占用的就是一个栈帧</p><p>进程在切换时要保存寄存器的值，这些值分配在内核区的栈空间之中</p><h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ul><li><p>文件文件描述符表</p></li><li><p>共享信号处理方式（信号建议不要与线程混用）</p></li><li><p>除了栈空间都共享</p></li></ul><h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ul><li><p>线程Id</p></li><li><p>处理器现场（寄存器）和内核栈</p></li><li><p>独立的栈空间</p></li><li><p>errno变量（在代码段中）</p></li><li><p>信号屏蔽字</p></li><li><p>调度优先级</p></li></ul><h3 id="线程优缺"><a href="#线程优缺" class="headerlink" title="线程优缺"></a>线程优缺</h3><p>优点：程序并发性高，开销小，数据通信，共享数据方便</p><p>缺点：库函数不稳定，调试，编写困难，gdb不支持，对信号支持不好。</p><p>优点相对突出，缺点不是硬伤，linux下由于实现方法，进程，线程差别不是很大。</p><h2 id="控制原语"><a href="#控制原语" class="headerlink" title="控制原语"></a>控制原语</h2><h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self()"></a>pthread_self()</h3><p>获取线程id 注意不是LWP。</p><p>gcc编译的时候需要加入 -pthread。</p><h3 id="pthread-creat"><a href="#pthread-creat" class="headerlink" title="pthread_creat()"></a>pthread_creat()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>thread：线程id(传出)</li><li>attr：线程属性（传入）</li><li>start_routine：线程的主控函数（传入）</li><li>arg ：线程主控函数的参数（传入）</li></ul><p>返回值：int，成功0 ，出错返回error的错误编号</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thrd_func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    var += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In %d thread  : %ld\n&quot;</span>, i+<span class="number">1</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var = %d\n&quot;</span>, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h3><p>单个线程退出</p><p>与exit退出进程不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>retval 退出时当前线程状态，传出参数</li></ul><p>在线程中执行exit（）会直接将进程和线程退出</p><h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h3><p>阻塞等待线程退出，获取线程退出状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125;<span class="type">test_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thrd_func</span><span class="params">(<span class="type">void</span>* retvar)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">test_t</span>* retval = (<span class="type">test_t</span>*)retvar;</span><br><span class="line">    retval-&gt;ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    retval-&gt;var = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(retval-&gt;str, <span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)retval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">test_t</span>* retval = (<span class="type">test_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">test_t</span>));</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="type">void</span>*)retval);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, (<span class="type">void</span> **)&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c , var = %d , str = %s&quot;</span>, retval-&gt;ch, retval-&gt;var, retval-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(retval);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收COUNT个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tfn</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">        var = <span class="number">333</span>;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">        var = <span class="number">777</span>;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">        var = <span class="number">666</span>;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *tid[COUNT];</span><br><span class="line">    <span class="type">int</span> *ret[COUNT];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], (<span class="type">void</span>**)&amp;ret[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回收了第%d个子线程，返回值ret= %d\n&quot;</span>, i+<span class="number">1</span>, ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prthread-detach"><a href="#prthread-detach" class="headerlink" title="prthread_detach()"></a>prthread_detach()</h3><p>线程设定为分离态，设定一个线程退出时自行回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>再进行回收就会报错了,因为已经自行完事了回收了寂寞。</p><h3 id="prthread-cancel"><a href="#prthread-cancel" class="headerlink" title="prthread_cancel()"></a>prthread_cancel()</h3><p>取消线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>这个线程的取消并不是实时的，需要达到一个取消点才会取消，比如说内核调用，系统调用。或者自己设定1个取消点在线程中</p><p>具体取消点函数可看man 7 pthreads 或者apue 12.7</p><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>创建线程的第二个参数，pthread_attr_t;</p><h3 id="attr-t结构"><a href="#attr-t结构" class="headerlink" title="attr_t结构"></a>attr_t结构</h3><ul><li><strong>int etachstate</strong> <ul><li><strong>线程的分离状态</strong></li></ul></li><li>int schedpolicy<ul><li>线程调度策略</li></ul></li><li>struct sched_param schedparam<ul><li>线程调度参数</li></ul></li><li>int inheritsched<ul><li>线程调度继承性</li></ul></li><li>int scope<ul><li>作用域</li></ul></li><li><strong>size_t guardsize</strong><ul><li><strong>线程栈末尾的警戒缓冲区大小</strong></li><li>栈空间的函数地址的线程栈并非连着的，之间有一个警戒区分割</li></ul></li><li>int stackaddr_set<ul><li>线程的栈设置</li></ul></li><li>void* stackaddr<ul><li>线程栈的地址位置</li></ul></li><li><strong>size_t stacksize</strong><ul><li><strong>线程栈的大小</strong></li><li>最大线程大小，N个线程对这块大小进行均分分配</li></ul></li></ul><p>加粗的是一般比较常用的属性</p><h3 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h3><p>提前定义一个结构体pthread_attr</p><p>调用pthread_attr_init()，进行值的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>常用的：</p><h4 id="设置状态"><a href="#设置状态" class="headerlink" title="设置状态"></a>设置状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br></pre></td></tr></table></figure><p>参数二有两个宏参数可以使用</p><ul><li>PTHREAD_CREATE_DETACHED<ul><li>分离态</li></ul></li><li>PTHREAD_CREATE_JOINABLE<ul><li>可回收态</li></ul></li></ul><p>需要注意的是，在分离态的子线程如果结束过快，create函数的返回的线程id，可能就是错误的id，需要在该子线程中调用一个pthread_cond_timedwait()函数，保证在结束前返回线程id。</p><h4 id="修改线程栈空间"><a href="#修改线程栈空间" class="headerlink" title="修改线程栈空间"></a>修改线程栈空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br></pre></td></tr></table></figure><p> 参数二传入一个栈地址，参数三就是要设定的大小</p><p>需要先在在堆空间申请一个空间(毕竟说到底，用户能修改使用的还是堆)</p><p>stackaddr = malloc (SIZE);</p><p>设定好栈空间后，创建的函数就会放到这个设置好的新的空间中</p><p>大小的限制取决于用户的malloc的最大大小。</p><p>而当过小过大都会回到栈默认值中</p><h2 id="线程使用注意点"><a href="#线程使用注意点" class="headerlink" title="线程使用注意点"></a>线程使用注意点</h2><ul><li>需要注意NPTL：线程库的版本</li><li>避免僵尸。</li><li>线程中一般不使用fork创建子进程<ul><li>子进程中只有调用子进程的线程存在</li></ul></li><li>线程中避免使用信号</li></ul><h2 id="多线程拷贝"><a href="#多线程拷贝" class="headerlink" title="多线程拷贝"></a>多线程拷贝</h2><p>之前有做过的多进程拷贝，这次再做个多线程拷贝，在linux系统下线程本质上还是进程，所以区别不大，IPC依旧选择MMAP。</p><p>这里直接上代码，没有难点，巩固一下线程的基本原语和基本特性</p><p>这里试了试最大线程数：我可以开辟的最大线程为15297个线程,如果需要更大的线程数，就需要手动将内存空间开辟到堆中，自己设定进程大小。在这个代码中就不演示了想要加的话可以在写一个判断设置线程空间大小，单纯图一乐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> fsize = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tnums = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* fmw = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* fmr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fileCopy</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> len = fsize/tnums;  </span><br><span class="line">    <span class="keyword">if</span>(i &lt; tnums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == tnums<span class="number">-1</span>)&#123;</span><br><span class="line">            memmove(fmw + (len*i), fmr + (len*i), len + (<span class="type">int</span>)(fsize%len));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memmove(fmw + (len*i), fmr + (len*i), len);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">progressBar</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buff,<span class="string">&#x27;\0&#x27;</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="type">char</span> label[] = <span class="string">&quot;\\/\\/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-39s][%c][%.lf%%]\r&quot;</span>,buff, label[i%<span class="number">4</span>], (i+<span class="number">1</span>)*<span class="number">2.5</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        buff[i] = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">        usleep(<span class="number">50000</span>/tnums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;食用方法：源文件名，新文件名，使用的线程数\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fdr = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;源文件&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fdw =open(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fdw &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;目的文件&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">finfo</span>;</span></span><br><span class="line">    fstat(fdr,&amp;finfo);</span><br><span class="line">    fsize = finfo.st_size;</span><br><span class="line">    <span class="type">int</span> ret = ftruncate(fdw, fsize);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;truncate error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmr = mmap(<span class="literal">NULL</span>, fsize, PROT_READ, MAP_SHARED, fdr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fmr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;目的文件映射&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdr);</span><br><span class="line">    fmw = mmap(<span class="literal">NULL</span>, fsize, PROT_WRITE, MAP_SHARED, fdw, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fmw == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;源文件映射&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据线程数创建线程  </span></span><br><span class="line">    tnums = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tnums &gt;= <span class="number">10000</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你要复制什么玩意？确定要这么多进程数？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> tid[tnums + <span class="number">1</span>];<span class="comment">//这里是之前测试回收是否成功的记录</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tnums; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i], &amp;attr, fileCopy, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid[tnums], &amp;attr, progressBar, (<span class="type">void</span> *)i);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap(fmr, fsize);</span><br><span class="line">    munmap(fmw, fsize);  </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础04 | 信号</title>
      <link href="/2022/08/11/linuxsig/"/>
      <url>/2022/08/11/linuxsig/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><ul><li><p>摔杯为号</p></li><li><p>一只穿云箭，千军万马来相见</p></li></ul><p>从这里可以看出信号几个特性，简单，迅速，明显，有条件触发的，多种的</p><p>信号是信息的载体，linux 古老的经典的通信方式，主要的通信手段</p><p>早期的信号不是很可靠，POSIX.1对可靠信号例程进行了标准化</p><p>信号基于linux内核进程间通信，<strong>内核发送内核处理</strong></p><p>时钟中断基于硬件</p><p>信号早期相当于软中断</p><p>软中断与硬件中断相比实际上并不是很可靠</p><h3 id="信号的4要素"><a href="#信号的4要素" class="headerlink" title="信号的4要素"></a>信号的4要素</h3><ul><li>信号名</li><li>信号编号</li><li>信号默认处理动作<ul><li>term：终止进程</li><li>ign：忽略，子进程死亡，默认会向父进程发送这样的信号，让父进程保持运行，比如SIGHLD</li><li>Core：终止进程，GDB等调试的工具中比较常见</li><li>Stop：停止（暂停）进程</li><li>Cont：继续</li></ul></li><li>信号对应事件</li></ul><p>man 7 signal查看帮助文档</p><h2 id="信号的产生5种方式"><a href="#信号的产生5种方式" class="headerlink" title="信号的产生5种方式"></a>信号的产生5种方式</h2><p><strong>注意：这里讨论的是ARM/X86的系统内核下的信号编号</strong></p><ul><li>按键产生<ul><li>Ctrl+c 产生SIG INT(2)终止/中断（interrupt）</li><li>Ctrl+z 产生SIG T STP(20)终端暂停</li><li>Ctrl+\ 产生SIGQUIT(3)退出</li></ul></li><li>系统调用<ul><li>kill，raise，</li></ul></li><li>软件条件<ul><li>定时器alarm</li></ul></li><li>硬件异常<ul><li>内存非法访问 SIGSEGV（11）段错误</li><li>除零 SIGFPE(8) 浮点数例外</li><li>总线 SIGBUS（7）总线错误</li></ul></li><li>命令产生<ul><li>kill命令 默认信号是11（终止进程）</li></ul></li></ul><h3 id="信号状态"><a href="#信号状态" class="headerlink" title="信号状态"></a>信号状态</h3><h4 id="递达态"><a href="#递达态" class="headerlink" title="递达态"></a>递达态</h4><p>信号产生后，内核会立刻递送，并到达，速度相当于光速，可以认为是瞬时的；</p><h4 id="阻塞态（屏蔽）（未决）"><a href="#阻塞态（屏蔽）（未决）" class="headerlink" title="阻塞态（屏蔽）（未决）"></a>阻塞态（屏蔽）（未决）</h4><p>信号产生后不可递达目的地接收时的状态</p><p>记录着信号状态的是位于进程控制块PCB中的</p><ul><li>阻塞信号集（信号屏蔽字）</li></ul><ul><li>未决信号集<ul><li>没有进行处理的信号集合</li></ul></li></ul><p>在产生信号的前提下，阻塞信号集影响未决信号集</p><h3 id="信号的3种处理方式"><a href="#信号的3种处理方式" class="headerlink" title="信号的3种处理方式"></a>信号的3种处理方式</h3><ul><li>执行信号的默认动作</li><li><del>草，走</del>，忽略（丢弃）</li><li>捕捉（调用户的处理函数）</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当出现信号都被屏蔽，捕捉或者忽略，唯一不会被阻塞的忽略的捕捉的两个信号</p><ul><li>SIGKILL（9）<ul><li>杀死进程 </li></ul></li><li>SIGSTOP（19）<ul><li>停止进程</li></ul></li></ul><h3 id="常见信号产生函数"><a href="#常见信号产生函数" class="headerlink" title="常见信号产生函数"></a>常见信号产生函数</h3><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><strong>注意kill函数其实并不是真的杀死进程，需要根据你选择发送的信号决定</strong></p><p>很简单看 man 文档就能知道了，这里直接上示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = kill(pid, SIGKILL);</span><br></pre></td></tr></table></figure><p>pid有四个特殊值：</p><ul><li>0 同一个进程组的所有进程</li><li>>0指定进程</li><li>\&lt;0 指定进程组</li><li>-1表示可发送的（权限）所有进程</li></ul><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>作用给当前进程发送一个信号（给自己发）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = raise(SIGSTOP);</span><br></pre></td></tr></table></figure><h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>作用就是自己给自己发一个异常信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abort</span>();</span><br></pre></td></tr></table></figure><h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h3><h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>设置一个定时器，设定内核指定时间发送一个SIGALRM（14）信号</p><p>每个进程只有一个定时器</p><p>自然定时法，与进程的状态无关</p><p>返回值比较有意思，返回的是上一次调用距离当前调用的时间差</p><p>测试我的计算机一秒能数多少个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//计算我的计算机一秒能执行多少次++的操作</span></span><br><span class="line">    <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld \n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现我的一秒只能执行140615次打印和++操作，<del>确实挺拉的</del></p><p>如果将打印操作重定向out中，可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat out | awk &#x27;END &#123;print&#125;&#x27;</span><br></pre></td></tr></table></figure><p>发现执行10590892了次++</p><p>可以发现IO极大的拖慢执行效率</p><p>实际执行时间 = 系统时间 + 用户时间 +等待时间 （等硬件资源，系统资源）</p><p>可以用 time 看出具体的系统时间和用户时间</p><h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h4><p>功能比timer更好更全，所以普遍使用该函数作为定时器</p><ul><li>可指定的三种计时方式<ul><li>TIMER_REAL自然定时 发送的信号SIGALRM</li><li>TIMER_VIRTUAL虚拟空间计时（用户空间）发送的信号 SIGVTALRM</li><li>ITIMER_PROF运行时计时（用户+内核）发送的信号SIGPROF</li><li><strong>注意三种定时器信号意味着一个进程中可以同时设置三种不同类型的定时器</strong></li></ul></li><li>可以指定精度微秒，可循环的定时器</li></ul><p>通过代码进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">my_alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sec)</span>&#123;</span><br><span class="line">    <span class="comment">//定义存储定时器的数据的结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    it.it_value.tv_sec = sec;<span class="comment">//秒</span></span><br><span class="line">    it.it_value.tv_usec = <span class="number">0</span>;<span class="comment">//微秒</span></span><br><span class="line">    <span class="comment">//下一次的定时定时器的时间</span></span><br><span class="line">    <span class="comment">//设置为0说明没有下一次定时器，只有一个</span></span><br><span class="line">    it.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">    it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个参数是选择计时类型，第二个是传入定时器的数据，第三个是传出参数，接收的是上一个定时器的间隔时间差</span></span><br><span class="line">    <span class="comment">//有了计时类型就同时设定三种不同类型的定时器</span></span><br><span class="line">    ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldit.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(; ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要实现一个循环的定时器(周期定时)代码实现如下</p><p>具体：实现一个循环1秒发送SIGALRM信号的定时器，和一个0.5s的发送SIGTVALRM信号的定时器。信号调用用户自定义的行为：显示抓取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigroutine</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (signo)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGALRM:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Catch a signal - SIGALRM\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGVTALRM:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Catch a signal - SIGTVALRM\n&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sec, <span class="type">unsigned</span> <span class="type">int</span> usec, <span class="type">int</span> timetype )</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    it.it_value.tv_sec = sec;</span><br><span class="line">    it.it_value.tv_usec = usec;</span><br><span class="line">    </span><br><span class="line">    it.it_interval.tv_sec = sec;</span><br><span class="line">    it.it_interval.tv_usec = usec;</span><br><span class="line">    <span class="type">int</span> type = timetype;</span><br><span class="line">    ret = setitimer(type, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    signal(SIGALRM, sigroutine);</span><br><span class="line">    signal(SIGVTALRM, sigroutine);</span><br><span class="line">    my_alarm(<span class="number">1</span>, <span class="number">0</span>, ITIMER_REAL);</span><br><span class="line">    my_alarm(<span class="number">0</span>, <span class="number">500000</span>, ITIMER_VIRTUAL);</span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++的写法可以使用lambda函数写捕获能精简自定义响应函数部分</p><h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p>对未决信号集和阻塞信号集的操作</p><h4 id="信号集的设定"><a href="#信号集的设定" class="headerlink" title="信号集的设定"></a>信号集的设定</h4><p>本质上是一个集合，一个无序不重复的数组，类似C++的set容器，在c库types.h中定义了一个sigset_t，用来存放信号集合</p><p>提供了5个函数对该sigset_t进行操作 </p><ul><li>sigemptyset(sigset_t* set) ; 将信号集清0  </li><li>sigfillset(sigset_t* set ); 将信号集设置为1  </li><li>sigaddset(sigset_t* set, int signum);将某一个信号加入集合当中，信号编号对应值设置为1</li><li>sigdelset(sigset_t* set, int signum);将某一个信号删除。将编号对应值设置为0</li><li>sigismember(sigset_t* set, int signum):取信号在该信号集的对应的值</li></ul><p>实际上未决信号集屏蔽信号集都在pcb中，用户函数是无法直接对其进行位操作，正常也不会</p><h4 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask()"></a>sigpromask()</h4><p>我们需要使用一个函数对将我们自定义的集合设置到屏蔽信号集中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = sigprocmask(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>,  <span class="type">sigset_t</span>* oldset)</span><br></pre></td></tr></table></figure><p>需要注意的是，屏蔽实际上只是暂缓信号，直到解除屏蔽</p><ul><li>SIG_BLOCK 表示需要屏蔽的信号 mask = mask | set</li><li>SIG_UNBLOCK 表示需要解除屏蔽的信号， mask = mask&amp; ~set</li><li>SIG_SETMASK 表示set用于替代原始屏蔽集的新屏蔽集 mask = set</li></ul><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending()"></a>sigpending()</h4><p>读取当前进程的未决信号集</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>程序示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPending</span><span class="params">(<span class="type">sigset_t</span>* pend)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">33</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(pend,i))&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> myset, oldset, pend;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;myset, SIGTSTP);</span><br><span class="line">    sigaddset(&amp;myset, SIGINT);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;oldset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sigpending(&amp;pend);</span><br><span class="line">        printPending(&amp;pend);</span><br><span class="line">        sleep(<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>注册一个内核信号捕捉的行为 </p><p>类似qt信号槽，前端插件开发中的hooks钩子</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__sighandler_t</span>  handler= signal(SIG, handler);</span><br><span class="line"><span class="keyword">if</span>(handler == SIG_ERR)&#123;</span><br><span class="line">    perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意返回的值是一个函数指针，指向的其实就是handler这个函数</p><p>由此可见这是一个典型的callback函数</p><p>signal会打破进程的睡眠状态无论sleep(N) N值有多大，只要接受到相应信号将会打破主函数当前的sleep状态，执行下一条语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGALRM, signal_func);</span><br><span class="line">signal(SIGINT, signal_func);</span><br><span class="line">alarm(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  sleep(<span class="number">300</span>);<span class="comment">//会直接打断，继续下一条语句</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;主函数打印 %d\n&quot;</span>, getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>作用比signal更强。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br></pre></td></tr></table></figure><p>先来看看这个结构体又是什么构造,看看man文档</p><ul><li><p>sa_sigaction </p><ul><li>扩展信号响应函数指针</li></ul></li><li><p>sigset_t  sa_mask</p><ul><li>使用sa_mask 进行信号的临时屏蔽阻塞<ul><li>一般用于捕捉函数需要运行中收到同一个或者其他信号时，保证捕捉响应函数处理结束</li><li>仅在捕捉响应函数执行期间生效</li></ul></li></ul></li><li><p>int sa_flag</p><ul><li>标志位</li><li>0 采用默认的属性，在信号捕捉函数执行期间自动屏蔽本信号</li><li>SA_NOCLDSTOP 子进程暂停时不提醒</li><li>SA_NOCLDWAIT 子进程死亡不回收</li><li>SA_NODEFER 不屏蔽信号响应函数中的信号</li><li>SA_ONSTACK 信号响应函数在替补栈中分配内存</li><li>SA_RESETHAND 响应函数执行一遍重置信号响应策略（只执行一次）</li><li>SA_RESTART 自动重启被该信号中断的某些系统调用</li><li>SA_SIGINFO 使用扩展信号响应函数而不是标准响应函数</li></ul></li><li><p>viod* (sa_handler)(int);</p><ul><li>阔号代表两个可用类型</li><li>实际上就是捕捉函数的函数指针</li></ul></li></ul><p>多说无益代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">docatch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d signal is caught\n&quot;</span>, signo);</span><br><span class="line">    <span class="comment">//sleep(10);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">   <span class="comment">// sigaddset(&amp;act.sa_mask, SIGQUIT);</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要注意的特性"><a href="#需要注意的特性" class="headerlink" title="需要注意的特性"></a>需要注意的特性</h4><ul><li><p>PCB中的信号屏蔽集mask和函数提供的sa_mask，在响应函数运行期间sa_mask最优</p></li><li><p>当出现多个同一个信号被屏蔽阻塞，解除屏蔽后，只会处理一次信号，不户籍进行排队</p></li></ul><h2 id="内核捕捉信号过程"><a href="#内核捕捉信号过程" class="headerlink" title="内核捕捉信号过程"></a>内核捕捉信号过程</h2><ol><li>执行主控制流程的某条指令时因为中断或者异常系统调用进入内核</li><li>内核处理完异常准备回用户模式之前，先处理当前进程中可以递送的信号</li><li>如果信号的处理动作 是自定义的信号处理函数，则回到用户模式执行信号处理函数（而不是回到主控制流程）</li><li>信号处理函数返回时执行特殊的系统调用sigreturn 再次进入内核</li><li>在内核中,在返回用户模式，从主控制流程中上次被中断的地方继续向下执行</li></ol><p><del>图,改日再画</del></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础02 | 程序和进程第一节</title>
      <link href="/2022/08/10/linux02/"/>
      <url>/2022/08/10/linux02/</url>
      
        <content type="html"><![CDATA[<h1 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h1><p>程序是二进制文件，在磁盘上，不占用系统资源（CPU，内存，打开的文件，设备，锁….)</p><p>进程,比较抽象的概念，活跃的程序，占用系统资源</p><p>可以通俗理解为：程序是剧本，进程是上演的戏剧</p><h2 id="需要知道的前置知识"><a href="#需要知道的前置知识" class="headerlink" title="需要知道的前置知识"></a>需要知道的前置知识</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>单道程序设计：DOS系统，程序只能排队占用CPU执行，</p><p>多道程序设计：想要实现多开进程，而CPU如果只有一个，需要划分时间分片设置一个时间中断，硬件手段，给打开的多个程序时间中断，给进程们进行分配CPU的使用时限，由于CPU计算相当快，人眼看不到停止轮次，就会认为是并行运行，实际上是并发</p><h3 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a>CPU和MMU</h3><p>CPU：硅，<del>去沙滩抓把沙子做一做就弄明白了</del><br>请移步机组文章</p><p>这里单独拿出MMU</p><h4 id="MMU基本工作原理"><a href="#MMU基本工作原理" class="headerlink" title="MMU基本工作原理"></a>MMU基本工作原理</h4><p>MMU是一个内存管理单元，在CPU中</p><p>虚拟内存只是个概念，需要MMU将虚拟内存的虚拟地址映射在对应的物理地址上。除了映射功能，还能设置内存访问的级别，一般英特尔cpu设定的内存访问级别都有四个级别</p><p>linux只使用了3级与0级两种级别</p><p>0级的内核空间，3级就是用户空间</p><p>在运行的两个进程，即使程序相同，但是用户区的映射的不是同一块的物理进程，内核区指向的物理内存实在同一块，但是PCB是不一样的，具体还是请移步机组文章</p><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>进程描述符（linux系统下的通用称呼)</p><p>PCB本质是一个结构体组</p><p>结构体成员</p><ul><li>进程id，系统中每个进程有唯一的id,</li><li>进程的状态<ol><li>初始化</li><li>就绪：等待CPU分配时间片</li><li>运行</li><li>挂起：等待除了CPU以外的其他资源，主动放弃CPU，可以理解为阻塞状态</li><li>终止</li></ol></li><li>进程切换时需要进行保存的和恢复的一些CPU资源和寄存器的值。</li><li>描述虚拟地址空间的信息<ul><li>MMU维护这一个虚拟地址映射到物理地址的表</li></ul></li><li>描述控制终端的信息<ul><li>运行该进程的终端信息呗</li></ul></li><li>当前工作目录<ul><li>当前进程的工作目录，具体请看chdir函数</li></ul></li><li>umask掩码<ul><li>文件的保护控制权限用</li></ul></li><li>文件描述符表<ul><li>包含很多指向文件结构体的指针,就是fd，</li></ul></li><li>信号相关的信息</li><li>用户id和组id</li><li>会话（Session）和进程组</li><li>进程可以使用的资源上限（Resource Limit)<ul><li>使用ulimit -a命令查看linux中的所有的进程组使用的资源上限</li></ul></li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>linux是什么系统，多用户多任务的开源操作系统</p><p>每个用户的配置都不一样，每个人都有不同的启动桌面，不同的默认工具设置，等等，实际上就是环境变量不一样</p><p>我们所常见的全局环境变量，用户环境变量可以这么理解</p><p>几个常用环境变量</p><ul><li>PATH：二进制的执行文件路径</li><li>SHELL：当前的命令解析器</li><li>LANG：当前的语言</li></ul><p>环境变量的打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个环境变量的函数</p><ul><li>setenv()</li><li>getenv()</li><li>clearenv()</li></ul><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* val;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1,%s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line">    setenv(name, <span class="string">&quot;自定义一个环境变量&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2,%s = %s\n&quot;</span>, name, val); </span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">int</span> ret = unsetenv(<span class="string">&quot;ABCDE&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret: %d\n&quot;</span>, ret);</span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3,%s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    <span class="type">int</span> ret = unsetenv(<span class="string">&quot;ABCDE&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret: %d\n&quot;</span>, ret);</span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3,%s = %s\n&quot;</span>, name, val); </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>fork函数</p><p>通过函数fork创建一个子进程</p><p>fork函数有两个返回值，一个是是子进程的id,一个是flag（是创建进程成功）</p><p>父进程的fork返回的是子进程的id，子进程fork返回的是flag</p><p>创建一个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程测试&quot;</span>);</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">       _exit(<span class="number">1</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程,pid= %u,我的父进程的 ppid= %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主进程,pid= %u,我的父进程的 ppid= %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主进程睡眠1秒保证子进程先运行一会</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;测试子进程会不会也执行\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环创建五个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程测试\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="comment">//第一个进程睡眠一秒依次类推</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子进程,pid是：%u, 父进程ppid是：%u\n&quot;</span>, i+<span class="number">1</span>, getpid(),getppid());   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主进程结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>以上所有的进程实际上都在同时争夺CPU，需要做进程状态的控制才能保证到底是哪个进程先使用CPU</p><p>如果将所有的sleep休眠函数都删除，那么结果其实也是一样的，只是显示上有问题</p><h4 id="父子进程的异同"><a href="#父子进程的异同" class="headerlink" title="父子进程的异同"></a>父子进程的异同</h4><p>主要是值的相同</p><p>相同：</p><ul><li>全局变量，</li><li>.data</li><li>.text</li><li>栈</li><li>堆</li><li>环境变量</li><li>用户ID</li><li>宿主目录</li><li>进程工作目录</li><li>信号处理方式等</li></ul><p>不同</p><ul><li>进程ID</li><li>fork返回值</li><li>父进程ID</li><li>进程运行时间</li><li>定时器</li><li>未决信号集</li></ul><p>父子进程间遵循</p><p><strong>读时共享，写时复制</strong></p><p>共享的</p><ol><li>文件描述符</li><li>mmap建立的映射区</li></ol><h4 id="父子进程的调试"><a href="#父子进程的调试" class="headerlink" title="父子进程的调试"></a>父子进程的调试</h4><p>gdb调试默认父进程</p><p>在调用子进程函数之前<br>设置跟踪子进程，就可以走子进程的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child</span><br></pre></td></tr></table></figure><p>如果有多个子进程，那就需要设置好条件断点，通过进程的索引值比如你设定的id，或者直接使用pid判断来进入不同的子进程</p><h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p>除了子父进程，子进程还可以执行别的程序</p><p>换核不换壳，pid ppid都不变，改变的其实是代码区和等等。</p><p>利用的是exec函数族</p><h4 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h4><p>exec函数族之一的函数</p><p>l  代表的是list(具体可以理解为就是指令参数0~n),而p 表示的是PATH环境变量</p><p>利用execlp函数实现子进程执行 环境变量中指定的地址二进制文件ls文件，打印当前的进程的目录下的文件<br>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这里是父进程&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解析一下execlp的使用：</p><p>第一个参数表示的是执行的是ls这个文件</p><p>第二个参数表示argv[0],第三个就是argv[1]依次类推</p><p>直到选项参数结束为NULL</p><p>假设我们要执行我们自己的程序</p><p>可以使用execl （不用指定环境变量）</p><p>除了以上的execlp和execl</p><p>还有execv和execvp, execvpe, execle</p><p>参数：</p><ul><li>l(list) 参数列表</li><li>p(path) 参数的环境变量path</li><li>v(vector) 参数的数组</li><li>e(environment) 参数的所有的环境变量<ul><li>在使用e时，需要先导入环境变量表extren </li></ul></li></ul><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><del>没爹没妈的进程</del></p><p>没有父进程回收，系统会将其父进程设置为init进程，<del>可以理解为孤儿院领养了</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让父进程先死，后子进程打印ID，打印的父进程ID是init进程ID</span><br></pre></td></tr></table></figure><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>父进程忘记给子进程结束后收尸了</p><p>子进程会残留在PCB中，成为僵尸进程，kill无法终止</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，pid: %u,父进程ppid: %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程：啊，我死了\n&quot;</span>);   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">        <span class="comment">//主进程</span></span><br><span class="line">        <span class="comment">//循环运行没有给结束的子进程进行收尸</span></span><br><span class="line">        <span class="comment">//循环打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，pid: %u,我的子进程ppid: %u\n&quot;</span>, getpid(), pid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;主进程发呆中呀~\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在终端查看进程可以看见</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220808141216762.png" alt=""></p><p>看见一个状态为Z+ 进程名字使用中括号括起（一般买书的时候发现作者名字被中括号扩起说明作者已经过世了）<br>那么该怎么将上面这两种子进程回收呢</p><p>我们需要使用以下函数</p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><ul><li><p>阻塞主进程，等待子进程退出，然后回收</p></li><li><p>获取子进程的结束状态</p><p>根据wait的传出参数是一个整形数int* status，该怎么得知对应状态呢？</p><p>需要系统提供的宏函数来进一步判断进程终止的具体原因，重点掌握</p><ul><li>正常结束：</li><li>WIFEXITED(status) 为非0    进程正常结束</li><li>WEXITSATUS(status) 如果是进程正常结束，返回进程的退出的值</li><li>异常结束：</li><li>WIFSIGNALED(status) 为非0    进程异常结束</li><li>WTERMSIG(status) 如果进程异常结束，返回收到的是第几种信号造成的 结束<ul><li>kill默认15号信号杀死进程</li><li>我们常见的访问不可访问的内存空间会返回的是11号信号，表示的是段错误信号</li></ul></li></ul></li></ul><p><strong>代码示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    <span class="type">__pid_t</span> wpid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execl(<span class="string">&quot;02app&quot;</span>, <span class="string">&quot;02app&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，pid: %u,父进程ppid: %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程：我死了\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">121</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，pid: %u,我的子进程ppid: %u\n&quot;</span>, getpid(), pid);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            wpid = wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;正常关闭，关闭的返回值为:%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;异常关闭，受到的是信号为 %d 号\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响"><a href="#实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响" class="headerlink" title="实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响"></a>实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响</h4><p>问题来了</p><p>一次wait函数调用能回收几个子进程？<strong>一个</strong>,想要回收多个子进程，需要多次调用</p><p>但是自动默认选择的是先结束的子进程。</p><p>显然这是有些局限的，不能指定回收哪一个子进程</p><p>问题解决：</p><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><p>作用与wait大体相同，不同点，也是关键点</p><ul><li><p>可以选择不阻塞主进程，使用轮询方式判断子进程是否结束，需要设置第三个参数为WNOHANG（wait not hang)主进程不挂起</p><p>回收指定的子进程并且不挂起主进程代码示例：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">__pid_t</span> pid, wpid;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="type">__pid_t</span> wpid3;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            wpid3 = pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; count)&#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子进程,我的pid是: %u,我的父进程id是: %u\n&quot;</span>, i+<span class="number">1</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(wpid3, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (wpid != wpid3);<span class="comment">//当没有子进程回收跳出轮询</span></span><br><span class="line">        <span class="comment">//这里有一个BUG，会极大的占用cpu资源，在下方的代码有修正</span></span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第三个进程结束成功回收\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;所有进程都回收成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要回收所有的子进程并且不挂起，将waitpid的第一个参数和跳出轮询的判断设置为 -1（-1表示没有一个进程需要回收，如果收成功，返回的是回收成功的pid）</p><p>第一个参数有四个特殊的值</p><ul><li>大于0，表示回收指定的PID的进程</li><li>0 ，回收本组的任意一个子进程</li><li>-1，表示回收任意一个子进程，等价于 wait(NULL)；</li><li>小于-1的值，表示回收指定的进程组GPID的任意子进程</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>假设需要定义一个进程任务，任务内容要求主进程有三个子进程</p><p>第一个子进程实现ps_dup2，第二个子进程实现自定义的程序，第三个出段信号引发错误的程序。</p><p>最后主进程再不结束运行的情况下对所有进程进行回收</p><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;ps.out&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">121</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程2&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;w2&quot;</span>, <span class="string">&quot;w2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程3&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;w3&quot;</span>, <span class="string">&quot;w3&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="type">pid_t</span> w3pid;<span class="comment">//第三个进程</span></span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;<span class="comment">//设定一个轮询次数，否则极大浪费cpu资源</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            w3pid = pid;</span><br><span class="line">            <span class="comment">//记录测试用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            w1();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            w2();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            w3();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;轮询次数为：%d\n&quot;</span>, n);</span><br><span class="line">            <span class="comment">//回收所有的子进程</span></span><br><span class="line">            <span class="comment">//轮询方式,不挂起主程序</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">               wpid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG); </span><br><span class="line">               <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">               <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收值：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;异常信号为：%d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;   </span><br><span class="line">            &#125;<span class="keyword">while</span>(wpid != <span class="number">-1</span> || n &gt; <span class="number">0</span> );</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主程序时间已过，再次自动回收所有的子进程\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;轮询次数为：%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux小作业 | 多进程拷贝</title>
      <link href="/2022/08/10/linuxwork01/"/>
      <url>/2022/08/10/linuxwork01/</url>
      
        <content type="html"><![CDATA[<h1 id="小作业01：多进程拷贝"><a href="#小作业01：多进程拷贝" class="headerlink" title="小作业01：多进程拷贝"></a>小作业01：多进程拷贝</h1><p>作业要求：实现多进程分段拷贝文件，可指定拷贝的文件的路径，和拷贝使用的进程数，</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>系统函数有：</p><ul><li>fork<ul><li>进程创建</li></ul></li><li>waitpid<ul><li>子进程死亡回收</li></ul></li><li>stat<ul><li>获取文件大小</li></ul></li><li>open<ul><li>打开文件</li></ul></li><li>mmap<ul><li>内存映射</li></ul></li></ul><h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><p>也算不上什么难点，只不过需要对每个进程所需要的写入的片段字节大小和和偏移量思考一下,其余的无非就是细节上的问题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./mcp rfilepath wfilepath n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程数为 %d\n&quot;</span>, n);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程数默认为 %d\n&quot;</span>, n);</span><br><span class="line">        n = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_r = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd_r == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;read init error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fr</span>;</span>  </span><br><span class="line">    fstat(fd_r,&amp;fr);</span><br><span class="line">    <span class="type">size_t</span> size = fr.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_w = open(argv[<span class="number">2</span>], O_RDWR | O_CREAT |O_TRUNC, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd_w == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write init error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓宽写文件</span></span><br><span class="line">    ftruncate(fd_w, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对读文件进行mmap</span></span><br><span class="line">    <span class="type">char</span>* mm_r = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd_r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm_r == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap readfile error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd_r);</span><br><span class="line">    <span class="comment">//对写文件进行mmap</span></span><br><span class="line">    <span class="type">char</span>* mm_w = mmap(<span class="literal">NULL</span>, size, PROT_READ| PROT_WRITE, MAP_SHARED, fd_w, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm_w == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap writefile error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd_w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据所选进程数求出字节数和进程数</span></span><br><span class="line">    <span class="type">int</span> len = size/n;</span><br><span class="line">    <span class="comment">//最后一个进程需要处理的子节数</span></span><br><span class="line">    <span class="type">int</span> len_end = len + (size%len);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid ,wpid;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(i &lt; n<span class="number">-1</span> || n == <span class="number">1</span> &amp;&amp; pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//前倒数第一个子进程们</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个子进程 ,偏移的数据长度为 %u 字节, 复制了%u字节\n&quot;</span>, i+<span class="number">1</span>, len*i, len);</span><br><span class="line">         memmove(mm_w+(len*i), mm_r+(len*i), len);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//倒数第一个子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最后一个子进程, 偏移的数据长度为 %u 字节，复制了%u字节\n&quot;</span>, len*i, len_end);</span><br><span class="line">         memmove(mm_w+(i*len), mm_r+(i*len), len_end);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//主进程//进行回收</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">           wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">           <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(wpid !=<span class="number">-1</span> || n &gt; <span class="number">0</span> );</span><br><span class="line">        munmap(mm_r, size);</span><br><span class="line">        munmap(mm_w, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node项目需要注意的</title>
      <link href="/2022/08/02/nodetip/"/>
      <url>/2022/08/02/nodetip/</url>
      
        <content type="html"><![CDATA[<h3 id="Node项目需要注意的"><a href="#Node项目需要注意的" class="headerlink" title="Node项目需要注意的"></a>Node项目需要注意的</h3><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>NPM的第三方的包过大时</p><p>将node_modules文件夹，添加到.gitgnore的忽略文件中</p><p>只需要创建一个package.json<br>在项目文件夹下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>自动将依赖的第三方包记录在package.json中</p><p>注意：执行该命令时项目不能有中文和空格</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>git clone一个项目后，</p><p>需要执行该项目先前执行依赖包的下载操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line"><span class="comment">#npm install</span></span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 指定的包名</span><br></pre></td></tr></table></figure><h3 id="需要了解"><a href="#需要了解" class="headerlink" title="需要了解"></a>需要了解</h3><p>包的项目上线之后如果不会用到，将包安装时的指令添加选项-D</p><p>例如安装webpack</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack -D </span><br></pre></td></tr></table></figure><p>该包就会放入开发阶段的结点中</p><p>devDependencies(开发依赖包)</p><p>如果上线和开发都需要使用</p><p>默认的安装包的方式就好</p><p>默认的结点</p><p>Dependencies（核心依赖包）</p><p>第三方包的使用具体查看www.npmjs.com查阅文档</p><p>当然也可以直接去寻找REAMD.md文档</p><h3 id="下包速度的提升"><a href="#下包速度的提升" class="headerlink" title="下包速度的提升"></a>下包速度的提升</h3><p>更换镜像源</p><ul><li>linux 下在家目录下的.npmrc文件添加这一行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><ul><li><p>windows</p><p>执行这一条指令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>通过指令查看当前配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>你问为什么不用淘宝镜像源？具体请访问<a href="https://npmmirror.com/">https://npmmirror.com/</a></p><h4 id="简单的自定义包的开发"><a href="#简单的自定义包的开发" class="headerlink" title="简单的自定义包的开发"></a>简单的自定义包的开发</h4><p>一个项目文件夹</p><p>package.json 包的信息</p><p>index.js：包的主体</p><p>README.md： 相关功能介绍说明文档</p><p>当然package.json可以在写好主体的所有部分最后在使用命令生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>比如自定义一个简单的第三方包作为例子</p><p>功能：转义HTML字符，防止简单的XXS攻击.再重新还原返回</p><p>主体文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">htmlstr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> htmlstr.<span class="title function_">replace</span>(<span class="regexp">/&lt;|&gt;|&quot;|&amp;/g</span>,<span class="function">(<span class="params">match</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;it;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;quot;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;amp;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">htmlUnEscape</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&amp;it;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>,<span class="function">(<span class="params">match</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;it;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&amp;amp;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    htmlEscape,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后在该项目文件夹执行npm包初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>得到的package.json内容修改如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;htmlescape&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;转义HTML字符，防止XXS攻击.再重新还原返回&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;htmlEscape.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;html&quot;</span><span class="punctuation">,</span><span class="string">&quot;escape&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icrad&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再写个使用介绍文档就完成一个简单的包</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode|水果成篮|简单C++实现</title>
      <link href="/2022/07/31/shuiguochenglan/"/>
      <url>/2022/07/31/shuiguochenglan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没做题了，久违的简单题，却没想到花了我一个小时<del>我是一个一个一个究极菜狗啊啊</del>，好久没做，思路都不清晰了，特记该文章边做题边理清思路</p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><pre><code>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</code></pre><p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p>来源：力扣（LeetCode）<a href="https://leetcode.cn/problems/fruit-into-baskets">水果篮子</a><br>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>滑动窗口，也就是双指针</p><p>给了数组，需要返回子数组最大符合长度</p><h4 id="确定变量"><a href="#确定变量" class="headerlink" title="确定变量"></a>确定变量</h4><p>快指针：int fast=0</p><p>慢指针：int slow=0    </p><p>由题目可知：</p><p>明确判断点：是否满足一个最大数组长度 与 篮子存放的两种苹果种类的异同</p><p>需要记录两种苹果变量（动态的）</p><p>第一种：int first=0</p><p>第二种：int second=0</p><p>给出了果树的数组fruits</p><p>第一种类与慢指针绑定</p><p>第二种类与快指针绑定</p><p>first=fruits[fast];</p><p>second=fruits[slow];</p><p>最长数组计算:</p><p>fast-slow+1</p><p>需要返回的最大数组定义</p><p>int length=0;</p><h4 id="列出情况"><a href="#列出情况" class="headerlink" title="列出情况"></a>列出情况</h4><ol><li>快指针指向的果树等于第一种</li><li>快指针指向的果树等于第二种</li><li>快指针指向的果树没有一种相等</li></ol><p>三种情况，实际上是两种处理方式</p><p>1与2的可以合并一种情况处理，有一个条件满足即可:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fruits[fast]) == first || fruits[fast] == second)&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//更新返回长度</span></span><br><span class="line">   length = <span class="built_in">max</span>(fast-slow+<span class="number">1</span>, length)</span><br><span class="line">     fast++;<span class="comment">//快指针加一，慢指针不动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他（就是出现情况三）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//更新摘取果树顺序</span></span><br><span class="line">    slow=fast<span class="number">-1</span>;<span class="comment">//slow回退fast一格,此时的快指针指向的值一定不等于slow的指向</span></span><br><span class="line">    second=fruits[slow];<span class="comment">//将该值的给第二种果树篮子</span></span><br><span class="line">    frist=fruits[fast];<span class="comment">//当前指向的值给第一种果树篮子</span></span><br><span class="line">    <span class="comment">//前方每有一个与第二种种类相同的果树，慢指针回退一个</span></span><br><span class="line">    <span class="comment">//避免slow=-1 再加上条件</span></span><br><span class="line"><span class="keyword">while</span>(fruits[slow<span class="number">-1</span>] == second &amp;&amp; slow &gt;= <span class="number">1</span> )slow--;</span><br><span class="line">    <span class="comment">//更新返回长度</span></span><br><span class="line">   length = <span class="built_in">max</span>(fast-slow+<span class="number">1</span>, length);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> first = fruits[fast];</span><br><span class="line">        <span class="type">int</span> second = fruits[slow];</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; fruits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(fruits[fast] == first || fruits[fast] == second)&#123;</span><br><span class="line">                length = <span class="built_in">max</span>(fast - slow + <span class="number">1</span>, length);</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow = fast - <span class="number">1</span>;</span><br><span class="line">                second = fruits[slow];</span><br><span class="line">                first = fruits[fast];</span><br><span class="line">                <span class="keyword">while</span>(slow &gt;= <span class="number">1</span> &amp;&amp; fruits[slow - <span class="number">1</span>] == second) slow--;</span><br><span class="line">                length = <span class="built_in">max</span>(fast - slow + <span class="number">1</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>别看有两个while时间复杂度实际上是$O(n)$，时间复杂度主要还是看操作次数。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础，C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第六节|计网最高层</title>
      <link href="/2022/07/30/internet06/"/>
      <url>/2022/07/30/internet06/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>同学们，达到计网最高层了嗷</p><span id="more"></span><h2 id="应用层的两种方式"><a href="#应用层的两种方式" class="headerlink" title="应用层的两种方式"></a>应用层的两种方式</h2><h3 id="P2P方式"><a href="#P2P方式" class="headerlink" title="P2P方式"></a>P2P方式</h3><ul><li>对等方式，没有固定的服务请求者和服务提供者</li><li>服务分散型</li><li>可扩展性，系统新能不会因为规模的增大而降低</li><li>具有成本上的优势</li></ul><h3 id="c-s客户服务器方式"><a href="#c-s客户服务器方式" class="headerlink" title="c/s客户服务器方式"></a>c/s客户服务器方式</h3><ul><li><p>有明确的服务请求方，和服务提供方</p></li><li><p>服务器总是处于运行状态，等待客户的服务请求</p></li><li><p>服务集中型的</p></li><li><p>尝会出现服务器计算机跟不上众多客户机的请求情况</p></li><li><p>常用计算机群集，或者服务器场，构建一个强大的虚拟服务器</p></li></ul><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>DHCP作为应用层协议，使用的是客户/服务器方式，使用UDP提供的服务</p><p>作用是：动态的分配网络配置，不需要手动操作配置主机</p><p>DHCP UDP 端口67 </p><p>DHCP客户 UDP 端口68 UDP用户数据报</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><ol><li>主机，也就是DHCP客户，启动DHCP客户进程，广播发送一个DHCP DISCOVER（dhcp discover)报文DHCP发现报文，该报文主要包含<ol><li>事务ID</li><li>MAC地址</li><li>原地址0.0.0.0</li></ol></li><li>DHCP服务器收到该广播地址，根据其MAC地址，查找数据库找对应配置信息，没有就默认发送广播报文：DHCP OFFER（dhcp offer）DHCP提供服务<ol><li>事务ID：判断是否自己请求的报文</li><li>源地址</li><li>配置信息<ol><li>IP地址：ARP协议判断IP地址没有被占用</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li></ol></li></ol></li><li>DHCP客户收到DHCP OFFER，转而广播一个DHCP REQUERST（dhcp request)，请求DCHP的服务确认<ol><li>事务ID</li><li>请求的地址租期</li><li>mac地址</li><li>等等</li></ol></li><li>DHCP服务器收到后根据事务ID嗯，OK也回复一个广播表示认可DHCP ACK报文</li><li>当DHCP客户收到这个DHCP报文后，先ARP检测自己分配到的地址是否已被占用，若果被占用，就恢复一个谢绝报文DHCP DECLINE 撤销IP地址足月，重新再发送DHCP DISCOVER</li></ol><p>至此，DHCP客户可以使用该网络配置接入互联网</p><p>接下来的就是续约操作和解约释放由下图所示</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730114325137.png" alt=""></p><p>DHCP服务器总不能啊每一个网络都整一个</p><p>然后就有了DHCP中继代理的概念</p><h4 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730114705398.png" alt=""></p><p>给一个网络的路由器配置DHCP服务器的IP地址，使该路由器成为DHCP与主机的桥梁.</p><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>（Domain Name System）</p><p>域名更便于记忆</p><p>主机里也有个高速缓存寻找域名地址对应的IP地址</p><p>如果没有就想DNS请求解析</p><p>DNS基于UDP提供的服务 端口53</p><h4 id="因特网采用层次树状结构的域名结构"><a href="#因特网采用层次树状结构的域名结构" class="headerlink" title="因特网采用层次树状结构的域名结构"></a>因特网采用层次树状结构的域名结构</h4><p>最右是顶级域名</p><ul><li>国家顶级nTLD</li><li>通用顶级gTLD</li><li>反向域arpa</li></ul><p>我国将二级域名划分两类</p><ul><li>类别域名</li><li>行政区取名</li></ul><p>次级域名</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730122442883.png" alt=""></p><p>这四类都分布在世界各地，构成的服务器群集。</p><p>域名服务器四类</p><ul><li>根域名服务器<ul><li>最高层次的域名服务器，记录所有的顶级域名及其IP地址，Internet有13个不同IP地址的根域名服务器群集，通常不直接域名进行解析，而是返回该域名所属域名的顶级域名服务器的IP地址</li></ul></li><li>顶级域名服务器<ul><li>负责管理顶级域名服务器注册的所有二级域名，收到DNS查询请求，有可能直接返回ip地址，也有可能返回下一集权限域名服务器的IP地址</li></ul></li><li>权限域名服务器<ul><li>负责管理某个区的域名，每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道器管辖的域名与IP地址映射关系，同样的知道下级域名服务器的地址</li></ul></li><li>本地域名服务器<ul><li>不会超过几个路由器的距离</li></ul></li></ul><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730164846918.png" alt=""></p><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730164917730.png" alt=""></p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><ul><li>为了提高DNS的查询效率，减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛的使用了 <strong>高速 缓存</strong>，高水缓存用来存放查询过的域名以及从何出获得域名映射信息的记录</li><li>高速缓存在主机和服务器都有，其中存在的项目一般存在两天，设定一个新的合理的值</li></ul><h2 id="FTP文件传送协议"><a href="#FTP文件传送协议" class="headerlink" title="FTP文件传送协议"></a>FTP文件传送协议</h2><p>基于TCP协议的 文件传输 </p><p>传送控制命令的TCP连接监听端口号21，会话期间一致保持打开</p><p>用于传送数据的TCP连接端口号20，使用开启，结束关闭</p><h4 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><ul><li>主动模式</li></ul><p>客户随机的端口号与服务器的21端口建立连接，控制命令</p><p>刚客户端主命令请求，并告知一个随机端口号，FTP服务器收到后主动将20端口与客户端该随机端口号建立连接</p><ul><li>被动方式</li></ul><p>与主动连接稍微不同的是，客户端发送命令，服务器需要先开启某个临时端口被动等待客户端另一个临时的端口号进行TCP连接</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730171105202.png" alt=""></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="STMP与POP3协议"><a href="#STMP与POP3协议" class="headerlink" title="STMP与POP3协议"></a>STMP与POP3协议</h3><p>实际上就是邮件发送与邮件读取协议</p><h4 id="SMTP简单邮件传送协议"><a href="#SMTP简单邮件传送协议" class="headerlink" title="SMTP简单邮件传送协议"></a>SMTP简单邮件传送协议</h4><p>基于TCP协议 25端口号</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>跟实际的邮件没有什么区别，只不过道路换成了了网络中的各种信道，连通路，信件成了数据</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730175311749.png" alt=""></p><p>电子邮件的信息格式不是由SMTP定义的，而是在RFC 822中单独定义的，首部和主体两部分构成</p><p>只能传送ASCII文本数据</p><p>为了解决SMTP进行传送中文，图片等多种</p><p>因此提出了MIME</p><p>多用途因特网邮件扩展</p><p>（multipurpose internet mail extensions)</p><ul><li>增加了5个新的邮件首部字段，这些字段提供有关文件主体的信息。</li><li>定义了许多有邮件内容的格式，对多媒体电子邮件的表示进行了标准化</li><li>定义了传送编码，可对任何内容格式进行转换</li></ul><p>实际上就是将非ASCII的文本的数据，转换为ASCII在传送</p><p>接收方读取内容同时也是需要MIME进行解析。</p><p>MIME不仅用于SMTP，也通榆面向ASCII字符的HTTP</p><h2 id="常用的读取协议"><a href="#常用的读取协议" class="headerlink" title="常用的读取协议"></a>常用的读取协议</h2><h3 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h3><ul><li>邮局协议（Post office protocol),pop3是第三个版本</li><li>简单功能有限</li><li>只能下载并删除 或者 下载并保留的方式从邮件服务器下载邮件到用户方计算机。</li><li>不允许用户在邮件服务器上管理自己的邮件。</li><li>采用TCP C/S 端口110</li><li>安装用户代理程序</li></ul><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><ul><li>因特网邮件访问协议IMAP（Internet Message Access Protocol),IMAP4是第四个版本，目前只是因特网的建议标准</li><li>功能比POP3强大，用户可以在自己计算机上可 以操控邮件服务器中的邮箱，跟本体操控一样。因此IMAP也是一个联机协议</li><li>采用TCP C/S 端口143</li><li>安装用户代理程序</li></ul><h4 id="基于万维网的邮件"><a href="#基于万维网的邮件" class="headerlink" title="基于万维网的邮件"></a>基于万维网的邮件</h4><ul><li>浏览器登录</li><li>不需要下载到本地管理，工作模式与IMAP类似</li></ul><p>​    </p><h2 id="www"><a href="#www" class="headerlink" title="www"></a>www</h2><p>World  Wide Web<strong>,不是特定的网络</strong>,是个大规模的，联机式的信息储藏所，<strong>是一个运行在因特网上 的一个分布式应用</strong></p><p>浏览器对网页内容基于渲染引擎进行解析显示</p><h3 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure><p>http端口默认为80,可以不显示</p><p>以下详情可以移步前端分类文章：</p><p>HTML：网页结构内容</p><p>CSS：层叠样式</p><p>JavaScipt：脚本语言控制网页行为</p><p>部署在服务器端传输给浏览器进行渲染</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议（HyperText Transfer Protocol)</p><p>定义浏览器怎么向服务器</p><ul><li>HTTP/1.0版本<strong>只能**</strong>非持续链接**，请求一个文件都需要与服务器建立TCP连接，收到响应立即关闭连接，听浪费时间的，假设建立多个TCP连接请求多个对象，又太浪费服务器资源</li><li>HTTP/1.1 <strong>可以</strong>采用<strong>持续连接</strong>的方式，在该方式下，万维忘服务器在发送响应请求依旧保持这条链接，所以现在大部分都是HTTP/1.1版本，实现更好的交互效果<ul><li>进一步提高效率，使用流水线方式，收到下一个响应报文之前就可以连续发送多个请求报文，同时服务器也就会发回一个接一个的响应报文，节省很多RTT时间.</li></ul></li></ul><h3 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h3><p>面向文本，每一个字段都是ASCII码串，每个字段长度都是不确定的（</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>眼熟么，就是请求头</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730191036914.png" alt=""></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/home/icrad/.config/Typora/typora-user-images/image-20220730191109693.png" alt=""></p><h4 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730191127839.png" alt=""></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730191405387.png" alt=""></p><p>经典状态码就是404 短语：Not Found</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用cookie在服务器上记录用户信息</p><p>第一次HTTP请求报文中没有携带cookie</p><p>服务器收到后生成唯一的cookie，并且以此为索引在服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息</p><p>服务器的HTTP响应报文中就携带了该cookie  在首部字段中Set-Cookie</p><p>客户端从得到的报文中读取Cookie保存，再下一次访问时的请求报文就携带上了cookie</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730192422176.png" alt=""></p><h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><ul><li>在万维网中还可以使用缓存机制提高万维网的效率</li><li>万维网缓存又称为<strong>Web缓存</strong>（Web cache)，可位于客户机，也可位于中间系统上，位于中间系统上的web 缓存又称为<strong>代理服务器</strong>（Proxy Server)</li><li>web缓存吧一些请求和响应暂存在本地磁盘中，当新请求到达时，就烦一会暂存响应，而不是再次根据URL再次访问资源。</li></ul><p>假设原始服务器的文档更改，代理服务器中的副本没有更改，如果直接请求怎么说？会不会拿到旧的文档呢？</p><p>首先知道源主机向代理服务器发送响应时会给该响应设定一个有效日期。（人为设定）</p><p>答案是： 8会，你猜猜文件为什么会有创建日期和修改日期捏？主机用户请求时，<strong>没有过期</strong>还是直接发回响应，假设有效日期<strong>过期了</strong>：代理服务器将会询问源主机响应是否发生改变，假设修改日期的不同，源主机会返回最新的响应给代理服务器，代理服务器再将该文档封装报文发给请求的主机。如果相同，源主机就会回复一个响应报文状态码为304 Not Modified</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730193949043.png" alt=""></p><h2 id="补充：HTTPS"><a href="#补充：HTTPS" class="headerlink" title="补充：HTTPS"></a>补充：HTTPS</h2><p>实际上可以这么理解</p><p>是HTTP Secure （安全加强版）</p><p>全称为Hypertext Transfer Protocol over Secure Socket Layer</p><p><strong>在原有的HTTP下加入SSL层在（HTTP与TCP之间） </strong></p><p><strong>使HTTP明文传输变成加密传输</strong></p><p><strong>端口是443</strong></p><p>之前有说过纯HTML是无状态的，加入SSL 就不一样了是有特定状态的响应，</p><p>提供了身份验证与加密通讯方法。</p><p><strong>https协议需要到ca申请证书，一般免费证书很少，需要交费。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第五节|运输层</title>
      <link href="/2022/07/28/Internet05/"/>
      <url>/2022/07/28/Internet05/</url>
      
        <content type="html"><![CDATA[<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>物理层，数据链路层 ，网络层，实现了主机到主机的通信</p><p>但实际上，通信的真正实体其实是通信进程</p><span id="more"></span><p>P2P（端到端）运输层的协议</p><h3 id="两种主要协议"><a href="#两种主要协议" class="headerlink" title="两种主要协议"></a>两种主要协议</h3><p>面向链接的TCP</p><p>无连接的UDP</p><h3 id="AP（Applications-Process）"><a href="#AP（Applications-Process）" class="headerlink" title="AP（Applications Process）"></a>AP（Applications Process）</h3><p>由于因特网上会出现不同的操作系统，不同格式的进程标识符，就需要统一的方法对TCP/IP体系的应用进程进行标识</p><h3 id="端口-Port"><a href="#端口-Port" class="headerlink" title="端口(Port)"></a>端口(Port)</h3><p>实际上是区分应用进程的标识符(PID)，并不是物理端口</p><h3 id="端口号（PID）"><a href="#端口号（PID）" class="headerlink" title="端口号（PID）"></a>端口号（PID）</h3><p>TCP/IP体系的运输层使用端口号来区分应用层不同的应用进程</p><ul><li>16比特表示，取值为0~65535</li><li>熟知端口号：0~1023,IANA把这些端口号指派给TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20，HTTP适用80，DNS使用53.</li><li>登记端口号：1024~49151,为没有熟知的端口号使用，这类端口号必须在IANA按照规定的手续登记，以防止重复，例如：Microsft RDP微软远程桌面使用的端口3389。</li><li>短暂端口号：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文是，就知道客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul><h3 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h3><h4 id="发送方的复用"><a href="#发送方的复用" class="headerlink" title="发送方的复用"></a>发送方的复用</h4><p>应用报文根据所选的<strong>端口号</strong>判断是<strong>UDP协议进行复用</strong>封装成<strong>用户数据报</strong>。</p><p>同上，应用报文根据所选的端口号判断是<strong>TCP进行复用</strong>封装成报文段。</p><p>无论是数据报，还是报文段，都封装为IP数据报（协议字段不同），这个操作称为IP复用</p><p>最后发送给接收方</p><h4 id="接收方的分用"><a href="#接收方的分用" class="headerlink" title="接收方的分用"></a>接收方的分用</h4><p>接收方对IP数据报进行解析，根据协议字段，分别解析出用户数据报和报文段，分别进行UDP分用，TCP分用，再通过端口号解析为应用报文传递给上层</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727092643417.png" alt="image-20220727092643417"></p><h4 id="常见的熟知端口号"><a href="#常见的熟知端口号" class="headerlink" title="常见的熟知端口号"></a>常见的熟知端口号</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727093153322.png" alt="image-20220727093153322"></p><h3 id="UDP与TCP"><a href="#UDP与TCP" class="headerlink" title="UDP与TCP"></a>UDP与TCP</h3><h4 id="用户数据报协议UDP（User-Datagram-Protocol"><a href="#用户数据报协议UDP（User-Datagram-Protocol" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol)"></a>用户数据报协议UDP（User Datagram Protocol)</h4><ul><li><p>可以随时发送数据</p></li><li><p>无连接，支持一对一，一对多，一对全的通信</p></li><li><p>面向应用报文</p></li><li><p>提供的也是无连接不可靠的服务，仅仅丢弃数据报，不做任何处理，尽最大努力交付，无流量控制和拥塞控制</p></li><li><p>UDP数据报首部格式</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727102339647.png" alt=""></p></li></ul><h4 id="传输控制协议TCP-Transmission-Control-Protocol"><a href="#传输控制协议TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议TCP (Transmission Control Protocol)"></a>传输控制协议TCP (Transmission Control Protocol)</h4><ul><li>必须使用三报文握手建立连接</li><li>必须使用四报文挥手释放连接</li><li>面向连接，仅支持单播：一对一的通信</li><li>面向字节流（数据流），不保证大小关系对应，实现可靠传输的基础</li><li>提供的事面向连接的可靠传输服务，使用流量控制和拥塞控制</li><li>TCP数据报格式</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727102410486.png" alt=""></p><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>为了保证可靠的传输，控制数据的发送速率的操作被称为流量控制</p><p>关键点：</p><ul><li><p>seq是数据的序号字段</p></li><li><p>原理实际上跟SR有点相似</p></li><li>也有发送窗口和接受窗口，但是也有GBN的累计确认。</li><li>流量控制的是接受窗口，接受窗口控制的接受多少数据，而接受窗口的大小呢由接受端的数据缓存大小决定</li><li>发送窗口随着接受窗口进行变化，接受方告诉发送方接受窗口的大小，发送方保持发送窗口大小跟接受窗口一致</li></ul><p><strong>例子如下：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727113757304.png" alt=""></p><p>出现死锁的局面：<br><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727114358434.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727120356308.png" alt=""></p><h4 id="通俗的语言来解释TCP的流量控制（小作文了属于是）"><a href="#通俗的语言来解释TCP的流量控制（小作文了属于是）" class="headerlink" title="通俗的语言来解释TCP的流量控制（小作文了属于是）"></a>通俗的语言来解释TCP的流量控制（小作文了属于是）</h4><ol><li>A有16个神奇的苹果（报文段），B的袋子可以放4个苹果（这苹果的神奇之处在于，递出去之后，必须要知道是否接受到才会彻底消失，<del>薛定谔的苹果</del>）</li><li>A问B一次袋子能装多少个，B回答4个（接收窗口）</li><li>A就连续的给B递4个苹果，并给每个苹果标上序号，可是当B放第3个时，把袋子撑破了，第3苹果掉在了地上烂了（<strong>报文段丢失</strong>）</li><li><strong>B就先拿回家处理了一下（流量控制），把接受到的苹果们放入了冰箱，发现袋子只能放3个苹果了</strong>，这时，B告诉A，现在我的袋子只能装3个了，并且第三个苹果烂了且<strong>只拿到前两个苹果</strong></li><li>B表示知道了，与此同时A这里的确认收到的苹果彻底消失了，从之前没消失的第三个（就是内个摔烂的没有确认收到的苹果）开始连续的给B递3个苹果，此时序号也从第三个开始，递完之后，A等待B告诉是否收到的信息（<strong>设定计时器</strong>）</li><li>B接过了所有的苹果，但是，突然大脑呆滞阿巴阿巴，忘记给A回复了，也忘记回家放苹果了（<strong>累计确认报文丢失</strong>）</li><li>A只好再次把之前的苹果们 的<strong>第一个苹果</strong>传递给B（<strong>超时重传</strong>），再次进行等待</li><li>B收到了重新传送的苹果，发现重复了序号3的苹果，就把重复的丢弃给A回复了，这个时候发现拿三个回家，原本应该拿四个的才对，却想越气，<strong>决定再空出一只手再拿一个苹果</strong>。这时，B回复A都收到了这三个苹果，<strong>并且表示我还能再拿一个（流量控制）</strong></li><li>A知道后表示ok,之前的三个消失了，从最新的一个开始拿，想起来B说还能再拿一个，就只递给B一个，然后等待B回复是否收到，<strong>B表示额外的一个已经把B塞满了，就先别递了（再次流量控制），</strong>A说OK，等你回复什么时候再给你递</li><li>B回家放苹果，当把袋子里的都放好，想起来手上还有一个苹果，也放好了，干脆再重新拿个袋子，顺带告诉A我又可以拿3个苹果了（发现之前袋子实际上装不了4个，最多装三个）</li><li>A啊等啊等，迟迟等不到B给他回信息，为啥呢，发现了 B回的信息A没看见（不要在意为啥看不见，问就是<strong>ACK丢失</strong>），因为A不知道B到底能不能拿，就再也没有递苹果。（但是在心里暗自决定再等10s）（<strong>持续计时器</strong>）</li><li>B呢以为A知道了可以递苹果了，在傻傻的等（无计时器），实际上却是：两边都在等，出现了死锁局面</li><li>这样的局面怎么打破呢？A还是等不下去了（<strong>计时器超时</strong>），向B打了一个问号 “?” （<strong>一个字节的0窗口探测报文</strong>）</li><li>B说啊，我现在可以拿3个，A表示OK，就开始向B就递苹果了，就<strong>打破了这个死锁的情况</strong><ul><li>假设：B这会打LOL，回复还是拿不了，A只能行叭，只好等一段时间就向B 打个问号 “?” 。（每收到一个0,就启动持续计时器）</li><li>再假设：这个B玩的亚索0-17，队友也一直再给他打问号，B没发现A给打的问号，也就没有给A回复，那么这种情况，A的也是有忍耐时间的（<strong>0窗口探测报文的计数器</strong>），见到B还没有回复，就再打个问号（<strong>超时重传</strong>）</li></ul></li></ol><p><strong>注意，以上情况没有考虑出现拥塞控制</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727121632253.png" alt=""></p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>四个字，供不应需</p><p>需求远远超过已有资源就会出现拥塞，若不进行控制，整个网络的<strong>吞吐量</strong>将随着输入的负荷<strong>增大而下降</strong>，降为0就进入<strong>死锁</strong>状态</p><p>需要进行需求控制，也被称为拥塞控制，是相当有必要的</p><h4 id="四种拥塞算法"><a href="#四种拥塞算法" class="headerlink" title="四种拥塞算法"></a>四种拥塞算法</h4><p>发送方维护一个拥塞窗口cwnd,取决于网络的拥塞程度，并且<strong>动态变化</strong></p><p>拥塞判断的依据是，发生超时重传</p><p>发送方将拥塞窗口作为发送窗口swnd，</p><p>发送方维护这一个慢开始门限ssthresh状态变量：</p><ul><li>当cwnd&lt;ss thresh,使用慢开始算法</li><li>当cwnd&gt;ss thresh,停止使用慢开始算法该用拥塞避免算法</li><li>当cwnd=ss thresh ,即可以使用慢开始算法，也可以使用拥塞避免算法</li></ul><p>(TCP Tahoe)</p><ul><li><p>慢开始(slow-start)</p><ul><li>拥塞窗口值按照指数规律增长，按传播轮次</li></ul></li><li><p>拥塞避免(congestion avoidance)</p><ul><li>拥塞窗口值线性+1，按传播轮次</li><li>假设出现拥塞，将ss thresh值更新为发生拥塞时cwnd的一半，cwnd回到默认值，重新开始执行按开始算法</li></ul></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728100559097.png" alt=""></p><p>当出现超时重传时不一定会出现拥塞，如果直接判断产生拥塞，cwnd就会回到默认值重新开始，那么会极大的降低传输效率，为了提升TCP性能，引入了新的拥塞控制算法（TCP Reno）</p><ul><li>快重传(fast retransmit)<ul><li>使发送方尽快进行重传，而不是等超时重传计时器超时再重传，目的是为了让发送方尽早知道发生了个别报文端的丢失</li><li>出现丢失，发送方依旧不管不顾的继续发送，在超时重传计时器还没超时之前，每接收到一个报文，接收方会提醒一次我接受到了一个，但是之前的丢的还没给我补发（重复的确认我只收到了丢失的前一个），发送方连续收到<strong>三次</strong>重复确认丢失之前一个的报文的确认，立刻重传丢失的报文，这就是<strong>快重传</strong></li></ul></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728101840094.png" alt=""></p><ul><li>快恢复(fast recovery)<ul><li>发送方一但收到三个重复确认，就知道只是丢失了个别的报文段，并不是出现拥塞，转而执行快恢复算法</li><li>发送方讲慢开始文献ssthresh 和拥塞窗口cwnd调整为当前窗口的一半，开始执行拥塞避免算法</li><li>也有的块恢复实现是把快恢复开始时的拥塞窗口cwnd再增大一些 至少加3<ul><li>既然发送方收到了三个重复的确认，说明有三个数据报文段已经离开了网络，不需要消耗资源，就可以增加拥塞窗口，尽可能扩大TCP的传输速率</li></ul></li></ul></li></ul><p>四者结合动态实现拥塞控制</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728102803073.png" alt=""></p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>这是TCP最复杂的问题之一</p><p>太小不行，会出现重复</p><p>太大，会浪费传输效率</p><p>而且，RTT  ，数据传输时间是受各层影响的</p><p>所以不能直接使用某次测量的RTT样本超时重传时间RTO</p><p>利用每次测量的到的RTT样本，计算加权平均往返时间RTT，计算一个平滑的往返时间</p><script type="math/tex; mode=display">RTT_{S1}=RTT_1</script><script type="math/tex; mode=display">新的RTT_s=(1-a)*旧的RTT_s+a*新的RTT样本</script><p>在上式中$0\leq a &lt; 1$:</p><ul><li>若很接近0,则新的$RTT$样本$RTT_S$影响不大；</li><li>若很接近1,则新的$RTT$样本$RTT_S$影响较大；</li></ul><p>建议标准的RFC6298推荐的值为1/8，即0.125.</p><ul><li>该方法得到的值就比测量的RTT的值更加平滑，因此超时重传的时间就应该略大于$RTT_S$</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728105335061.png" alt="image-20220728105335061"></p><p>即使如此，对于RTT样本的测量一样会出现很多问题</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728105544856.png" alt=""></p><p>出现以上情况会出现计算差错</p><p>对此，karn提出一个算法：出现报文段重传，就不采用这段往返时间RTT作为样本</p><p>但是这有引起了新的问题：实际传播的时延突然增大，并且不再减小，就会一直出现超时重传的情况，那么RTO就无法再进行更新，就会一直重复发送数据报文段</p><p>进而对Karn算法进行修正，加入报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是：将RTO的值取为旧值得两倍。</p><p>​    举例说明</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728110426058.png" alt=""></p><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><ul><li>字节为单位的滑动窗口来实现可靠传输</li><li>发送窗口，出现拥塞采用拥塞窗口cwnd，未出现拥塞采用接受窗口值rwnd</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728111043844.png" alt="image-20220728111043844"></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728112050879.png" alt=""></p><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><ul><li>建立TCP连接</li></ul><ol><li><p>TCP客户端和TCP服务端都处于CLOSED状态</p></li><li><p>TCP服务端需要建立一个传输控制块</p><ol><li><p>TCP连接表</p></li><li><p>指向发送和接受缓存的指针</p></li><li><p>当前发送和接收的序号</p><p>……</p></li><li><p>建立好之后准备接受TCP客户的连接请求进而变更状态为监听LISTEN状态（该状态也称为被动打开连接状态）</p></li></ol></li><li><p>TCP客户进程同样首先创建传输控制块</p><ol><li>TCP连接表</li><li>指向发送和接受缓存的指针</li><li>当前发送和接收的序号</li><li>…….</li><li>发送TCP连接请求并更行状态为SYN-SENT（同步已发送）（主动打开连接）发送<strong>第一个报文</strong>（该报文用来请求TCP服务器的SYN-RCVD同步状态</li><li><strong>来简单的说明这个报文：发送的是一个带着SYN标志的报文，该值为1,说明这个报文是专门用来请求连接建立的，seq=x,这个X其实可以为任意值，由客户决定，表示的是序号</strong></li></ol></li><li><p>TCP服务器收到了<strong>第一条请求报文</strong>，为了表示请求成功，状态变为<strong>SYN_RCVD</strong>，回应了<strong>第二条新的报文</strong> ：标志ack=x+1（序号+1,表示上一个序号为x的报文确认收到了,请求序号为x+1的报文段）SYN=1 同时也表示这是用来建立连接的报文，不能携带数据，ACK=1<strong>标志表示这是一个确认的报文</strong> seq=y(同理第一条报文段，这个值可以由服务端自由设定)</p></li><li><p>当TCP客户端收到第二条报文，根据报文表示没问题，变为<strong>连接建立状态</strong>，并且发送<strong>第三条报文端</strong>，：该报问段是普通报文段 <strong>没有SYN标志</strong>，ACK=1表明这个是用来确认服务器的状态，seq=x+1，是该报文段的序号，ack=y+1则表示请求下一条服务器报文段的序号</p></li><li><p><strong>TCP服务器收到第三条报文，明白了TCP客户端是想建立连接，将自己状态改为连接已建立状态。</strong></p></li></ol><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728114322618.png" alt=""></p><p>其中建立连接用了<strong>三个报文</strong>，因此被成为三报文握手</p><p>假说不进行确认同步状态，直接双方一起建立连接，去掉第三个报文，改为两报文建立连接，就会出现第一报文丢失重发导致已关闭的TCP服务器误开，浪费网络资源。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728145452314.png" alt=""></p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><ul><li><p><strong>释放TCP连接的过程</strong></p><p>小可：我要走了</p><p>过了一会</p><p>小符：你确定你要走吗</p><p>小符，思考了一会，再次问：</p><p>你真的确定你要走了么？</p><p>（这时可以扔一些小石头之类的（数据）给小可）</p><p>过了一会</p><p>小可：嗯</p><p>小符听到后，小声嘟囔着一句</p><p>​    笨蛋</p><p>,然后头也不回的走了</p><p>小可有点怅然若失。</p><p>等了一会，最后也走了</p><p>如图所示：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728171424738.png" alt=""></p><p><strong>急着下班的小可</strong>（如果少了最后一次握手）</p><p>小可最后回复时，一阵大风，</p><p>小符没有听到小可最后的回复</p><p>而且小可直接溜了，</p><p>小符一直等啊等，等小可的最后回答</p><p>每等一段就问，</p><p>你真的要回去了吗？</p><p>……</p><p>可是小可早就run了。</p><p>即使听到了什么也不再理踩。</p></li></ul><p>  如图所示</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728171343533.png" alt=""></p><ul><li><p><strong>不想活的小可</strong></p><p>小可突然不想活了，吊在大本钟下</p><p>小符等了一会，发现小可没有再说话</p><p>就每等一会问一次</p><p>你特么还活着么？</p><p>连续问了十次</p><p>小符知道了，</p><p>小可估计是寄了</p><p>小符走了。</p></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728172420036.png" alt=""></p><p><del>才，才不是因为想偷懒呢</del></p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><ul><li><p>面向字节流</p></li><li><p>发送缓存中一部分或者全部字节给其添加一个首部成为TCP报文段然后发送</p></li><li><p>一个TCP报文段由首部和数据载荷两部分构成</p></li><li><p>TCP的全部功能都体现在它首部中个字段的作用</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728173523044.png" alt=""></p></li><li><p>源端口，目的端口</p><ul><li>源端口：顾名思义，进程端口，协议进程的端口，主机自己设定的暂时端口等</li></ul></li><li><p>序号</p><ul><li>取值 32比特，循环的，当最后一个值加一，回到0重新继续加，数据载荷的第一个字节的序号</li></ul></li><li><p>确认号（ack），标志位(ACK/URG/PSH/RST/SYN/FIN)</p><ul><li>确认号取值 32比特，循环的，当最后一个值加一，回到0重新继续加，搭配确认标志号ACK取值为1时才生效</li><li>TCP协议其实有规定，在建立连接后，ACK都必须为1</li><li>ack表示请求序号的下一个，并且表明我已经收到了之前的全部数据</li><li>标志位：(URG/ACK/PSH/RST/SYN/FIN)：表明报文段类型<ul><li>RST复位，表示TCP连接异常，必须释放连接，再重新建立，也可以拒绝非法报文段，禁止打开一个TCP连接</li><li>PSH推送，尽快上交，不用等待发送缓存</li><li>URG紧急标志，与紧急指针搭配，1生效，0无效</li></ul></li></ul></li><li><p>数据偏移，保留，窗口</p><ul><li>数据偏移：占4个比特，表示数据载荷部分起始处距离报文段起始的值，<strong>以四个字节为单位</strong></li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728175151668.png" alt=""></li><li>保留：占6比特，默认为0；</li><li>窗口：占16比特，就是发送本报文段的一方的接收窗口</li></ul></li><li><p>校验和，紧急指针</p><ul><li>检验和：一种检错的数据</li><li>紧急指针与标志位搭配，指明出紧急的数据载荷部分长度，VIP指针，也不用排队上交给应用层</li></ul></li><li><p>选项（可选）</p><ul><li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度</li><li>窗口扩大选项：扩大窗口，提高吞吐</li><li>时间戳选项<ul><li>计算往返时间RTT</li><li>处理序号超过范围的情况，防止序号绕回</li></ul></li><li>选择确认选项：选择确认功能</li></ul></li><li><p>填充</p><ul><li>用来保证首部能被4整除</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这部分还挺简单的，接下来就即将到达计网最高层了捏</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 运输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第四节|网络层</title>
      <link href="/2022/07/25/internet04/"/>
      <url>/2022/07/25/internet04/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层-重点掌握"><a href="#网络层-重点掌握" class="headerlink" title="网络层(重点掌握)"></a>网络层(重点掌握)</h1><p>网络层的任务</p><p>实现网络互连，进而实现数据包在各网络之间传输</p><p>网络层需要解决的问题</p><ul><li>提供运输层的服务</li><li>网络层寻址</li><li>路由选择问题</li></ul><span id="more"></span><p>因特网（Internet）使用的是TCP/IP协议栈</p><p><strong>网络层</strong>也常被称为<strong>网际层</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723081216440.png" alt=""></p><h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><ul><li><p>必须建立网络层连接 虚电路VC（Virtual Circuit)</p></li><li><p>可靠性由网络来保证</p></li><li><p>分组按序，走虚电路到达</p></li><li>在通信结束需要释放之前建立的虚电路</li></ul><h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><ul><li><p>可靠通行应当由用户主机来保证</p></li><li><p>不需要建立网络层连接</p></li><li>首部必须携带目的主机的完整地址</li><li>可以走不同的路由</li><li>容易出现误码，乱序等问题</li></ul><p>在TCP/IP全栈体系中</p><p>网际层提供的<strong>简单灵活的</strong>，<strong>无连接的</strong>，<strong>尽最大努力交付</strong>的<strong>数据报</strong>服务</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h3><p>全世界范围内唯一的 32比特的标识符（每一台主机或路由器的每一个接口）</p><p>IP地址由因特网名字和数字分配机构ICANN进行分配</p><ul><li>2011 IANA（互联网号码分配管理局）宣布IPv4分配完毕</li><li>2014~2015 我国逐渐停止分配IPv4,同时开始全面部署IPv6</li></ul><p>这里由时间发展，解释IPv4的编址方法的三个历史阶段</p><ol><li>1981年 <strong>分类编址</strong></li><li>1985年 <strong>划分子网</strong></li><li>1993年  <strong>无分类编址</strong></li></ol><h3 id="IPV4表示"><a href="#IPV4表示" class="headerlink" title="IPV4表示"></a>IPV4表示</h3><p>32位的IPv4地址采用点分十进制的表示方法</p><p>每八个比特分为一组，每组的十进制数，用点来分隔</p><p>快速计算</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723085508368.png" alt=""></p><p>凑值法</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723085734030.png" alt=""></p><h3 id="IPV6地址"><a href="#IPV6地址" class="headerlink" title="IPV6地址"></a>IPV6地址</h3><p>是IPv432位地址4倍长度，一样用的是CIDR记法</p><ul><li>扩展了路由和寻址的能力</li><li>报头格式的简化</li><li>对可选项更大的支持</li><li>身份验证和保密</li><li>支持无状态自动地址配置</li></ul><h2 id="编址阶段"><a href="#编址阶段" class="headerlink" title="编址阶段"></a>编址阶段</h2><h3 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h3><p>分出了五类依次按照ABCDE排序</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723090501132.png" alt=""></p><p>注意</p><ul><li>ABC可以分配给网络中的主机或路由器的各接口</li><li>主机号全为0的是网络地址，不能分配</li><li>主机号全为1的事广播地址，不能分配</li></ul><p><strong>A类</strong></p><ul><li><p>网络号全为0<strong>：最小网络号</strong>,<strong>保留不指派</strong></p><p>可指派的网络号起始为00000001</p></li><li><p><strong>最大网络号为</strong>：01111111， 为<strong>本地环回测试地址</strong>，<strong>不指派</strong></p><p>最小的本地环回测试地址为127.0.0.1</p><p>最大的本地环回测试地址为127.255.255.254</p></li></ul><p>所以可分配的范围为1~126，每个网络号的最大主机数：$2^{24}-2$</p><p>​    注意0.0.0.0只能最为源地址使用</p><p><strong>B类</strong></p><ul><li><p>最小网络号全为 0 ，也是<strong>第一个可指派</strong>的网络号，128.0<br>网络地址为128.0.0.0（给荷兰用的)</p></li><li><p>最大网络号也是最后一个可指派的网络号 ，191.255</p><p>网络地址为191.255.0.0</p><p>所以可分配的范围为1~126，每个网络号的最大主机数：$2^{16}-2$</p></li></ul><p><strong>C类</strong></p><ul><li>最小网络号192.0.0.0 ，也<strong>是可以指派的网络号</strong></li><li>最大网络号223.255.255.0</li></ul><p>所以可分配的范围为1~126，每个网络号的最大主机数：$2^{8}-2$</p><p><strong>特殊的ip地址：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723101245507.png" alt=""></p><p><strong>注意：两台路由器通过链路直连也是一个网络，也需要分配IP给各个端口。</strong></p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>网络号申请得花钱。开销还很大，浪费原有网络号中剩余的主机号地址</p><p>那我在主机号中再划分各个子网，就充分利用了网络资源</p><ul><li>利用子网掩网使用连续的比特1来对应网络号和子网号</li><li>连续的的比特0；来对应主机号</li></ul><p>子网掩码将原有的耳机结构划分为了三级结构：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723102824555.png" alt=""></p><p>划分细节示例：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723102527353.png" alt=""></p><p>一个比特相当于将IP再次划分了两部分，子网0和子网1</p><p>同时子网0和子网1同时也有自己的广播地址和最小网络地址。</p><p>例题：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723103701163.png" alt=""></p><p><strong>注意事项：</strong></p><ul><li>在确定子网掩码时需要先确定网络类型，根据<strong>网络类型网络号</strong>确认<strong>默认子网掩码</strong></li></ul><h3 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a><strong>无分类编址</strong></h3><p>虽然划分了子网呢一定程度上解决些问题，但还是8太顶用，因为主机号与网络号不成正比。</p><p>CIDR（无分类的域间路由选择）</p><p>CIDR消除了传统的A类B类和C类地址,以及划分子网的概念</p><p>CIDR使用“斜线记法”，即在IPv4地址后面加上/  数字代表网络前缀占用数量</p><p>示例：  </p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723112642980.png" alt=""></p><h4 id="路由聚合（超网"><a href="#路由聚合（超网" class="headerlink" title="路由聚合（超网)"></a>路由聚合（超网)</h4><p>用来节省路由器中的路由表的占用，所以就叫做路由聚合。</p><p>将多个目的网络聚合在一个地址块。</p><p>聚合出来的地址块就称为聚合地址块</p><p><strong>聚合地址块</strong>根据 <strong>所有的目的地址的共同前缀</strong> ：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723113352483.png" alt="image-20220723113352483"></p><p><strong>聚合得到的地址块</strong>即为：172.1.4.0/22</p><p><strong>网络前缀越长，地址块越小，路由就越具体</strong></p><p>当路由器查表转发分组的时候就会发现又有多条路由可选，就会选择网络前缀最长的那条，被称为<strong>最长前缀匹配。</strong></p><h3 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h3><h4 id="定长子网掩码划分（FLSM）"><a href="#定长子网掩码划分（FLSM）" class="headerlink" title="定长子网掩码划分（FLSM）"></a>定长子网掩码划分（FLSM）</h4><p>上面的子网掩码实际上都归类为地场子网划分，只能划分2的n次方的子网（n是子网比特数)，但只要划分9个子网时，很有可能造成资源浪费，比如定长子网掩码 只能划分16个子网，就造成极大浪费</p><h4 id="变长子网掩码划分（VLSM）"><a href="#变长子网掩码划分（VLSM）" class="headerlink" title="变长子网掩码划分（VLSM）"></a>变长子网掩码划分（VLSM）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723174229568.png" alt=""></p><p>按需分配：</p><p>分配原则选分配地址数量最多的网络开始</p><p>尽可能减少了浪费，在不添加主机的情况下还是又一点点浪费</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723181943846.png" alt=""></p><h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><h4 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a><strong>IPv4数据报的首部格式</strong></h4><p>实现iP协议的基础</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726120944091.png" alt=""></p><ul><li><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul><li>半个字节（字段）4位，通信双方协议版本必须一致，一般记为4（IPv4)</li></ul></li><li><h4 id="首部长度"><a href="#首部长度" class="headerlink" title="首部长度"></a>首部长度</h4><ul><li>同占4位，表示该IP数据报的首部的长度，改字段的取值是以4字节为单位，最小值为5（十进制，即20个字节），最大为15（同理，为60字节） </li></ul></li><li><h4 id="可选字段"><a href="#可选字段" class="headerlink" title="可选字段"></a>可选字段</h4><ul><li>可选字段，1~40个子接，用来支持拍错，测量及安全等措施，但是很少用</li></ul></li><li><h4 id="填充字段"><a href="#填充字段" class="headerlink" title="填充字段"></a>填充字段</h4><ul><li>确保首部长度字段为4字节的整数倍</li></ul></li><li><h4 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h4><ul><li>用来获得更好的服务，实际上没咋使用过。</li></ul></li><li><h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><ul><li>16个比特，顾名思义就是<strong>首部和数据载荷</strong>的长度</li><li>最大取值为十进制的65535,以字节为单位。</li></ul></li><li><h4 id="标识，标志，长偏移"><a href="#标识，标志，长偏移" class="headerlink" title="标识，标志，长偏移"></a><strong>标识，标志，长偏移</strong></h4><ul><li>作用是<strong>分片</strong> </li><li><strong>标识</strong>:占16比特，属于同一个数据报的各分片数据包应该具有相同的标识，并且IP软件维持一计数器，每产生一个数据报，计数器的值加1,并且将此值赋给标识字段</li><li><strong>标志</strong>：占3比特，DF位0表示可以切片，MF位0表示这是最后一个分片，保留位，必须为零</li><li><strong>片偏移</strong>：占13比特，值出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。（片偏移以8个字节为单位）</li><li><strong>分片示例</strong>（假设因特网最大数据载荷为1500）</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726151551784.png" alt=""></li><li>分片的分片同理</li></ul></li><li><h4 id="生存时间，协议，首部检验和"><a href="#生存时间，协议，首部检验和" class="headerlink" title="生存时间，协议，首部检验和"></a>生存时间，协议，首部检验和</h4><ul><li><strong>生存时间</strong>TTL：路由器在转发该IP数据报时，将IP数据报首部中该字段的值减去IP数据报在本路由器上所耗费的时间（减1），若不为0就转发，否则就丢弃（当前以 跳数 为单位）</li><li><strong>协议</strong> 占8比特，用来指明，IP数据报是啥协议的数据单元<ul><li>常见的协议字段值</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726153430858.png" alt=""></li></ul></li><li><strong>首部检验和</strong>：也被称为因特网检验和，检验首部传输过程中是否出现差错，每经过一个路由器都需要重新计算首部检验和，IPV6中不再计算首部检验和</li></ul></li></ul><h4 id="发送与转发"><a href="#发送与转发" class="headerlink" title="发送与转发"></a>发送与转发</h4><p><strong>主机发送</strong></p><p> 间接交付是指两个不同的子网（网关）下进行数据报的发送</p><p>需要进行路由器的转发，</p><p><strong>路由器转发</strong></p><p>指定的路由器就是常说的默认网关</p><p>路由表中：目的网络，地址掩码 ：下一跳路由器</p><ul><li><p>注意是目的网络，路由器根据所传入的IP数据报首部的目的地址</p></li><li><p>目的地址与地址掩码相与得到所要传递的目的网络（网段）</p></li><li>如果找不到就丢弃该IP数据报，并返回一个ICMP报文</li></ul><p>最基本的原理</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220724105703620.png" alt=""></p><p><strong>附加：</strong></p><p>路由器不转发广播P数据报（可以理解为由软件实现），三层解析</p><p>VLAN（虚拟局域网技术）这玩意是在物理层隔离个广播域，只有两层解析地址，因此隔离广播域还得用VLAN</p><h3 id="静态路由的配置"><a href="#静态路由的配置" class="headerlink" title="静态路由的配置"></a>静态路由的配置</h3><p>多个路由之间的数据报的传递，需要手动配置静态路由表</p><p>但是不能及时适应网络状态的变化（流量，拓扑）</p><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a><strong>默认路由</strong></h4><p>当包含众多网络时（比如接入互联网），总不能每个接口都给路由表配置一个</p><p>我们使用该默认路由0.0.0.0/0</p><p>默认接入该接口下的所有网络.</p><h4 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a><strong>特定主机路由</strong></h4><p>考虑安全问题时，路由器中添加一条特定主机的IP（CIDR）也可以访问</p><p>当同时存在默认路由和特定主机路由，最长前缀匹配</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725092852395.png" alt=""></p><h4 id="静态路由环路"><a href="#静态路由环路" class="headerlink" title="静态路由环路"></a><strong>静态路由环路</strong></h4><ul><li><strong>错误的配置：</strong></li></ul><p>路由容易引发路由环路错误</p><p>不过呢为防止IP数据报在路由环路中永久兜圈，在IP数据报首部都设有有生存时间的</p><p>TTL字段，该字段在进入路由器后TTL字段的值减1.弱TTL的值不等于0,责备路由器转发，否则丢弃</p><ul><li><strong>聚合不存在了不存在的网络：</strong></li></ul><p>聚合的概念：就是超网。</p><p>你指定的聚合网络块中，有一些是没有进行配置主机接入的网络，当有数据报转发到该不存在的网络时就会找不到,只能走默认路由，二默认路由的下一跳是原网络，就会出现路由环路的问题</p><p>所以我们为这些不存在的网络配置了一个黑洞路由</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725100340470.png" alt="image-20220725100340470"></p><ul><li><strong>网络故障</strong></li></ul><p>网络故障导致的路由条目进行删除，一样转发只能走默认路由，如果下一跳是源网络，又会出现路由环路的情况</p><p>所以我们为这些删除的，不存在的网络配置了一个黑洞路由（下一条为null0)。</p><p>当网络故障恢复好后，路由器会自动检测添加该网络接口，并将之前的人工配置的黑洞路由配置自动失效</p><p>，当又出现故障，就恢复生效状态</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725100819279.png" alt=""></p><h3 id="动态路由的选择"><a href="#动态路由的选择" class="headerlink" title="动态路由的选择"></a>动态路由的选择</h3><p>比较复杂，开销大，但是适应性好，适用于大规模网络</p><p>特点:</p><ul><li><h4 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h4><p>动态路由选择</p></li><li><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>路由之间交换路由信息</p></li><li><h4 id="分层次"><a href="#分层次" class="headerlink" title="分层次"></a>分层次</h4><p>整个因特网划分各个自治系统AS</p></li></ul><h4 id="分层次-1"><a href="#分层次-1" class="headerlink" title="分层次"></a>分层次</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725101430655.png" alt=""></p><ul><li><p>自治系统的之间的路由选择</p><p>使用的协议为外部网关协议EGP（只是名称，不是具体协议）</p><p>等同于ERP外部路由协议</p></li><li><p>自治系统内部的路由选择</p><p>使用的协议为内部网关协议EGP（只是名称，不是具体协议）</p><p>等同于IRP内部路由协议</p></li></ul><p>  以下是常见的路由选择协议：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725103011360.png" alt=""></p><h4 id="路由器的基本机构"><a href="#路由器的基本机构" class="headerlink" title="路由器的基本机构"></a>路由器的基本机构</h4><p>分为两部分：</p><ul><li><h4 id="路由选择部分"><a href="#路由选择部分" class="headerlink" title="路由选择部分"></a>路由选择部分</h4><ul><li>路由选择处理机：路由表</li></ul></li><li><h4 id="分组转发部分"><a href="#分组转发部分" class="headerlink" title="分组转发部分"></a>分组转发部分</h4><ul><li>一组端口（可以输入可以输出，下图分出来是为了方便理解）</li><li>交换结构：分组表</li><li>输入输出的缓冲区<ul><li>输出缓冲区暂存的是来不及处理发送的数据</li><li>输入缓冲区暂存的事来不及处理接受的数据</li></ul></li></ul><p><strong>注意</strong>：</p><p>路由表和分组表事分开的东西，为了方便理解，默认将路由表</p></li></ul><p>如图所示：<img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725103600937.png" alt=""></p><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><ul><li>内部网关协议IGP中最先得到广泛使用的协议之一</li><li>要求每一个路由器都维护从它到其他每一个网络的距离记录，称为<strong>距离向量</strong>（Distance-Vector)</li><li><strong>跳数</strong>（Hop Count)作为度量(Metirc)来衡量到达目的网络的距离<ul><li>路由器到直连网络的距离定义为1</li><li>到非直联网络的距离定义为所经过的路由器数+1</li><li>最多<strong>15</strong>个路由器，所以<strong>距离等于16时</strong>相当于<strong>不可达</strong></li></ul></li></ul><h4 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><ul><li>好的路由就是距离短的路由</li><li>同时又多条距离相等的路由是进行，<strong>等价负载均衡</strong><ul><li><strong>等价负载均衡</strong>：将通信数据等量平均的分布到多条等价的路由上</li></ul></li></ul><ul><li><strong>仅和相邻路由器周期性交换更新路由表</strong></li><li>若干次交换网络与更新，路由都记录了各网络的最短距离和下一跳地址，这个过程称为收敛</li></ul><h4 id="更新规则："><a href="#更新规则：" class="headerlink" title="更新规则："></a>更新规则：</h4><p>​    路由表的交换，传递，改造，更新</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725113709731.png" alt=""></p><h4 id="RIP的缺陷"><a href="#RIP的缺陷" class="headerlink" title="RIP的缺陷"></a>RIP的缺陷</h4><ul><li><p>坏消息传的慢</p><p>出现故障时，就会有可能出现路由环路的问题，如图所示</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725114803457.png" alt="image-20220725114803457"></p></li><li><p>坏消息 （故障的网络的信息）传得很慢</p><p>又被成为<strong>路由环路或无穷记数的问题</strong>：这是距离向量算法的一个固有问题</p><p>但是可以采取多种措施减小该问题出现的概率或者降低其带来的危害</p><ul><li>限制<strong>最大距离</strong>为15</li><li>当路由表发生变化<strong>立即发送</strong>更新报文，而不是周期发送</li><li><strong>水平分割</strong>：让路由器记录收到某特定路由信息的接口，而不让同意路由的信息再通过此接口反方向传送</li></ul></li></ul><p>​        <strong>注意：这些方法并不能消除问题，距离向量算法是这样的</strong></p><p><strong>缺少的内容</strong></p><p>RIP的报文格式</p><p>定时时常等</p><p>IPv4 的RIP有两个版本</p><p>IPv6 的RIPng</p><h3 id="开放式最短路径优先OSPF协议"><a href="#开放式最短路径优先OSPF协议" class="headerlink" title="开放式最短路径优先OSPF协议"></a>开放式最短路径优先OSPF协议</h3><p>克服RIP的缺点</p><ul><li>基于链路状态</li><li>采用SPF算法，原理上不会产生路由环路的问题</li><li>不限制网络规模，收敛速度快</li><li>链路的状态是指和那些路由器相邻，以及相应链路的代价（cost)<ul><li>代价用来表示链路时延距离带宽等等都行，由网络管理人员决定</li><li>思科路由器OSPF计算代价的方法：100Mbps/链路带宽</li></ul></li></ul><h4 id="基本工作原理-1"><a href="#基本工作原理-1" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><ul><li>发送问候（hello)分组,建立和维护邻居关系<ul><li>该分组封装在IP数据报中，发往组播地址224.0.0.5</li><li>发送周期为10秒</li><li>40秒未收到来自邻居路由器的hello分组，则认为该邻居路由不可达</li></ul></li><li>每个路由器都会产生链路状态通告LSA（Link State Advertisement).<ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul></li><li>每个路由器都有一个链路状态数据库LSDB，用来存储LSA</li><li>通过各个路由器泛洪发送封装自己的LSA的LSU分组，最终使个路由器的LSDB达到一致</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726110350726.png" alt=""></li><li>基于最短SPF算法得出最短路径。具体SPF算法请移步这篇文章：</li><li>OSPF有一下五种分组类型<ul><li>hello分组<ul><li>问问能不能到达</li></ul></li><li>数据库描述(<strong>D</strong>atabase <strong>D</strong>escription)<ul><li>发送自家的集合成的所有链路状态项目的摘要信息）</li></ul></li><li>链路状态请求（<strong>L</strong>ink <strong>S</strong>tate <strong>R</strong>equest）<ul><li>请求发送具体的详细信息</li></ul></li><li>链路状态更新（<strong>L</strong>ink <strong>S</strong>tate <strong>U</strong>pdate）<ul><li>路由器使用这种分组，发送链路状态进行洪泛发送，对全网更新链路状态</li></ul></li><li>链路状态确认（<strong>L</strong>ink <strong>S</strong>tate <strong>A</strong>ckonwledgment）<ul><li>确认更新链路状态的确认分组</li></ul></li></ul></li></ul><p><strong>基本工作过程如下图所示：</strong></p><p>​        <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726111842587.png" alt=""></p><ul><li>在多点接入网络中路由器邻居关系的建立<ul><li>选举 指定路由器DR，备选的 指定路由器BDR</li><li>所有的非DR/BDR只与DR/BDR建立邻居关系</li><li>非DR/BDR之间通过DR/BDR才能交换数据</li></ul></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726112314026.png" alt="image-20220726112314026"></p><p>​        </p><p>​    实现选举并不复杂，类似交换机的生成树协议STP，忘请回看上一章</p><p>为了进一步扩大网络规模，OSPF把一个自治系统再划分为诺干更小的范围 ，叫做区域Area</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726112849474.png" alt="image-20220726112849474"></p><p>划分区域的好处，就是区域内交换的信息量少了，能应用于更大规模的网络</p><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><ul><li><p>这不讲了两个内部主要的网关（路由）协议，就不得不讲讲EGP外部网关协议中的BGP边界网关协议了</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726113414469.png" alt=""></p></li><li><p>内部网关协议IGP</p><ul><li>只需要考虑自治系统内的网络，无需考虑外部的其他策略</li></ul></li><li><p>外部网关协议EGP</p><ul><li>因为不同的自治系统内，度量路由的代价cost可能不同，因此需要换个度量寻找最佳路由，但是没有统一的度量，找个最佳路由没有意义</li><li>而且，不同的自治系统可能代表着不同的国家（你懂的）必须考虑相关策略（注意策略并不是协议）</li></ul><p><strong>注意：这里我还是要提一嘴，IGP和EGP并不是具体协议</strong>，可以理解为类型</p></li></ul><h4 id="基本工作原理-2"><a href="#基本工作原理-2" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><p>基于以上考虑：</p><ul><li>BGP协议 设定一个路由作为自治系统内的 BGP发言人</li><li>发言人互相交换了网络可达性的信息后，各BGP发言人根据各自的相关策略选出一个达到各自治系统比较好的路由。也就是构造出一个树形结构（避免环路）</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726114524387.png" alt=""></p><ul><li>各AS自治系统交换其路径向量</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726115256186.png" alt=""></li></ul><h4 id="BGP-4四种报文"><a href="#BGP-4四种报文" class="headerlink" title="BGP-4四种报文"></a>BGP-4四种报文</h4><ul><li>open<ul><li>打开，可以理解为开门，建立关系，通信初始化</li></ul></li><li>update<ul><li>通告路由信息，列出撤销或增加的多条路由</li></ul></li><li>keepalive<ul><li>周期性证实邻站的连通性</li></ul></li><li>notificatin<ul><li>用来发送检测到的差错信息</li></ul></li></ul><p>不同协议的报文的直接封装的协议分别如下图</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726120631145.png" alt=""></p><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><ul><li><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP（<strong>I</strong>nternet <strong>C</strong>ontrol <strong>M</strong>essage <strong>P</strong>rotocol）</p></li><li><p>主机或者路由器使用ICMP来发送<strong>差错报告报文</strong>和<strong>询问报文</strong>。</p></li><li><p>ICMP报文被封装在IP数据报中发送</p></li></ul><h4 id="五种差错报文类型"><a href="#五种差错报文类型" class="headerlink" title="五种差错报文类型"></a>五种差错报文类型</h4><ul><li>终点不可达<ul><li>终点还可以细分为，端口，路由，网络，等等</li></ul></li><li>源点抑制<ul><li>出现拥塞是丢弃数据报，就想源点发送源点抑制报文，通知源点把发送速率放慢点，要坏掉了。</li></ul></li><li>时间超过<ul><li>当收到不是给自己的IP数据报，将TTL减1,结果不为0就转发，结果为0时，就像源点发个时间超过报文</li><li>当出现分片缺少时，把所有分片都丢失，并且发送给源点<strong>一个</strong>时间超过</li></ul></li><li>参数问题<ul><li>检测到误码，就想源码法参数问题数据报文</li></ul></li><li>改变路由（重定向）<ul><li>路由器把改变路由报文发送给主机，让主机知道下次应当将数据包发送给另外的路由器。</li></ul></li></ul><p><strong>不该发送的情况</strong></p><ul><li>多播地址报文</li><li>ICMP报文出差错，不再发ICMP</li><li>数据片发送一个就够了</li><li>特殊地址，127.0.0.0或者0.0.0.0</li></ul><h4 id="两种常用ICMP询问报文"><a href="#两种常用ICMP询问报文" class="headerlink" title="两种常用ICMP询问报文"></a>两种常用ICMP询问报文</h4><ul><li>回送请求和回答<ul><li>向一个特定的目的主机发出询问，收到询问，目的主机必须回送一个回送回答报文</li><li><strong>用来测试目的站是否可达</strong></li></ul></li><li>时间戳请求和回答<ul><li>询问时间，1900年1月1日开始 到 当前时刻的多少秒，作为值填入一个32位的字段，作为回答报文</li><li><strong>用来进行时钟的同步和测量时间</strong></li></ul></li></ul><h4 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h4><ul><li><h4 id="分组网间探测-Packet-InterNet-Groper"><a href="#分组网间探测-Packet-InterNet-Groper" class="headerlink" title="分组网间探测(Packet InterNet Groper)"></a>分组网间探测(<strong>P</strong>acket <strong>I</strong>nter<strong>N</strong>et <strong>G</strong>roper)</h4><ul><li><p>就是我们常用的ping指令，用来测试网络是否可达</p></li><li><p>应用层直接使用网际层的ICMP（没有通过运输层的TCP或UDP）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接拿百度做测试就好</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure></li></ul><p>效果如图： <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726162956952.png" alt=""></p></li></ul><ul><li><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><ul><li><p>用来测试IP数据报从源主机到达目的主机要经过那些路由器</p></li><li><p>直接使用的网际层，一样没有用到应用层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同样还是百度</span><br><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure></li></ul><p>效果如图 <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726163524000.png" alt=""></p></li></ul><p>​    原理就是源主机连续的发送，每发送一次，ttl+1,直到到达发送的主机（此时到当前目的路由TTL的值为1），回送请求回答的报文。</p><h3 id="虚拟专用网（VPN）与网络地址转换（NAT）"><a href="#虚拟专用网（VPN）与网络地址转换（NAT）" class="headerlink" title="虚拟专用网（VPN）与网络地址转换（NAT）"></a>虚拟专用网（VPN）与网络地址转换（NAT）</h3><h4 id="虚拟专用网（Virtual-Private-Network"><a href="#虚拟专用网（Virtual-Private-Network" class="headerlink" title="虚拟专用网（Virtual Private Network)"></a>虚拟专用网（Virtual Private Network)</h4><p>利用公用的因特网，作为一个专用网之间的通信载体，这样额专用网又成为虚拟专用网。</p><p>由于IPv4都分配完了挺紧缺的，一个机构能申请到的地址数远远小于拥有的主机数量，因此，虚拟专用网中的各个主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要再重新申请的，在因特网中使用的公有地址</p><p>以上这段话可以这么理解：我呢家里啊只申请到了一个IP地址，要接我网络的主机超过了我能拥有的IP的数量，我想让我的其他主机也能接入网络，但是没有IP地址，得咋整呢：</p><p>这么时候诶，</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726165421197.png" alt=""></p><p>我们查找到了几个能让我们自己使用的ip地址块，这些地址块被称为私有地址</p><p>也就是我们常说的 <strong>内网</strong>，我们将这些主机的IP设为这些内网地址。</p><p>但是私有地址们只能在内部通信，咋接入因特网呢，这些内网地址发出来的数据报因特网也不收啊？它只接受我们申请到的公网IP。</p><p>诶，所以你以为咱们为啥要买<strong>路由器</strong>？。。</p><p>这不就是将唯一申请到的IP地址分配给路由器么，通过路由器再接入互联网？（NAT）</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726170416656.png" alt=""></p><p>这种内网传送到内网的操作，咱们称其为<strong>IP隧道技术</strong></p><p>这类同一机构不同部门的内部网络所构成的虚拟专用网VPN又成为<strong>内联网VPN</strong></p><p>在世界各地接入因特网，只需要运行该VPN软件，就可以访问VPN其他内网的资源，<strong>这种VPN称为远程接入VPN</strong></p><h4 id="网络地址转换（Network-Address-Translation"><a href="#网络地址转换（Network-Address-Translation" class="headerlink" title="网络地址转换（Network Address Translation)"></a>网络地址转换（Network Address Translation)</h4><p>1994年提出了网络地址转换NAT的方法。</p><p>通俗来说就是：私有地址主机到的IP地址转换为全球IP地址</p><p>NAT路由器可以实现每一个内网地址对应一个外网地址对应并进行数据转发</p><p>但是只能一个外网地址跟一个内网地址对应，那不是还是需要申请公网地址？这不白转换了？</p><p>那么我们带着运输层的端口一起进行转换。这样，就可以只使用一个全球IP地址绑定多个本地地址的主机进行通信。</p><p><strong>NAPT</strong>（<strong>N</strong>etwork <strong>A</strong>ddress and <strong>P</strong>ort <strong>T</strong>ranslation)</p><p><strong>网络地址和端口号转换</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726172612960.png" alt=""></p><p>但是注意，外网的服务器是无法主动发起对内网的通信的，</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726173147402.png" alt=""></p><p><strong>内网的好处：</strong></p><ul><li>隔绝外网随意对内网进行链接，安全防护</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>能将IP地址解析下一个路由或者设备的相应MAC地址并在数据链路中重新封装</p><p>ARP（Address 解析 协议）高速缓存表：</p><p>用来存储的东西</p><p><strong>注意一下arp报文都是封装在MAC帧当中的</strong></p><p>在数据链路层，向所有主机发送ARP请求报文</p><p>根据其中请求的ARP请求报文检验，是否是来请求自己的，如果不是，就丢掉</p><p>如果是，交给上层网络层ARP进程 解析 先记录请求报文的主机IP与MAC 地址于自己的ARP高速缓存表中：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721172516670.png" alt=""></p><p>然后向下 数据链路层 再向发送请求的主机，一个ARP响应报文，其中包含自己的MAC 与ip地址，</p><p>收到了ARP响应报文，网络层的ARP进程进行解析，然后记录到自身的ARP告诉缓存表</p><p>注意不能跨网络使用</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721173048276.png" alt=""></p><p>注意了：</p><p>ARP还有其他报文，比如，免费报文（用来检测IP是否冲突）</p><p>ARP协议没有安全验证机制，有写人就会利用ARP进行攻击，ARP欺骗等问题</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这章学爽了</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复健1(未整理)</title>
      <link href="/2022/07/24/cfj/"/>
      <url>/2022/07/24/cfj/</url>
      
        <content type="html"><![CDATA[<h1 id="C-复健（侯捷）"><a href="#C-复健（侯捷）" class="headerlink" title="C++复健（侯捷）"></a>C++复健（侯捷）</h1><p>overloading (重载)</p><p>重载的条件：</p><p>同名</p><p>同作用域</p><p>不同的返回值</p><p>或者不同的参数（形参）</p><p>同名：其实在编译器来看是不同名的</p><p>作用域：一个类内，一个全局域内，一个函数域内</p><p>当构造函数放在私有中：</p><p>设计模式：Singleton</p><p>外界不能创建这个类</p><p>但是我们可以通过这个类提供的外界接口。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>; <span class="comment">//关键点在 static</span></span><br><span class="line">    <span class="built_in">setup</span>()&#123;...&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();<span class="comment">//调用方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数,内联（inline）定义，调用是最快的 </p><p>但内联是编译器决定的，写的定义过于复杂就不能一定是内联函数 </p><p>我们在类外定义函数实现的时候：需要inline在最外进行修饰，才有可能修饰成内联函数</p><p>构造函数：初始化值最好使用初始化列表的方式</p><p>常量成员函数</p><p>修饰符：const</p><p>要确定，是否要更改其中对象中数据，<br>如果要不需要更改 ，那必须需要修饰成员函数 添加const修饰</p><p>因为这是正规的正式合法的修饰，不加说明你是学习C++的杂牌军</p><p>const的意义</p><p>在使用该类的途中如果使用了const修饰，你却没有给这个函数修饰，编译器会报错</p><p>所有的成员函数都隐藏着一个参数 this; 这个this是调用这个成员函数的对象的指针</p><p>示例：</p><p>运算符的重写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面写法</span></span><br><span class="line"><span class="built_in">operator</span> ()(<span class="type">const</span> <span class="type">int</span> &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上</span></span><br><span class="line"><span class="built_in">operator</span> ()(<span class="keyword">this</span>,<span class="type">const</span> <span class="type">int</span> &amp;a)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>可以理解的是 this指针，其实就是，多个对象之间，调用的函数都是同一份 的调用依据</p><p>这里跟上一句话：对象之间互为友元</p><p>引用是可以理解为一个指针常量</p><p>可以改内容不可以改名字</p><p>我们可以用const修饰引用，既不可以该指针地址，也不可以改值</p><p>传指针才多大，当你要传的东西，大于指针地址的大小，为了速度呢前提是你不更改你传的东西，可以使用常量引用作为传值，若果要修改，就不要加常量修饰</p><p>注意了，返回引用本质是上返回指针，别啥玩意都返回引用，返回个野指针空指针啥的都是非法操作</p><p><strong>传递者无许知道接受者是以引用（reference)的形式接受</strong></p><p>标准库不是圣经,<del>圣经还有错的</del>呢，不是完美无缺的</p><p>构造函数的特殊语法初始化列表</p><p><strong>相同class的各个objects互为友元</strong></p><p><strong>一个好的C++代码习惯：</strong></p><p><strong>总结：内联函数最佳，const能加就加，引用能用就用，类中变量数据最好放私有区域</strong> <strong>用构造函数的特殊语法初始化列表</strong></p><p><strong>相当优雅</strong></p><p>类的匿名对象可以用作temp object（临时对象） ,一般用在生命周期比较短的作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return int( (int) char( &#x27;a&#x27;));</span><br></pre></td></tr></table></figure><p>拷贝构造编译器默认有给。</p><p>但是遇到以下情况：就不能用默认的：</p><p>类带指针成员</p><p>自定义一个string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(onst <span class="type">char</span>* cstr=<span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span><span class="comment">//内联</span></span><br><span class="line">    String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr=<span class="number">0</span>)<span class="comment">//拷贝构造</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data= <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];<span class="comment">//+1的意义是结束符号</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);<span class="comment">//数据的挪移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        m_data =<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//结束符号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">    String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>;<span class="comment">//检测自我赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个判断是有必要的，不止是为了效率，还为了正确性假设有这个么笨蛋</span></span><br><span class="line">    <span class="comment">//这么使用语法 s1=s1 如果不进行检测，就把自己先delete掉了。接下来的操作都是非法操作.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] m_data;<span class="comment">//指针数组串需要加中括号</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);<span class="comment">//深拷贝</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">    String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">String s3=s2;</span><br></pre></td></tr></table></figure><p>注意了有拷贝构造，VS的编译器就不给你生成别的默认的构造函数了（你就自己用你自己设定的吧！哼</p><p>啥事栈(stack)？啥事堆（heap）啥事作用域（scope）？</p><p><del>若不知道，回炉重造</del></p><p>栈：</p><p>存在于某作用域(scope)的一块内存空间。调用一个函数，函数本身会形成一个栈来方式所接还送肚饿参数和返回地址。</p><p>堆：</p><p>系统分配的（具体怎么分配问你操作系统）提供的一块全局的内存空间</p><p>程序可以动态分配区块，你得手动释放这块内存，才会死，否则只能就交给操作系统处理，具体怎么处理，还是得问问操作系统。</p><p>static静态修饰的玩意在全局区，直到程序结束</p><p>new 不是函数，实际上是一个操作符</p><p>而malloc才是一个函数</p><p>new的底层调用了malloc,然后调用构造函数ctor</p><p>delete同理</p><p>底层原理：先调用析构函数dtor  后调用free</p><p>VC编译器c的动态内存分配</p><p>注意是32位的操作系统下。</p><p>分配的内存块(in VC)，必须是16的倍数,除了本身的数据以外，还有两个4字节的头与尾cokie    值为总内存块的大小转16进制最后一位为1</p><p>1代表着，系统给出内存。0就没有给出，可以理解为一个标志</p><p>注意，分配的若是数组，将会分配的内存块中会有一个整数（4字节），值是数组的长度</p><p>调用delete时 也会先调用数组的长度次数的析构函数，再释放free内存</p><p>在使用NEW和 delete 的操作需要特别确认，不会出现误操作</p><h3 id="namespace的使用"><a href="#namespace的使用" class="headerlink" title="namespace的使用"></a>namespace的使用</h3><p>慎用unsing  namespace std;</p><p>以防造成命名空间混乱</p><p>当然偷懒还是可以使用，指定特定的使用</p><p>using std::cout</p><h3 id="OOP面向对象编程"><a href="#OOP面向对象编程" class="headerlink" title="OOP面向对象编程"></a>OOP面向对象编程</h3><p>基于对象的编程，C++与C的不同。</p><ul><li>Inheritance</li><li>Composition</li><li>Delegation</li></ul><h4 id="Composition复合"><a href="#Composition复合" class="headerlink" title="Composition复合"></a>Composition复合</h4><p>实际上这是最常见最简单的，一个类作为容器包含着其他的类</p><p>通俗的例子，在C 中，结构体中的成员是结构体，但是，严格上来讲，还是不一样的，当然先这么理解没问题</p><p>Adapter设计模式中可以见到</p><p>在复合的关系构造与析构，实际上可以理解为包装礼盒</p><p>里面的东西打包，再打包，这就是构造的顺序</p><p>拆礼物就不用说的，先拆外壳，在拆里头的东西，这就是析构的顺序</p><p>这是稳定的。</p><h4 id="Delegation委托"><a href="#Delegation委托" class="headerlink" title="Delegation委托"></a>Delegation委托</h4><p>Composition by reference</p><p>复合的引用版</p><p>类中掌握着一个指向其他类的指针，所以，也被称为Composition by reference</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stringRep</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    stringRep* rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意这两个类的生命周期了，不同步的，是异步的，pimpl(handle/Body)</p><p>相当灵活的是，这个指针是可以指向其他的类的</p><h4 id="Inheritance继承"><a href="#Inheritance继承" class="headerlink" title="Inheritance继承"></a>Inheritance继承</h4><p>在C中只有一种继承方式，</p><p>struct 的 pubilc </p><p>而C++有三种继承（分三种的原因，其实就是类与结构体的区别）</p><p>不同的继承</p><p>基类子类的成员之间的关系也不同。</p><p>有这么一种生物上的解释</p><p>子类中含有父类的基因，可以这么理解</p><p>子类对象的构造与析构一样是，由内而外与由外而内（打包礼物和拆礼物）</p><p>子类中定义的成员函数，要是与基类名字相等，这里就需要用到虚函数了，这就是继承中最核心的部分</p><ul><li>non-virtual</li><li>virtual</li><li>pure virtual</li></ul><p>pure virtual 纯虚函数，子类必须重新定义的（重写）的函数</p><p>继承与复合的构造与析构</p><ul><li><p>子类继承基类同时复合其他类的析构顺序，代码测试结果如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基类构造</span><br><span class="line">其他类构造</span><br><span class="line">子类构造</span><br><span class="line">子类析构</span><br><span class="line">其他类析构</span><br><span class="line">基类析构</span><br></pre></td></tr></table></figure><p>可以发现，构造顺序是从基类开始</p><p>然后是复合类，才到子类</p><p>继承的基类优先级最高</p><p>在内存分布中是在第一位相对于子类中其他复合类而言</p></li></ul><p>委托与继承的结合实际应用中是使用的最多的</p><p>比如说一个数据多种不同的表现方式</p><p>面型对象中应用的设计模式</p><p>Composite</p><p>应用实际：文件夹结构系统</p><p>文件夹中有文件和文件夹。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220905181337892.png" alt="image-20220905181337892"></p><p>对未来子类的继承CLASS的规划</p><p>Prototype模式</p><p>图解</p><p>-私有</p><h1 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h1><p>下划线 静态</p><p>变量名：变量类型</p><p>函数名（函数参数）</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复健2(未整理)</title>
      <link href="/2022/07/24/cfj1/"/>
      <url>/2022/07/24/cfj1/</url>
      
        <content type="html"><![CDATA[<p>conversion function </p><p>转换函数</p><p>non-explicit-one-argument ctor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numer;</span><br><span class="line">  <span class="type">int</span> m_denom;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : <span class="built_in">m_numer</span>(num), <span class="built_in">m_denom</span>(den) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (<span class="type">double</span>)(m_numer / m_denom); &#125;</span><br><span class="line">  Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fraction</span>((f.m_numer + <span class="number">1</span>) * <span class="keyword">this</span>-&gt;m_denom, f.m_denom * <span class="keyword">this</span>-&gt;m_denom);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Fraction</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction ::~<span class="built_in">Fraction</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">4</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="type">double</span> d = f + <span class="number">4</span>;<span class="comment">//编译出错，二义性，因为编译器不知道应该转f 还是转换 4</span></span><br><span class="line">  <span class="type">double</span> c = <span class="number">4</span> + f;</span><br><span class="line">  cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">  Fraction e = f + <span class="number">4</span>;<span class="comment">//加了explicit 关键字后，默认转换Fra为double,编译器就不会再调用构造函数来进行转换了，同时的这里也会报错，double 无法转换得到 Fra类型</span></span><br><span class="line">  Fraction g = <span class="number">4</span> + f;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译器会寻找转换函数，不存在，存在多个都会报错</p><p>point like classes 仿指针的类</p><p>智能指针</p><p>我们希望指针能够更加的智能，能做更多的事情，C++11中继而出现了智能指针概念</p><p>成员模板中在只能指针也有应用到，为了模拟父类指针能够指向子类</p><p>因为在继承关系中，父类的类型确实是可以被子类的值，赋值，就想动物类中可以的值有人，猫，狗各种值一样</p><p>需要注意的是 -&gt; 这个符号是可以持续作用的（在重载该符号时，并不会被消耗 </p><p>容器的对应的迭代器，实际上也可以称为智能指针</p><p>其中++ —的遍历操作的实现就是重载运算符函数</p><p>function-like classes，仿函数</p><p>标准库会继承奇特的base classes</p><p>namespace经验谈</p><p>不同的测试函数，类，全局变量使用不同的命名空间，作为分隔区</p><p>互不干扰</p><p>specialization</p><p>模板特化（模板泛化的反面）</p><p>作用就是特殊的类型如果有需要，再指定特殊的具体讨论</p><p>partial 模板的偏特化 （局部特化</p><ul><li>个数上的偏特化<ul><li>最小类型的指定</li></ul></li><li>范围上的偏特化<ul><li>指定范围为指针的类型无论</li></ul></li></ul><p>模板的模板参数，需要注意的是假如模板中有多个模板参数，（定义对象会出现问题，一个坑，编译器无法编译，解决方法不同）</p><p>使用的是不是模板模板参数实现的对象，观察的是：调用时，是否所有的模板参数都指定了类型，如果有模糊地带，换句话而言，就是是否还存在你想让编译器来帮你推导的数据类型。</p><p>C++标准库</p><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>侯捷老师强烈建议，使用STL标准库，我个人认为，这种说法是不适合当前的面试的情况的，因为遇到了大部分，需要手撕链表二叉树哈希表等面试题目，平时也在刷leetcode等题库，可以体会到，当前的面试要求是，调用标准库算法，都是人下人（极端的说，不过确实有人说脚本小子，库小子的蔑称传开</p><p>在开发的时候当然还是要用标准库，毕竟标准库的算法并不是为面试提供的，而面试之后，你才能加入公司进行开发工作，而你写的手撕代码的实现，在开发中却很可能就完全用不到，调个库几乎就可以完成任务了，所以就会给人一种经典面试造火箭，工作扭螺丝的感觉。</p><p>学习标准库</p><p>第一步当然是都要调用，知道其用法</p><p>常用容器，常用，甚至不常用的算法，至少调用过一次</p><p>variadic templates</p><p>数量不定的模板参数</p><p>c++11中的语言特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; fristArg, <span class="type">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; fristArg &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;当前还没执行的参数&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>...(args)&lt;&lt;endl;</span><br><span class="line">  <span class="built_in">print</span>(args...);<span class="comment">//无所谓的处理方式，这里使用的递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">12</span>, <span class="string">&quot;hellp&quot;</span>, <span class="string">&quot;skdjskd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是…的位置，不同位置是不同的前后出现次序</p><p>随之更新的标准库中有很多都用到了这个新语法（新是相对98而言的），如今c++11距离至今已经11年了，c++20 加入了协程等（稍微了解了一下），和其他很多新特性，但是目前国内c++11居然还是主流（不好说。</p><p>c++11的语法糖</p><p>auto 实际上就是一个智能的指针</p><p>写迭代器的时候懒得写这么长（当然你还是得会写，这是C++程序员的基本素养所在）</p><p>用auto可以代替，类型推导都交给auto来处理，偷懒。</p><p>需要注意的是，推导的前提是得有值给编译器作为依据。</p><p>有些人干脆认为全都用auto好了，那你为啥不直接用PHP捏，写js全写any不就完了呗，开发都是用shell来写，因为shell直接就一种数据类型。（还是那句话：这是C++程序员的基本素养所在</p><p>for的新语法</p><p>主要是针对容器的遍历</p><p>语法模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（decl : coll)&#123;</span><br><span class="line">statment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用范例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">char</span>&gt; strs;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    strs.<span class="built_in">push_back</span>(<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line">    str += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reference</p><p>引用</p><p>在没有看侯捷老师的课程之前</p><p>引用在我的脑子里等同于 指针常量，在编译器中也是将引用当指针来看待</p><p>但是实际上，并不是的（尽管作用相同），逻辑上讲，引用相当于别名</p><p>别名和原名在调用sizeof函数调用中是一样的大小(这是一种假象，编译器制造出来的)</p><p>ps:java中的所有变量都是reference</p><p>而指针常量呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> a = &amp;x; </span><br><span class="line"><span class="type">int</span>&amp; b = x;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> c = &amp;a;</span><br><span class="line"><span class="type">int</span>&amp; d = b;</span><br><span class="line"><span class="comment">//修改a</span></span><br></pre></td></tr></table></figure><p>编译器中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span> <span class="type">const</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//为了对应编译器的欺骗和处理指针的传值矛盾</span></span><br><span class="line"><span class="comment">//再根据重载条件</span></span><br><span class="line"><span class="comment">//所以这两者是不能并存的</span></span><br><span class="line">但是以下的情况是可以并存的的，<span class="type">const</span>也算函数签名声明的一部分</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span> <span class="type">const</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//不打注释表示这个是更重要的东西</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，能用引用就引用，省事，还快，一般用到参数传递传出的描述。</p><p>对象模型</p><p>Vptr 和 vtbl</p><p>虚指针</p><p>虚基表</p><p>子类继承父类时</p><p>父类出现虚函数，子类一定也会继承得到虚函数</p><p>子类中调用虚函数的形式时，</p><p>通过的对象的指针p再找到继承的来的虚指针vptr，通过虚指针找到虚基表vtbl，再找表中的第n个虚函数的地址进行调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* p-&gt;vptr[n])(p);</span><br></pre></td></tr></table></figure><p>这就是动态绑定</p><p>也就是常说的的多态。</p><p>只要基础硬得跟石头一样，在进行编程时才会知其然所以然</p><p>关于this</p><p> 对象的函数的调用，在编译器看来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MYCLASS::funtion(&amp;myclass);</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line">this = &amp;myclass;</span><br><span class="line">this-&gt;function；</span><br><span class="line"><span class="comment">//如果是虚函数，再结合动态绑定</span></span><br><span class="line">(*this-&gt;function[n])(this);</span><br></pre></td></tr></table></figure><p>关于const</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220907183637718.png" alt=""></p><p>当成员函数中，const存在和non-const也存在。const 对象只会调用const的函数（防止了二义性的问题</p><p>相应的non-const object 只能调用non-const函数</p><p>我理解为编译里的读写锁机制</p><p>设计一个类，根据需求，实现功能，都要好好考量，每一个成员函数是否需要const修饰</p><p>（const就是算签名的一部分）</p><p>标准库的string应用的引用计数</p><p>总结起来就是八个字：就是读时共享，写时复制</p><p>COW ,在fork的进程中的对全局变量的处理也是相同的思想</p><p>关于new. delete</p><p>内存池中需要考虑到用到</p><p>重载delete 和 new和delete[],new[];</p><p>由于这两个函数（运算符）其实是全局的函数，把它们当运算符看也没问题，之前有说过了，new实际上是调用的malloc后构造</p><p>而delete 是调用析构后再进行free.</p><p>一般定义限定在任何一个对象的命名空间中，但是需要static修饰</p><p>既然是重载，肯定是有自己的想法的，说明单纯的new和delete已经满足不了</p><p>就衍生出了,带参数的new 和 delete</p><p>需要注意的是</p><p>带参数的new 不一定需要再写对应的delete</p><p>当这个带参数的new在执行构造抛出错误时才会调用对应的delete</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复健3(未整理)</title>
      <link href="/2022/07/24/cfj2/"/>
      <url>/2022/07/24/cfj2/</url>
      
        <content type="html"><![CDATA[<p>不会用标准库与其他语言没什么区别</p><p>C++11的标准库的体系结构与内核分析</p><p>C++标准库</p><p>C++标准模板库</p><p>先明白头文件引用</p><p>新式headers</p><p>无.h后缀名</p><p>旧式headers</p><p>带.h后缀名</p><p>而新式的headers内的组件都封装与namespace “std”中</p><p>旧式的std就不被封装于namespace “std”</p><p>标准库属于新式的headres中</p><p>STL的六大部件</p><ul><li>容器Container</li><li>分配器Allocators</li><li>算法Algorithms</li><li>迭代器Iterators<ul><li>泛化的指针</li></ul></li><li>适配器Adapters（转换器）<ul><li>容器的适配器</li><li>迭代器的适配器</li><li>仿函数的适配器等等</li></ul></li><li>仿函数Functors</li></ul><p>可以发现OOP的思想跟STL的设计思想是不大一样的</p><p>算法的复杂度</p><p>当前的常见的Big-oh</p><ul><li>$O(1)$</li><li>$O(n)$</li><li>$O(log_2n)$</li><li>$O(n^2)$</li><li>$O(n^3)$</li><li>$O(2^n)$</li><li>$O(nlog_2n)$</li></ul><p>容器大部分都是前闭后开区间，而且不一定是连续空间</p><p>一般分三类</p><ul><li><p>Sequence Container</p><ul><li>顺序容器</li></ul></li><li><p>Associative Container</p><ul><li>关联式容器</li></ul></li><li><p>unordered Container</p><ul><li>无序容器</li></ul></li></ul><p>HashTable </p><p>Separate Chaining</p><p>Array</p><p>vector</p><p>list</p><p>Chainingdeque</p><p>queue</p><p>stack</p><p>multiset</p><p>multimap</p><p>unordered_multimap </p><p>unordered_set</p><p>非STL</p><p>hash_map</p><p>hash_set</p><p>源码面前，了无秘密</p><p>OOP(object oreinted)与GP（generic )的对比</p><p>datas 和 methods 结合</p><p>datas 与 methods 分离</p><p>Allocators</p><p>支持容器的内存分配的模块</p><p>在不同编译器下不同的分配器得实现源码都是有略微不同的</p><p>默认的分配器实际上就只是malloc和free的封装</p><p>如果有特殊需求。比如说当实现很多的量，在分配的时候，当我们的值只是一个很小的东西，分配器分配的内存开销相应的就会很大，我们可以指定使用其他的分配器</p><p>Container的设计实际上还是根据需求特性来，比如链表的设计核心，结点，数据。需要围绕着其来进行代码上的设计，观察STL库的源码可以发现，C++11看起来似乎糅合了许多OOP的思想（只是似乎），看起来会有些复杂，比如考虑到了对有状态的分配器的支持等等</p><p>iterator的设计原则，必须要有五个类型作为特征，并且根据要达到的功能进行各种的重载函数，虽然大体思想还是GP编程</p><p>而算法要怎么判断迭代器的类型，并且使用调用达到算法的效果，需要iterator traits来进行甄别。</p><p>一般traits 有两个通道，一个是迭代器通道，一个是普通指针通道</p><p>deque</p><p>双向开口“连续”容器</p><p>是一个vector管理着N个array</p><p>利用deque做底层结构可以衍生出queue和stack</p><p>RB_Tree</p><p>RB_Tree的简单理解</p><p>红黑结点与root</p><p>利用RB_Tree底层结构衍生实现map和set</p><p>两者区别在于set 的RBTree 的key = value</p><p>而map key = key value = value  ` </p><p>而multiset or multimap  就在RBtree的insert_unique与iinsert_equal区别调用</p><p>hashtable</p><p>简单理解：多个（有上限）不同规格的桶的连续结合（vector)</p><p>桶实际的底层结构是有上限的链表上限一般取决于桶的总个数</p><p>超过上限就要增加桶</p><p>桶的个数呢一般选择的是质数（1是最小公因数）</p><p>增加桶一般是乘2后取左右的质数，所有的桶内的元素都要重新进行分配</p><p>所以hashtable也被称作 Separate Chaining</p><p>需要知道的是 放入的元素不同，需要指定不同的规则，在设计hashtable的时候需要指定符合规则的行为(谓词)</p><ul><li><p>HashFcn</p><ul><li>元素映射hash code</li><li>元素放置规则，注意设计的越杂乱容易不发生元素碰撞</li></ul></li><li><p>EqualKey</p><ul><li>元素相等判断</li></ul></li><li><p>ExtractKey</p><ul><li>key and value区分，为map和set区分服务</li></ul></li></ul><p> c++11后一半都选用unordered_set而不是hash_set，这个名字一开始是民间名字，加入了标准库后，改名哩，虽然hash_set也能用</p><p>算法</p><p>algorithms</p><p>从语言层面讲，是个function template</p><p>迭代器的分类</p><ul><li>input_iterator_tag<ul><li>farward_iterator_tag <ul><li>bidirectional_iterator_tag<ul><li>random_access_iterator_tag</li></ul></li></ul></li></ul></li><li>output_iterator_tag</li></ul><p>表继承方式</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220917164555786.png" alt=""></p><p>源码是这样的继承关系</p><p>迭代器分类和type traits对算法的影响</p><p>pred </p><p>返回值都是bool</p><p>根据参数的多少被称为N元谓词</p><p>标准库中的二分查找（binary_search)基于两个函数</p><ul><li>lower_bound()</li><li>upper_bound()</li></ul><p>标准库源代码示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    ForwardIterator</span></span><br><span class="line"><span class="function">    <span class="title">lower_bound</span><span class="params">(ForwardIterartor first, ForwardIterator last, <span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ForwardIterator it;</span><br><span class="line">    iteratoor_traits&lt;ForwardIterator&gt;::difference_type count, step;</span><br><span class="line">    count = <span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">it = first; step = count / <span class="number">2</span>; advance9it, step);</span><br><span class="line">        <span class="keyword">if</span>(*it , val)&#123;</span><br><span class="line">            first = ++it;</span><br><span class="line">            count -= step + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> count = step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>functors 仿函数</p><p>这个东西基本只为算法服务</p><p>标准库中基本又主要的三大类，实际上不止3个</p><ul><li>Arithmetic</li><li>Logical</li><li>Relational</li></ul><p>而每一个STL的functors 都需要选择适当的适配分类（adaptable）继承</p><p>Adapters适配器</p><p>（类似转换头）</p><p>container adapters  容器适配器</p><ul><li>stack</li><li>queue</li></ul><p>iterator adapters 迭代器适配器</p><p>functor adapters 函数适配器</p><p>bind2nd是个用来辅助binder2nd函数适配器的辅助函数,帮助记录第一个参数和第二参数的类型，binder2nd再通过知道的类型定义内部成员。俗称，实参类型推导</p><p>实际上在C++11中bind2nd   实际使用的是 std::bind 新型适配器</p><p>include\<functional></p><p>可以绑定函数，仿函数（函数对象），成员函数，成员变量</p><p>设计模式adapter</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复健4(未整理)</title>
      <link href="/2022/07/24/cfj3/"/>
      <url>/2022/07/24/cfj3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++11特性"></a>C++11特性</h1><p>很多以前存在的组件已经放入了STL</p><p>比如regex，tuple等</p><p>需要注意的比较重要的特性</p><p>模板多函数参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; fristArg, <span class="type">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; fristArg &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;当前还没执行的参数&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">12</span>, <span class="string">&quot;hellp&quot;</span>, <span class="string">&quot;skdjskd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个点实际上就是一个关键词</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><p>表示一个pack，在不同的位置有不同的意思和用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="comment">//表示多个类型模板参数包</span></span><br><span class="line"><span class="type">const</span> Types&amp;... args</span><br><span class="line"><span class="comment">//表示多个函数参数类型包</span></span><br><span class="line">args...</span><br><span class="line"><span class="comment">//表示函数参数包</span></span><br></pre></td></tr></table></figure><p>很方便的实现递归的操作比如tuple的实现，实现同名不同类型的成员等</p><p>接下来第二个例子</p><p>了解了新特性后打算重写printf(c的输出函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s) != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;invalid format string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *s++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, T value, Args... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++s) != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">      cout &lt;&lt; value;</span><br><span class="line">      <span class="built_in">printf</span>(++s, args...);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *s++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;extra arguments&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>* pi = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  <span class="built_in">myprintf</span>(<span class="string">&quot;嘿嘿%d真不错%s %p %f \n&quot;</span>, <span class="number">12</span>, <span class="string">&quot;heihie&quot;</span>, pi, <span class="number">3.1415926</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三例子：实现一个Max函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果只是单纯实现，参数类型相同时</span></span><br><span class="line"><span class="built_in">max</span>(&#123;<span class="number">213</span>,<span class="number">234</span>,<span class="number">213</span>,<span class="number">24</span>,<span class="number">656</span>,<span class="number">23</span>&#125;);</span><br><span class="line"><span class="comment">//用不到variadic template，按照标准库的默认处理便好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当传入的形式发生变化</span></span><br><span class="line"><span class="built_in">max</span>(<span class="number">213</span>,(<span class="type">int</span>)<span class="number">23</span>,(others)<span class="number">234</span>,<span class="built_in">Person</span>(),<span class="number">234</span>);</span><br><span class="line"><span class="comment">//就需要使用到variadic template 来进行函数的实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mymax</span><span class="params">(<span class="type">const</span> T&amp; n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T <span class="title">mymax</span><span class="params">(<span class="type">const</span> T&amp; n,Args... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std:<span class="built_in">max</span>(n, <span class="built_in">mymax</span>(args...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tuple  元组</p><p>一般用于，返回值有多个类型</p><p>第四个例子</p><p>tuple的使用</p><p>make_tuple的使用</p><p>递归，分节递归，递归的创建</p><p>第五个例子</p><p>递归的继承</p><p>同样是从tuple源代码来看,简易版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Balues&gt;<span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line">templte&lt;&gt; <span class="keyword">class</span> <span class="title class_">tuple</span>&lt;&gt;&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>&lt;Head, Tail...&gt;:<span class="keyword">private</span> tuple&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt;inherited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">tuple</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(Head v, Tail... vtail):<span class="built_in">m_head</span>(v), <span class="built_in">inherited</span>(vtail...)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Head::type <span class="title">head</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_head;&#125;<span class="comment">//error</span></span><br><span class="line">    <span class="comment">//拿出Head的类型，但是有些类型并没有type (比如并不是STL中的类型)</span></span><br><span class="line">    <span class="comment">//这里就出现问题了，如果使用了别的类型，将会出现编译错误，然而这里使用decltype就可以找出来类型</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">head</span><span class="params">()</span>-&gt;<span class="title">decltype</span><span class="params">(m_head)</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line">    <span class="comment">//然而，那我们为什么不直接使用Head的类型呢？</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_head;&#125;</span><br><span class="line"><span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第六例子</p><p>用于复合，tuple</p><p>Spaces in Template Expressions</p><p>模板嵌套空格省略</p><p>nullptr and std::nullptr_t</p><p>使用nullptr 代替 函数参数中NULL/0，作用就是更好的区分开空指针与数值（int）0 的区别</p><p>定义了一个新的指针类型nullptr_t</p><p>Automatic Type Deduction with auto </p><p>auto 推导类型，是一种语法糖</p><p>一般在定义迭代器的时候，类型将会写很长，很复杂，这里我我们就可以使用auto 来自动推导类型</p><p>Uniform Initialization</p><p>统一版本的对象初始化</p><p>使用{}态构造初始化</p><p>{}构建出std::initializer_list<T> 这个构造出来的对象关联着一个array<T,n>,实际上关联，只有一个迭代器</p><p>在这个容器中逐一调用构造函数或者原本就可以多个进行初始化</p><p>initializer_lists</p><p>编译器可以调用改对象的私有构造</p><p>需要注意的是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span> / <span class="number">3</span> ; <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span> a &#123;<span class="number">10</span>/<span class="number">3</span>&#125;; <span class="comment">// 3 warning </span></span><br></pre></td></tr></table></figure><p>explicit</p><p>关键字</p><p>在C++11之前</p><p>explicit for ctors taking one argument </p><p>只会调用一次,主要调用在构造函数上并且构造函数中只有一个参数</p><p>C++11后</p><p>explicit for ctors taking more than one argument </p><p>也只会调用一次，但是构造函数可以不只一个参数</p><p>range-based for statement</p><p>for循环的一种简单写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( decl : coll ) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; nums: &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; )&#123;</span><br><span class="line">    cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=delete , = default </p><p>通常写了一个构造函数之后，编译器就不回给你默认的构造函数，在构造函数之后添加=default 后就可以获得并使用default ctor </p><p>=delete 就顾名思义，删除为零</p><p>一个类中如果包含指针，基本必须都需要自己主动定义Big-Three （构造拷贝构造析构三大件）</p><p>No-Copy and Private-Copy</p><p>Private- Copy  or No-Copy 的典型应用就是单例模式single</p><p>Alias Template </p><p>化名模板（别名） </p><p>比c的宏有更简单的用法(当然也是有代价的)</p><p>关键字：using </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, MyAlloc&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">//is epuivalent to </span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br></pre></td></tr></table></figure><p>模板的特化问题，尚未解决，不能对别名做特化，只能原原本本的模板本身进行特化操作</p><p>模板模板参数</p><p>template template parameter </p><p> 模板的高深的使用方式。</p><p>但是注意的是只能模板模板参数，不能模板模板参数的模板参数*2，编译器只能推导一次</p><p>编译器第一次开始编译推导确实是能通过的，但是，需要注意的是，并不知道的模板模板参数的绑定究竟是什么类型，实际在运行的时候如果还是需要编译器进行推导还是会出现问题。（编译器并没有想象的这么聪明</p><p>所以常常Alias template 和模板模板参数进行混合使用，从而达到模板模板参数的模板参数的效果</p><p>现在我们模拟一个实现场景</p><p>已知一个数据组，我需要将其进行测试，满足以下调用效果，作用是检测是否该数据组是否能够放入不同容器并且进行数据搬移move。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(vector, mystring);</span><br><span class="line"><span class="comment">//mtstring 是我自定义的数据集</span></span><br><span class="line"><span class="comment">//vector 是我进行测试的容器</span></span><br></pre></td></tr></table></figure><p>起初写了一个测试函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(Container cntr, T elem)</span></span>&#123;</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(C2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而并不行，在实际调用时编译出现错误,错误非常明显，Container并不是一个模板</p><p>这时，就可以想到了，模板模板参数（不过呢，为了实现过程在更曲折一点，假装没想到模板模板参数。</p><p>想到了一个下位替代，使用函数模板和迭代器和萃取器（traits)</p><p>我提前就将数据放好在容器中作为参数，再进行测试</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(Container c)</span></span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_taits &lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">Valtype</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>()));<span class="comment">//静态数据输出测试</span></span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(C2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而测试函数的调用方式发生了改变，尽管作用一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="built_in">vector</span>&lt;mystring&gt;());</span><br></pre></td></tr></table></figure><p>感觉还是没有一开始设想的调用方式好，假如不想使用迭代器和trait怎么办呢，假如所使用的容器是自己设计的并没有遵循标准库的设计，是不是就无法使用这个测试函数了。</p><p>这个时候，终于想起来要使用模板模板参数了（迫真</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">class</span> <span class="title class_">Container</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">XCls</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">       c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">T</span>());</span><br><span class="line">    <span class="built_in">output_static_data</span>(<span class="built_in">T</span>());<span class="comment">//静态数据输出测试</span></span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="function">Container&lt;T&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">    c1.<span class="built_in">swap</span>(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的类测试编译通过了，再进行调用时,却出现了错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCls&lt;mystring, vector&gt; c1;</span><br></pre></td></tr></table></figure><p>错误原因是：第二个实参的类型不符合，深排原因，标准库中vector的实现有两个模板参数（需要指定适配器），然而，模板模板参数中需要特别注意的点来了，即使模板中的模板参数中第二个参数有默认值时，编译器并不能进行推导。</p><p>这个时候可以使用别名参数进行指定参数到底是什么，来帮助编译器进行推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">using</span> Vec = vector&lt;T, allocator&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>需要注意的事，该化名并不能在类中或者function body中声明。</p><p>最终函数的调用方式将会是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XClS&lt;string, Vec&gt; mystring;</span><br></pre></td></tr></table></figure><p>type alias </p><p>类型别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(<span class="type">int</span> ,<span class="type">int</span>);</span><br><span class="line"><span class="comment">//simliar to typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上我们在使用标准库的容器时，使用的string 实际就是using  string = std:: basic_string \<char></p><p>noexcept 不异常</p><p>宣告这个函数不会出现异常</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span> <span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常是个大学问，此处不谈</p><p>在使用成长性容器时(vector 或deque（实际上内部是靠着vector实现）)，会发生 内存越界 memeory reallocation</p><p>在11特性中，noexcept的作用是声明 vector的调用不会抛出异常，而是有一个自己设定的处理方法(move)  </p><p>总结就是，在设计一个类时，抛异常是非常致命的，设计到进行搬移的时候</p><p>override 重写</p><p>一般应用在虚函数之上，告诉编译器该函数重写：避免和重载和声明定义新的函数发生混乱</p><p>final 最终</p><p>两种比较常见用法,不过效果都是表示不可重写，与override对立</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Basel final&#123;&#125;;</span><br></pre></td></tr></table></figure><p>decltype </p><p>使用方式类似 sizeof() and typeof();</p><p>类型的表达式的类型,一般用来定义一个type</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到container_obj的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(container_obj)::value_type elem;</span><br><span class="line"><span class="comment">//similar to typeof</span></span><br><span class="line">map&lt;string,<span class="type">float</span>&gt;::value_type elem;</span><br></pre></td></tr></table></figure><p>有三种应用</p><p>第一种：用于声明返回类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(x + y)</span><span class="title">add</span><span class="params">(T1 x, T2 y)</span></span>;</span><br><span class="line"><span class="comment">//声明x+y 的结果的类型实际是add这个函数的结果的返回类型 </span></span><br><span class="line"><span class="comment">//比如add函数的返回值是int</span></span><br><span class="line"><span class="comment">//作用是提前做好声明，保证编译器不会报错</span></span><br><span class="line"><span class="comment">//不过这样其实是编译失败的，会出现x和y未定义</span></span><br><span class="line"><span class="comment">//所以这里就需要使用auto来辅助进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 x, T2 y)</span> -&gt; <span class="title">decltype</span><span class="params">( x + y )</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意的是这是一种新的返回类型的指定方式，与lanbdas的表达形式相似</p><p>第二种：in metaprogranmming </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(container_obj)</span>:: iterator iType</span>;</span><br></pre></td></tr></table></figure><p>在lambda没有使用之前，设定一个仿函数需要定义一个类，按照传统的方式来定义</p><p>使用仿函数时作谓词时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;string, functor&gt; myset;</span><br></pre></td></tr></table></figure><p>使用lambda时使用方式则变更为</p><p>这就是第三种</p><p>传递lambda的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)&#123;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">myset</span><span class="params">(cmp)</span> </span></span><br></pre></td></tr></table></figure><p>原因是因为我们手上往往只有objec 而没有type,所以需要借助decltpye来取出类型（类），在set的众多的构造函数中，有着一个可以使用lambda的接口，需要将lambda传给构造函数，否则调用的依旧是默认的规则（构造函数），然而lambda并没有构造函数,所以将会编译失败。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20221013202450061.png" alt=""></p><p>lambdas</p><p>定义的一个内联函数 </p><p>definition of inline functionality，similar to like functions</p><p>lambda introducer  </p><p>这个中括号有说法，除了平常常用对外部的变量的值和引用以外还有更多深入的用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示外部传的值可以发生变化，（可读不可写） mutable</span></span><br><span class="line"><span class="comment">//传引用时则可以加也可以省略</span></span><br><span class="line"><span class="comment">//比较完整的lambdas写法</span></span><br><span class="line">[...](...)<span class="keyword">mutable</span> throwSpec -&gt;retType&#123;...&#125;</span><br></pre></td></tr></table></figure><p>由于lambdas默认是内联函数 效率实际上还是很高的</p><p>更多的使用方式需要单独开一章文更加深入了解</p><p>右值引用与左值引用</p><p>左值其实就是一个变量，这是咱的基本的变量的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = b;</span><br><span class="line"><span class="type">int</span> d = a;</span><br><span class="line"><span class="comment">//以上都是左值</span></span><br><span class="line">a + b = <span class="number">42</span>;</span><br><span class="line"><span class="comment">//a + b 就是右值了,但是这样是人ERROR的</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;sadas&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;sdfad&quot;</span>)</span></span>;</span><br><span class="line">s1 + s2  = s2;</span><br><span class="line"><span class="comment">//然而在标准库中 string 是可以通过编译的</span></span><br><span class="line"><span class="built_in">string</span>()  = <span class="string">&quot;sdasdsf&quot;</span>;</span><br><span class="line"><span class="comment">//而临时变量，也是一个右值，并且编译通过</span></span><br></pre></td></tr></table></figure><p>而右值，是不可以出现在左边的,在C++11以前，是没有右值引用的概念的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;retuen <span class="number">6</span>;&#125;</span><br><span class="line"><span class="type">int</span> *p = &amp;<span class="built_in">foo</span>();<span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><p>在C++ 11以后，出现了新的语法，来声明，告诉编译器，这是一个右值引用，加入noexpect修饰，保证不会报错</p><p>一般，在拷贝时，深拷贝与浅拷贝，实际上都是左值copy,而遇到成长性的容器时，在保证效率需要使用到右值拷贝来进行效率上的优化避免出现不必要的拷贝，只需要把指针拷贝就好,于是就出现了 steal 的构造函数 move ctor，但是这个事情是相当危险的，毕竟是两个指针指向同一个内存块，所以move 函数的搬移 就是将左值转换为右值，  当拷贝完成之后，就需要打断指针指向，所以，被move的值，就不能再进行使用，从而保证安全。</p><p><strong>注意，以上的move都是 std::move</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Mystring</span>(Mystring &amp;&amp; str)<span class="keyword">noexcept</span>:initalization list&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&amp;&amp; 声明，告诉编译器传进来的就是右值，而左值一样也可以使用move函数  声明为右值。</span></span><br></pre></td></tr></table></figure><p>设计一个MyString和一个无move的功能的MyString来实现对照</p><p>设计多个构造函数，并对每次调用进行计数，测试搬移构造与拷贝构造的效率</p><p>在测试vector和deque等成长性容器可以发现，有move与无move的copy效率差别是巨大的，而对于list与红黑树等影响不是非常大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的左值传入，进行的拷贝</span></span><br><span class="line"><span class="function">M <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="comment">//右值传入，进行的其实是指针的交换。</span></span><br><span class="line"><span class="function">M <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line"><span class="comment">//临时变量，也是右值传入</span></span><br><span class="line"><span class="function">M <span class="title">c3</span><span class="params">(M())</span></span>;</span><br></pre></td></tr></table></figure><p>再次声明：<strong>当拷贝完成之后，就需要打断指针指向，所以，被move的值，就不能再进行使用，从而保证安全。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础ISO</title>
      <link href="/2022/07/21/socket/"/>
      <url>/2022/07/21/socket/</url>
      
        <content type="html"><![CDATA[<h1 id="ISO7层网络结构体系图"><a href="#ISO7层网络结构体系图" class="headerlink" title="ISO7层网络结构体系图"></a>ISO7层网络结构体系图</h1><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/bfcd89ba301b34b6f158d2065a5ccb40.jpg" alt="https://s4.51cto.com/oss/201910/22/bfcd89ba301b34b6f158d2065a5ccb40.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第三节|数据链路层</title>
      <link href="/2022/07/20/internet03/"/>
      <url>/2022/07/20/internet03/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>有些部分内容也是相当的抽象，了解即可</p><p>重点部分</p><ul><li>数据链路层的互联设备<span id="more"></span></li></ul><p>网络编程的主要研究在网络层中</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>给上一层交付的协议数据单元进行先添加帧尾和帧头使其成为帧</p><p>ppp帧（点对点信道的帧）</p><p>帧头帧尾作用之一是帧定界标志</p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>指的是对上层交付的传输数据没有任何限制，数据链路层的封装好像就是理所应当的，看不见的，不存在的（可以理解为你经常会忽视，你习以为常的事物）</p><h4 id="面对字节的物理链路使用字节填充"><a href="#面对字节的物理链路使用字节填充" class="headerlink" title="面对字节的物理链路使用字节填充"></a>面对字节的物理链路使用字节填充</h4><p>在发送帧之前检测定界标志，检测到定界符flag或者转义字符就前插入一个esc转义字符</p><p>如图所示：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图2022-07-1808-54-16.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图022-07-1808-54-29.png" alt=""></p><p>注意转义字符只有一个字节，10进制为27，是一个控制字符</p><h4 id="面向比特的物理链路使用比特填充"><a href="#面向比特的物理链路使用比特填充" class="headerlink" title="面向比特的物理链路使用比特填充"></a>面向比特的物理链路使用比特填充</h4><p>对数据部分进行每五个连续的比特1添加一个比特0，确保帧定界的标志成为唯一的值</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图022-07-1809-01-04.png" alt=""></p><p>在接收方时按照改规则去除比特0即可</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>提高帧的传输效率，应当使数据部分的长度更大一些</p><p>但是考虑到差错控制等多种因素，每一种数据链路层的协议都规定的帧的数据部分的最大上限</p><p>我们称其为最大传送单元MTU（Maximum Transfer Unit)</p><p>mac帧是没有定界符的，取代而之的是物理层加入一个前导码，有着相同的作用</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>比特差错，也是我们常说的误码</p><p>0变成1,1变成0 ，<del>想到了一些怪东西，不要深究</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/E42EE4FE61B7BAB7585878F6B6268C33.jpg" alt=""></p><p>在一定时间内，产生的错误在传输过程中占比，被称为误码率</p><p>这个时候我们就需要进行校验</p><h4 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h4><p>顾名思义，检测比特1是否为奇数或偶数</p><p>通信的双方指定一个校验方式</p><p>漏检率较高，计网用不着</p><h4 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h4><p>CRC (Cyclic Redundancy Check)</p><p>双方生成多项式G(X)</p><p>发送方：根据发送数据和生成的多项式计算出差错检测码（冗余码），将其添加到带传输数据的后面一起传输</p><p>简单冗余码的计算过程</p><p>首先我们需要得知待发送的信息的比特串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设为：101001</span><br></pre></td></tr></table></figure><p>生成一个多项式（随机假设的）</p><script type="math/tex; mode=display">G(x)=x^3+x^2+1</script><p>通过多项式的系数构造一个被除数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到：1101</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 使用的是模2除法，不是我们常用的十进制除法（进行的是异或运算）</p><p><img src="" alt=""></p><p>通过组合计算出来的余数就可以发送了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送的数据：101001  001</span><br><span class="line">                  余数</span><br></pre></td></tr></table></figure><p>接受方：根据发送数据和生成的多项式计算，检查余数是否为0,若不为0,说明为产生误码</p><p>直接上图：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718095630773.png" alt="image-20220718095630773"></p><p><strong>注意</strong>：咱这只是差错检测，<strong>纠错</strong>是不行的，想要纠错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>向前纠错</strong>。但是纠错码<strong>开销较大</strong>，计算机很少用</p><p>那么纠错该怎么实现呢，检错重传方式来纠正传输中的差错，或者是直接丢弃错误的帧，这都取决于数据链路层向上提供的是啥协议TCPor UDP可靠或者不可靠的 传输服务了</p><p><strong>CRC有很好的检错能力，计算也不复杂，而且易于硬件实现，所以广泛应用于数据链路层</strong></p><h3 id="可靠传输基本概念"><a href="#可靠传输基本概念" class="headerlink" title="可靠传输基本概念"></a>可靠传输基本概念</h3><p>基本概念：使用了差错检测后，出现了误码</p><p>不可靠传输服务：<strong>仅仅丢弃</strong>有误码的帧，啥也不做</p><p>可靠传输服务：发送端发到什么，接收端收什么</p><p>注意：可靠传输服务，<strong>不仅</strong>仅存在于数据链路层，在各层中都可以实现</p><p><strong>差错</strong>也有很多种：</p><p>比特差错<br>以下差错<strong>一般</strong>出现在数据链路层的上层</p><p><strong>分组丢失</strong></p><p><strong>分组失序</strong></p><p><strong>分组重复</strong></p><p><strong>再次作证了可靠传输服务</strong>，<strong>不仅仅存在于数据链路层</strong>，<strong>在各层中都可以实现</strong></p><h3 id="可靠传输的实现的机制"><a href="#可靠传输的实现的机制" class="headerlink" title="可靠传输的实现的机制"></a>可靠传输的实现的机制</h3><h4 id="停止等待协议（SW）"><a href="#停止等待协议（SW）" class="headerlink" title="停止等待协议（SW）"></a>停止等待协议（SW）</h4><p><strong>A方</strong>发送<strong>DATA分组</strong>给B方</p><p>B方检测<strong>DATA分组没有错误</strong>，返回发送一个<strong>ACK分组</strong>（表示接受成功）</p><p>A方接收到了ACK分组，OK，A方就可以呢<strong>继续发送下一个DATA分组</strong></p><p>当B方检测这个DATA分组<strong>有错误</strong>，丢掉，返回一个NAK分组（表示没有成功姐接受）</p><p>A方呢，重新再把这个DATA分组数据啊，再发送一次，直到呢B方返回一个ACK分组</p><p>图解：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718103620500.png" alt=""></p><p>诶那你就会有疑问了，如果出现A方发送的DATA数据丢失了呢，不就会出现B方什么也没收到，就什么也不返回，A方也不知道到底接没接收到，就一直处于等待接收方返回ACK/NAK的状态么。</p><p>出现这种情况，发送方内部启动个<strong>计时器</strong>，设定计时器的时间</p><p><strong>超时</strong>没收到返回分组，那我就<strong>重传</strong>原来的数据分组，这就是<strong>超时重传</strong>的概念</p><p>这个计时器的时间，一般大于发送往返的时间：图解如下</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718104421832.png" alt=""></p><p>然而呢，假设还有两种种情况：</p><p>就是出现：</p><ul><li><p>A方发送过去了，就是有点久<strong>超过了设定计时器定时 B方才接收到</strong> 或者 <strong>ACK回晚了</strong></p></li><li><p><strong>返回的ACK丢失了</strong>。</p></li></ul><p>出现这两种就会出现第二种解法：<strong>超时重传</strong>，但是啊，搞清楚了，B方式已经默认收到DATA 的，有A方又传了一个相同的DATA分组，这就是出现了<strong>分组重复</strong>的情况</p><p>这种情况需要发送方A在发送事给每个分组带上一个<strong>序号</strong>，接受方B接收该数据DATA0，检测该序号，与上一个DATA0<strong>分组序号相同</strong>就丢弃顺便返回一个ACK0（针对的DATA0的数据分组，注意啊：ACK也是需要编号的，否则依然会出现<strong>ACK重复混淆</strong> 的这种情况） ，A方就可以取消该DATA0分组的重传</p><p>继续发下一个DATA1（此时变为了1）返回的ACK1（也变为了1）</p><p>再下一个层就是为ACK0和DATA0，至此呢所有情况，都有了相应的应对方案。</p><p>上图：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718110752910.png" alt=""></p><p>值得一提的是：在PPP（点对点的信道物理链路层）中，发送时间，往返时间都是<strong>固定</strong>的，所以呢不用担心<strong>超时重传</strong>的问题，设不设定计时器重传时间，编不编号都无伤大雅，<del>除非有老鼠掐准点把你家电路吃了</del>，不过为了这个传输协议的鲁棒性，健壮型，加编号未尝不可</p><p><strong>但是在</strong>（实际的ISO协议）运输层中，这这额外的情况就很可能发生，设定往返超时的判断时间（<strong>重传时间</strong>）是需要<strong>谨慎确定</strong>的问题</p><p>注意：编号一个比特表示0/1就够了，停等协议是这样的</p><p><strong>SW协议的的信道利用率</strong></p><p>短距离，数据帧的长度低，信道利用率的能稍微高点</p><p>但实际上SW协议的新到利用率相当的低，有图可证</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718134746790.png" alt=""></p><p>可以用公式来计算：</p><script type="math/tex; mode=display">U= \frac{T_D}{T_D+RTT+T_A}</script><p>RTT是往返时间，出现重传U还要降低</p><p>为此，如此低的信道利用率太浪费资源，就有了GBN和SR协议的解决方法</p><p><strong>SW协议也被称为 自动请求重传协议ARQ（Automatic Repeat reQuest)</strong></p><h4 id="回退N帧协议（GBN）"><a href="#回退N帧协议（GBN）" class="headerlink" title="回退N帧协议（GBN）"></a>回退N帧协议（GBN）</h4><p>那么，为了解决SW协议的信道利用率，就提出了回退N帧协议</p><p>那SW协议就就连续发多个分组，跟流水线一样</p><p>但是需要做出限制，限定了一个发送窗口，记为$W_T$</p><p>当取值等于1时，等于SW协议</p><p>取值等$1&lt;W_T&lt;=2^n-1$ </p><p>n为采用几个比特给分组编号</p><p>（如$W_T$大于上限，就会出现分组重复的差错）</p><p>我们也需要给接收方设定一个接受窗口$W_R$=1</p><p>接收方只能按序接收数据分组，当发送方每收到一个ACK就往前移动一个序号的发送窗口</p><p>图如下</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100250014.png" alt=""></p><p>如果每一个序号的分组都进行发送确认ACK，开销有点大，</p><p>可以只发送序号最大的ACK4（假设发送窗口为5，采用3比特进行编号）那么发送方就知道0~4的信号接收方已接受。</p><p>那么出现差错怎么办呢</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100449425.png" alt="image-20220719100449425"></p><p>就会将所有的发送全部丢弃，每丢弃一个数据分组，就发送一个ACK4,表示我只接受到了0到4的数据分组，之前的所有数据都没有成功接收，全部需要重发。</p><p>由此可见，在网络波动大时，新到的利用率跟SW协议差不了多少。</p><p><strong>总结：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719101040194.png" alt="image-20220719101040194"></p><p>我们可以看下题解析，巩固一下理解 </p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100136847.png" alt=""></p><p>同样是一种ARQ协议，当通信线路8太行时，信道利用率和SW协议差不多</p><h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p>是GBN的改进，本质呢依然是GBN，但是更改了接收方的接收窗口的尺寸$W_r$</p><p>发送窗口与接受窗口相等，依然是按序滑动窗口（不是算法的滑动窗口，但也差不多）</p><p>出现误码，两方的窗口都不会进行滑动，直到所有数据分组确认接受，</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720084751118.png" alt=""></p><p><strong>两者的尺寸问题：</strong></p><p>发送窗口：1&lt;$W_t$&lt;=$2^{n-1}$</p><p>接受窗口：1&lt;$W_r$&lt;=$W_t$</p><p>n为编号所使用的比特数</p><p><strong>总结：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720085256472.png" alt=""></p><p>总的来说：只要理解SW（停止-等待）协议，可以发现GBN和SR都是基于SW的基础上加以改进的，理解起来都非常的容易</p><h2 id="点对点协议"><a href="#点对点协议" class="headerlink" title="点对点协议"></a>点对点协议</h2><p>点对点（ppp)协议：是目前使用最广泛的数据链路层协议，</p><p>也同时广泛应用于广域网之间的公用线路</p><p>对各种协议数据报的封装方法（封装成帧）</p><p><strong>链路控制协议LCP:</strong></p><p>用于建立，配置以及测试数据链路的链接</p><p><strong>一套网络控制协议NCPs ：</strong></p><p>其中的每一个协议支持不同的网络层协议</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720092649770.png" alt=""></p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720093302084.png" alt=""></p><h3 id="透明传输的实现"><a href="#透明传输的实现" class="headerlink" title="透明传输的实现"></a>透明传输的实现</h3><p>面对字节的异步传输链路：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094210308.png" alt=""></p><p>面对比特的同步传输链路：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094329746.png" alt=""></p><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094605294.png" alt=""></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094946553.png" alt=""></p><p>静止状态，检测到载波（物理层提供的服务）建立物理层的链接，跳转到建立状态</p><p>建立状态，开始进行LCP配置</p><p>鉴别状态，根据LCP配置的鉴别协议选择是否鉴别，成功跳转到网络的NCP配置阶段，失败即终止</p><p>网络状态。进行NCP配置，链路两端互相发发送特定NCP分组，根据使用的控制协议比如 IP-CP协议，就发送IPCP 的配置模块（作用是分配IP地址），成功后跳转到打开状态</p><p>打开状态，表明可以进行数据通信，如果出现故障或者终止请求，跳转至终止状态</p><p>终止状态，检测到载波停止时回到静止状态。</p><h2 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h2><h3 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h3><p>接入控制与碰撞检测协议</p><p>共享信道，需要协调多个发送接受站点对一个传输媒体的占用</p><p>这里我们引入媒体接入控制的概念</p><p><img src="/home/icrad/.config/Typora/typora-user-images/image-20220720105614322.png" alt="image-20220720105614322"></p><p>我们需要大概了解静态划分信道与动态接入控制中的随机接入</p><h4 id="静态划分信道："><a href="#静态划分信道：" class="headerlink" title="静态划分信道："></a>静态划分信道：</h4><p>信道复用实现：</p><p><strong>频分复用FDM</strong>：</p><p>按照频率不同区分信道，复用器与分用器 是并行通信</p><p><strong>时分复用TDM：</strong></p><p>划分时间，设定不同的时隙，串行通信</p><p><strong>波分复用WDM：</strong></p><p>可以理解为光波的频分复用，光复用器与光分用器</p><p><strong>码分复用CDM：</strong></p><p>在同时同频带进行并行通信，根据的不同码型区分信道</p><p>我觉得挺有意思的，<del>是歪比巴卜加密通信</del>，其中有个概念叫码片（chip)：每一个比特时间再划分的M个端间隔间隔</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720112705746.png" alt=""></p><p>应用举例：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720113025648.png" alt=""></p><p><strong>注意多址（MA）与复用的关系</strong>：</p><p>多址用与在动态的信道分配，固定的地址例如无线电则不需要多址，多址可以看成复用的应用</p><h4 id="随机接入协议："><a href="#随机接入协议：" class="headerlink" title="随机接入协议："></a>随机接入协议：</h4><p><strong>CSMA/CD协议：</strong></p><p>载波监听（<strong>C</strong>heck_<strong>S</strong>ign）: 监听信道否有载波</p><p>多址接入（<strong>M</strong>utli <strong>A</strong>ddress）：多个连接占在一条总线上，随机时间发送帧</p><p>碰撞检测（C D）：遇到碰撞，退避随机时间重新发送，强化碰撞（发送干扰信号，相当于放大碰撞）</p><p>关键概念：</p><p>争用期：争用期时间指的是，不会超过端到端往返时间时延的时间。</p><p><strong>注意：</strong>共享式以太网不能链接太多的主机，使用的总线也不能太长。</p><p>最小帧长：以太网规定最喜小帧长为64字节，即521比特（512比特时间为争用期）</p><p>作用是保证能在帧发送完成之前能检测到是否发生碰撞。</p><p>最大帧长：<br>以太网V2的MAC帧最大长度1518字节加上帧头与帧尾</p><p>帧的发送流程：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721155821739.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721155917409.png" alt=""></p><h3 id="802-11局域网（Wlan）"><a href="#802-11局域网（Wlan）" class="headerlink" title="802.11局域网（Wlan）"></a>802.11局域网（Wlan）</h3><p><strong>CSMA/CA协议：</strong></p><p>应用于无线局域网的多址碰撞检测</p><p>CA（碰撞避免）</p><p>是重点，也是核心，无线信道，想要检测道碰撞，成本太高了</p><p>所以呢提出了新的概念，也就是CA；</p><p>CA中利用了SW协议，在尽量避免碰撞，又提出了虚拟载波监听（数据帧中也携带通信的需要时间），与信道预约（RTS与CTS帧（这两个帧携带通信需要时间）</p><p>看到这是不是觉得非常敷衍，是的，我开始摆烂了，记几个概念得了，再深入，就不止是考研的范畴了。</p><h2 id="数据链路层的互连设备"><a href="#数据链路层的互连设备" class="headerlink" title="数据链路层的互连设备"></a>数据链路层的互连设备</h2><h3 id="前置概念："><a href="#前置概念：" class="headerlink" title="前置概念："></a>前置概念：</h3><p>首先在研究互联设备之前，我们需要清楚三个概念：</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC是以太网的MAC子层所使用的地址(物理链路层)</p><p>以太网帧的结构</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726155123275.png" alt=""></p><p>ppp信道不需要使用地址（因为只有两者）</p><p>帧里必须携带发送朱局和接收主机的地址，由于这类地址是通榆媒体介入控制</p><p>，因此这类地址被称为MAC地址</p><p>MAC 地址一般放在网卡的EEPROM中，也被称为硬件（物理）地址</p><p>注意（并非叫物理就是物理层的内容）</p><p>各种硬件接口都有MAC地址，所以</p><p><strong>严格来讲：MAC 地址是网络上各接口的唯一标识，而不是对网络上各设备的唯一标识</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721164243056.png" alt=""></p><p>48个字节，好像有几百亿的地址，起码用到2080年才用得完</p><p>我们通过MAC地址了解厂商信息；</p><p>也可以了解到MAC也有四种：</p><ul><li><p>全球：</p><ul><li>单播地址</li><li>多播地址</li></ul></li><li><p>本地（优先级最高）</p><ul><li>单播地址</li><li>多播地址</li></ul></li></ul><p>单播地址 应用于1对1设备</p><p>多播地址 应用于是以1 对多设备</p><h4 id="IP地址（网络层）"><a href="#IP地址（网络层）" class="headerlink" title="IP地址（网络层）"></a>IP地址（网络层）</h4><p>IP是TCP/IP体系结构网际层所使用的地址：</p><p>应用：因特网上的主机和路由器所使用的地址</p><p>注意这只是大概应用图：（具体实现在网络层中）</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721170406278.png" alt=""></p><h4 id="ARP协议（网络层）"><a href="#ARP协议（网络层）" class="headerlink" title="ARP协议（网络层）"></a>ARP协议（网络层）</h4><p>ARP协议是属于TCP/IP的东西，能将IP地址解析下一个路由或者设备的相应MAC地址并在数据链路中重新封装</p><p>ARP（Address 解析 协议）高速缓存表：</p><p>用来存储的东西</p><p><strong>注意一下arp报文都是封装在MAC帧当中的</strong></p><p>在数据链路层，向所有主机发送ARP请求报文</p><p>根据其中请求的ARP请求报文检验啊，是否是来请求自己的，如果不是，就丢掉</p><p>如果是，交给上层网络层ARP进程 解析 先记录请求报文的主机IP与MAC 地址于自己的ARP高速缓存表中：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721172516670.png" alt=""></p><p>然后向下 数据链路层 再向发送请求的主机，一个ARP响应报文，其中包含自己的MAC 与ip地址，</p><p>收到了ARP响应报文，网络层的ARP进程进行解析，然后记录到自身的ARP告诉缓存表</p><p>注意不能跨网络使用</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721173048276.png" alt=""></p><p>注意了：</p><p>ARP还有其他报文，比如，免费报文（用来检测IP是否冲突）</p><p>ARP协议没有安全验证机制，有写人就会利用ARP进行攻击，ARP欺骗等问题</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><ul><li>物理层中工作</li><li>仍是一个总线网，各站点共享总线资源，使用的还是CSMA/CD协议</li><li>又少量的容错和网络管理</li><li>集线器在物理层扩展以太网</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721174048318.png" alt=""></p><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721174853814.png" alt=""></p><ul><li>其中的存储转发：就是交换机内的数据链路层的帧号的缓存存储，再根据表转发</li><li>而直通交换，不需要检测 就是帧容易出错</li></ul><p>总结集线器与交换机双方对比：</p><p>一张图足矣</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721175546494.png" alt=""></p><p>所以，碰撞这一块。。。CSMA/CD /CA 协议</p><p>我之前如果只学交换机是不是完全不需要考虑总线碰撞的问题呢？<del>MD，白学了</del></p><h4 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721194240363.png" alt=""></p><p><strong>总结：</strong></p><p>登记遍历，无泛洪，有转发</p><h4 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h4><p>为了在给交换机增加冗余链路 ，增加可靠性的同时，不会出现网络环路（类似C++的头文件循环包含问题），网络环路带来的问题就是容易出现广播风暴（广播帧会多次转发，导致交换机堵塞，瘫痪）</p><p>需要用到一个算法协议STP生成树协议，这玩意，能将拓扑结构网络中不需要转发的窗口阻塞禁用，从而阻止广播风暴的问题</p><p>具体就是使用STP协议请移步这篇文章</p><h3 id="VLAN（虚拟局域网）"><a href="#VLAN（虚拟局域网）" class="headerlink" title="VLAN（虚拟局域网）"></a>VLAN（虚拟局域网）</h3><p>由于网络中会频繁出现广播信息，然而纯交换机组成的以太网会组成一个非常大的广播域，如果在这个广播域中，出现广播风暴，那是相当浪费网络资源和CPU的。</p><p><del>就是又STP协议也不顶用啊</del></p><p>所以，就需要有一个能够将广播域分割的方法</p><p>这就不得不拿出路由器了</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722083808830.png" alt=""></p><p>可是，这玩意的成本很高（相对于集线器与交换机而言），虽然也不是很高了现在，但也不能每两交换机之间就用一个罢，咱有钱也不能这么造不是？</p><p>这时，为了省钱呢，虚拟局域网VLAN诞生啦</p><p>这玩意概念上是</p><p><strong>将一个局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</strong></p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>IEEE 802.1Q帧（Dot One Q帧）</strong></p><p>是交换机在收到普通帧时的在扩展，插入了一个4字节的VLAN标记<img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722084927719.png" alt=""></p><ul><li>VLAN标记的最后12比特 成为VLAN标识符VID ，唯一地标志了以太网帧属于哪一个VLAN<ul><li>VID取值范围是0~4095( 0~$2^{12}-1$)</li><li>0和4095不表示VLAN，因此用于表示VLAN的VID取值也就是1~4094</li></ul></li><li><strong>注意</strong>这个帧是交换机来处理的，不是用户主机处理：<ul><li>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记，俗称打标签</li><li>转发的时候，按需求取掉或者保留标签转发</li></ul></li></ul><p>以上是</p><p><strong>交换机各端口的缺省VLAN ID</strong></p><ul><li>在思科交换机称为Native VLAN,即本征VLAN</li><li>在华为交换机上称为Port VLAN ID ，即端口VLAN ID ,简记为PVID（唯一的）。</li></ul><p><strong>注意：接下来我们讨论的是PVID</strong></p><p><strong>交换机端口类型</strong></p><ul><li><strong>Access</strong><ul><li>一般用于连接用户计算机</li><li>只能属于一个VLAN</li><li>PVID值与端口所属的VLAN的ID相同（默认为1）</li></ul></li></ul><p>接收：一般只接受未打标签的普通帧，再根据接受真的端口的PVID给帧打标签，字段中的VID 取值与PVID取值相等。</p><p>转发：检查帧中的VID与端口的PVID相等，则去标签，转发，否则就不转发。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722091128900.png" alt=""></p><ul><li><strong>Trunk</strong><ul><li>交换机之间或者交换机与路由器的互联</li><li>可以属于多个VLAN</li><li>用户可以设置端口的PVID值，默认为1.</li></ul></li></ul><p><strong>发送第一种情况</strong>：检测VID与PVID相等的帧，打标签，再转发</p><p><strong>接受第一种情况</strong>：接受到一个<strong>未打标签</strong>的帧，根据<strong>接收帧的端口PVID</strong>给帧打标签</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722091938090.png" alt=""></p><p><strong>发送第二种情况</strong>：接受一有标签但是PVID不等VID的帧，直接转发</p><p><strong>接受第二种情况</strong>：接受到一个打标签的帧，我直接带着标签转发</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722092327523.png" alt=""></p><ul><li><strong>Hybrid(思科没有)</strong></li></ul><p>同时具有Access与Trunk的特性：</p><p>端口可以互连：用户主机与交换机，交换机交换机，用户与用户</p><p>不同的地方在于：端口多了个 去标签白名单</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722093740897.png" alt=""></p><p>至此，数据链路层的内容结束</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第二节|物理层</title>
      <link href="/2022/07/17/internet02/"/>
      <url>/2022/07/17/internet02/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章了解个概念，不深究，比较抽象</p><span id="more"></span><h2 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h2><p><strong>明确：考虑怎么链接各种计算机之间传输比特流数据</strong></p><p>四个特性</p><ul><li><p>机械</p><p>接口类型</p></li><li><p>电气</p><p>电压</p></li><li><p>功能</p><p>传输1/0编码</p></li><li><p>过程</p><p>时种顺序</p></li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><p>注意传输介质实际上不属于物理层</p><h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul><li><strong>双绞线</strong></li></ul><p>两根，按一定规则双绞，抗干扰</p><ul><li><p><strong>同轴电缆</strong></p></li><li><p><strong>光纤</strong></p><ul><li><p>单模光纤：波导,就是贵，对光信号要求高</p></li><li><p>多模光纤：全反射</p><p>优点：带宽大,损耗低</p></li></ul></li><li><p><strong>电力线</strong></p><p>适合短距离</p></li></ul><h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><p>(自由空间)</p><ul><li><strong>微波</strong></li></ul><p>直线，电离层无折射，需要中继站，典型5G通信</p><ul><li><strong>无线电波</strong></li></ul><p>电离层折射，距离远</p><ul><li><strong>可见光</strong></li></ul><p>应用：lifi</p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>一条数据传输线路</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>多条数据传输线路</p><p><strong>计算机内部常用并行传输</strong></p><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><h4 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h4><p>连续无间隔</p><p><strong>外同步</strong></p><p>多加一条单独的时钟信号线</p><p><strong>内同步</strong></p><p>市中心号线与发送数据曼彻斯特编码</p><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>异步的体现：字节之间的时间间隔不固定</p><p>需要字节需要加上起始位和结束位</p><p>但各比特的持续时间是相同的</p><p>字节异步，比特同步</p><h3 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h3><p>单向</p><h3 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h3><p>双向不同时</p><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>同时双向</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p>关于编码与调制我们需要了解：</p><p>信息-&gt;数据（二进制）-&gt;信号（电磁表现）</p><p>数字基带信号的数字</p><p>模拟基带信号</p><p>两者都有编码和调制</p><h3 id="数字基带信号"><a href="#数字基带信号" class="headerlink" title="数字基带信号"></a>数字基带信号</h3><p>编码（数字信号转化数字信号）：以太网下的曼彻斯特编码，4B/5B 走的是数字信道</p><p>调制（数字信号转化模拟信号）：WIFI CCK/DSS/OFDM调制，走的是模拟信道</p><h3 id="模拟基带信号"><a href="#模拟基带信号" class="headerlink" title="模拟基带信号"></a>模拟基带信号</h3><p>编码（数字信号转化数字信号）：音频信号的PCM脉码调制，走的是数字信道</p><p>调制（数字信号转化模拟信号）：FDM频分复用，充分利用带宽资源，走的是模拟信道</p><p><del>啊~这熟悉又陌生的的名词</del></p><p><strong>注意</strong></p><p>传输媒体不等于信道</p><p>不同的传输媒体，包含多个不同数量的信道</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h4><p>自同步，编码效率低，需要归零</p><h4 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h4><p>需要多一条信道传输时钟信号，这玩意不能用来传递时钟信号</p><h4 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h4><p>码元为单位，以中间的信号跳变表示0/1</p><p>跳变有表示时钟，又表示数据</p><p>（是传统以太网10Mb/s）</p><h4 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h4><p>跳变只表示时钟</p><p>码元开始处 的电平是否发生变化表示数据，</p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字基带信号</p><p>频率，振幅，相位</p><h4 id="二元调制："><a href="#二元调制：" class="headerlink" title="二元调制："></a>二元调制：</h4><p>只有<strong>两种</strong>码元</p><p><strong>调幅AM</strong></p><p><strong>调频FM</strong></p><p><strong>调相PM</strong></p><p>调频和调相<strong>不能一块调</strong>，调幅调相可以同时，或者调频调幅</p><h4 id="混合调制："><a href="#混合调制：" class="headerlink" title="混合调制："></a>混合调制：</h4><p><strong>调频和调相混合</strong></p><p>至少可以有<strong>四种</strong>码元，若是有4个相位，4种振幅，可以调出16个不同的波形，也就是码元</p><p>我们再以二进制处理这16种码元</p><script type="math/tex; mode=display">log_216=4</script><p>可以算出每个码元所还能携带的信息量为4比特</p><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p><strong>奈氏准则</strong>，假定的理想条件下，避免码间串扰，码元的传输速率是有上限的</p><p>不考虑信噪比</p><p>理想低通信道的最高码元传输速率=2W Baud= 2W(单位：码元/s)</p><p>理想带通信道的组稿码元传输速率=W Baud= W（单位：码元/s）</p><p>W指的是，信道带宽hz</p><p>那么要考虑噪声，引出<strong>香农公式</strong></p><p>带宽受限 且高斯白噪声干扰的信道的极限信息的传输效率</p><script type="math/tex; mode=display">c=W*log_2(1+\frac{S}{N})~~~~（单位：bit/s）</script><p>综上奈氏准则和香农公式，要想<strong>提高信息的传输速率</strong>就必须用<strong>多元</strong>制的调制方式，努力提高<strong>信道中的信噪比</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思维导图：不着急，躺平摸鱼</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础，物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第一节</title>
      <link href="/2022/07/15/Internet01/"/>
      <url>/2022/07/15/Internet01/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络基础-第一节"><a href="#计算机网络基础-第一节" class="headerlink" title="计算机网络基础|第一节"></a>计算机网络基础|第一节</h1><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/728da9773912b31bad1719cedfd48473dbb4e130.png" alt="img"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学校网课不努力，B站大学再继续。实在努力不下去，美团饿么当兄弟。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/9bb444786eaac9678f1b8574db28d03b69cef878.jpg@942w_942h_progressive.webp" alt="img"></p><span id="more"></span><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p>两个以上主机可发送接受信息的互连的，可自治的，组成计算机网络</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="常用以下8个"><a href="#常用以下8个" class="headerlink" title="常用以下8个"></a>常用以下8个</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h4><p><strong>比特 bit 数据量单位</strong></p><p>代表：一个数0/1</p><p>字节=B</p><p>8bit=1B;</p><p>注意：<strong>依次乘与2的10次方</strong></p><p><strong>K-&gt;M-&gt;G-&gt;T</strong></p><p>举个例子</p><p>我们购买的硬盘，商家标的是250GB为什么在操作系统中却只有232.8GB呢</p><p>我们看下面的一个公式：</p><script type="math/tex; mode=display">\frac{250*10^{9} } {2^{30} }=232.8（GB）</script><p>商家的计算方式是G 为10的9次方，操作系统中数据量的G 是2的30次方</p><p><strong>比特率</strong>速率单位 bit/s</p><p>注意：<strong>依次乘与10的3次方</strong></p><p><strong>k-&gt;M-&gt;G-&gt;T</strong></p><p><strong>与数据量不同</strong></p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h4><p>在<strong>模拟信号</strong>中 ：单位<strong>Hz</strong></p><p>表达的是信号频率范围</p><p>在<strong>计算机网络</strong>中：</p><p>可以理解为网络中点到点传输的 最高数据率</p><p>单位b/s与比特率相同</p><p>这两者其实表述都是有联系的，带宽频率越宽，网络越好</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图50.png" alt=""></p><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3.吞吐量"></a>3.吞吐量</h4><p>单位时间通过的数据量</p><p>受到带宽限制</p><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><p>总的来说就是传输数据的时间</p><p>可以细分为：</p><p>网络时延：发送，传播，处理</p><ul><li>发送时延：分组长度/发送速率</li></ul><ul><li><p>传播时延</p><p>计算是有公式的</p><p>信道长度/电磁波传播速率 </p><p>然而在不同的传输介质中传播速率是不同的</p><p>这里列出3个不同的常见的传播介质</p><ul><li>光纤</li><li>忘了</li><li>是啥来着？</li></ul></li><li><p>处理时延：不方便计算</p></li></ul><h4 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h4><p>传播时延乘与带宽的乘积</p><p><img src="/home/icrad/图片/截图/截图 2022-07-15 19-11-41.png" alt=""></p><p>链路的时延带宽积又称为以比特为单位的链路长度</p><h4 id="6-往返时间"><a href="#6-往返时间" class="headerlink" title="6.往返时间"></a>6.往返时间</h4><p>数据双向交互一次的时间</p><p>我们简称为<strong>RTT(Round-Trip Time)</strong></p><h4 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h4><ul><li><p>信道利用率：有百分之几的时间是被利用的</p></li><li><p>网络利用率：全网络的信道利用率的加权平均。</p></li></ul><p>根据排队论，信道的利用率增大时，该信道引起的时延也会迅速增加</p><p>因此信道利用率并非越高越好</p><p>如果令<script type="math/tex">D_0</script>表示为网络空闲的时延，D表示当前的时延，那么在适当的假定条件下，可以用以下的简单公式来表示D与<script type="math/tex">D_0</script>和利用率U之间的关系</p><script type="math/tex; mode=display">D=\frac{D_0} {1-U}</script><ul><li>当网络的利用率达到50%时，时延加倍</li><li>当利用率超过50%时，时延急剧增大</li><li>当网络利用率接近100%时，时延趋于无穷大</li><li>依次一些拥有交大主干网的ISP通常会控制他们的新到利用率不超过50%,如果超过了，就扩容，增加带宽。</li><li><strong>注意</strong>：也不能太低，浪费了宝贵的通信资源，设定一个程序机制来根据情况动态调整网络中的通信量，是网络利用率保持在一个合理的范围内</li></ul><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><p>即分组的丢失率</p><ul><li>一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li><li>可以分为接口丢包率，结点丢包率，链路丢包率，路径丢包率，网络丢包率等</li></ul><p>分组丢失主要有两种情况：</p><ul><li><p>分组在传输的过程中，出现误码，被结点丢弃；</p></li><li><p>分组到达一台队列已满的分组交换机时被丢弃；在通信量较大是就可能造成网络拥塞</p></li><li><p>因此 丢包率也可以反应网络的拥塞情况</p><ul><li><p>无拥塞时路径丢包率为0；</p></li><li><p>轻度拥塞时路径丢包率为1%~4%</p></li></ul></li></ul><ul><li>严重时可达到5%~15%</li></ul><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p>有三种常见的计算机网络体系结构</p><ul><li><p><strong>法律上的国际标准(OSI)</strong></p><p>有七层：我不考研简单知道一下就够了，实际上开发不会用到这个框架</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图414.png" alt=""></p></li><li><p><strong>实际上的国际标准(TCP/IP)</strong></p><p>表明了各种层的协议</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图.png" alt=""></p></li><li><p><strong>原理体系结构（在学习中我们主要遵循的）</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图54.png" alt=""></p></li></ul><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>分层的思想：以大化小，以小化了</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>需要解决：</p><ul><li><p>传输介质</p></li><li><p>物理接口</p></li><li><p>什么信号</p></li></ul><p>严格来说：传输媒体并不属于物理层</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>需要解决：</p><ul><li>目的主机该如何标识（主机编址）</li><li>目的主机识别出力分组数据的封装</li><li>协调多个主机之间的数据交换（一个网络或一段链路）</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>需要解决：</p><ul><li>网络以及网络中的各主机的共同编址问题（多个网络（路由））</li><li>路由器该怎么转发分组，路由的选择</li></ul><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>需要解决：</p><ul><li>不同网络应用进程之间的通信(<strong>端到端</strong>的逻辑通信，不是端口到端口)</li><li>出错与异常的解决（丢包，误码等）</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>需要解决：</p><ul><li>不同网络进城程间的通信的基础上，规定特定的技术协议运用</li></ul><h3 id="分层的思想示例"><a href="#分层的思想示例" class="headerlink" title="分层的思想示例"></a>分层的思想示例</h3><p>简单的图解（图片来源湖南科技大学课程）：<br><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图2022-07-1623.png" alt=""></p><p>可以简单理解为：邮件的传输</p><p>个人主机：</p><ul><li><p>首先在<strong>应用层</strong>我们写了一个信件（<strong>报文</strong>） 内容规则可以是http，FTP，我们放在了自家的邮寄箱中 </p><p>这个时候来了个小哥来拿，他根据你在的地方，寄的信件内容类型呢，加了个邮局分局的地址等一系列信息，进行了一个简单的包装</p><p>（<strong>运输层</strong>根据tcp协议的规定 添加端口等一系列信息的<strong>TCP首部</strong>，成了一个<strong>TCP报文段</strong>）</p></li><li><p>拿到了你这个地区的邮局站，根据你要寄的地址分号码分类</p><p>（<strong>网络层</strong>加了个<strong>IP首部</strong>，成为了一个<strong>IP数据报</strong>）</p></li><li><p>然后根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>（<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p></li></ul><p>（帧交给物理层，加了个前导码，目的是为了让目的主机做好帧接受的准备）</p><p>​    </p><p>通过链路到达了另外一个邮寄站点（路由） </p><ul><li><p>物理层将信件货物拆解，去掉上一个标签</p><p>（比特流化为帧）</p></li><li><p>再将其交付给处理信件地址的网络层解析（提取查找路由表，确定转发端口 指定下一个路由或者地址）</p></li><li><p>再重新根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>(<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p><p>（<strong>帧</strong>交给<strong>物理层</strong>，加了个<strong>前导码</strong>，目的是为了让目的主机做好帧接受的准备）</p></li></ul><p>  以下内容都是同理</p><p>  （重复解析封装一发送）</p><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>任何可发送或接受信息的硬件或者软件进城</p><h4 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h4><p>相同层次中的实体</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120751857.png" alt=""></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>控制两个对等实体进行逻辑通信的规则的集合</p><p>注意：<strong>逻辑通信</strong>，的意思是，这个通信的的规则不是存在的，是假设的一种通信，单独简化研究，同理逻辑接口</p><p>三要素：</p><ul><li>语法：定义交换信息的格式（各种分组格式http ftp等）</li><li>语义：定义通信双方所要完成的操作</li><li>同步：定义收发双方的时序关系（<strong>三次握手</strong>）</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120824649.png" alt=""></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>协议的控制下，<strong>对等实体</strong>的逻辑通信向上层提供服务</p><p>实现本层的协议需要，使用下面一层所提供的服务</p><p>协议是<strong>水平</strong>的，服务是<strong>垂直</strong>的</p><ul><li><p>服务访问点：相邻两层的逻辑接口，用于交换两层之间的是实体信息，区分不同的服务类型</p><ul><li>数据链路层的服务访问点为帧的<strong>类型字段</strong></li><li>网络层的服务访问点为ip数据报首部的<strong>协议字段</strong></li><li>运输层的服务访问点为<strong>端口号</strong></li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120844704.png" alt=""></li></ul></li></ul><p>  <strong>协议数据单元</strong></p><p>  PDU：对等层次之间传送的数据包称为该层的协议数据单元</p><p>  SDU：同一系统系统内服务数据单元 层与层之间交换的数据包成为服务数据单元</p><p>  多个SDU 可以合成为一个PDU</p><p>  一个SDU 也 可以分为多个PDU </p><p>  比特-&gt;帧-&gt;ip数据段-&gt;tcp/udp数据报-&gt;报文</p><p>  <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图27.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不着急写，<del>随便做个思维导图糊弄一下</del></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB基础</title>
      <link href="/2022/07/14/GDB/"/>
      <url>/2022/07/14/GDB/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB的调试"><a href="#GDB的调试" class="headerlink" title="GDB的调试"></a>GDB的调试</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gdb.jpg" alt=""></p><p><strong>GDB (GUN DEBUGGER)</strong></p><ol><li><p>设置断点</p></li><li><p>单步运行</p></li><li><p>查看变量值</p></li><li><p>动态改变执行环境</p></li><li><p>分析崩溃产生core文件</p><span id="more"></span></li></ol><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g test.cpp -o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#生成可调试的执行文件</span></span><br></pre></td></tr></table></figure><h3 id="GDB-常用指令"><a href="#GDB-常用指令" class="headerlink" title="GDB 常用指令"></a>GDB 常用指令</h3><p>​    说多也不多，毕竟现在调试大多都是gui调试，暂时很少直接用gdb命令行进行调试，写几个比较基础的<del>糊弄糊弄，就记住几个</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gdb [file]</span><br><span class="line"><span class="comment">#执行gdb调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入gdb，可以直接输入命令</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span>(b) [num]</span><br><span class="line"><span class="comment">#在第num行代码设置断电</span></span><br><span class="line"></span><br><span class="line">info breakpoint </span><br><span class="line"><span class="comment">#查看当前代码信息</span></span><br><span class="line"></span><br><span class="line">display [变量]</span><br><span class="line"><span class="comment">#显示变量，在每次运行到断点显示值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line"><span class="comment">#继续运行</span></span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"><span class="comment">#运行程序</span></span><br><span class="line"></span><br><span class="line">quit</span><br><span class="line"><span class="comment">#退出GDB调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更多的我也记不到了，用man gdb指令查吧</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>程序出现段错误时，GDB打开可调试的执行文件，直接运行，程序停止位置表示段错误的位置</p>]]></content>
      
      
      <categories>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
            <tag> C++ </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G++基础</title>
      <link href="/2022/07/14/Gcc/"/>
      <url>/2022/07/14/Gcc/</url>
      
        <content type="html"><![CDATA[<h2 id="G-GCC基础"><a href="#G-GCC基础" class="headerlink" title="G++/GCC基础"></a>G++/GCC基础</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gcc.png" alt=""></p><h3 id="编译过程有四步"><a href="#编译过程有四步" class="headerlink" title="编译过程有四步"></a>编译过程有四步</h3><span id="more"></span><ol><li><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp -o test.i</span><br><span class="line"><span class="comment">#预处理为.i文件</span></span><br><span class="line"><span class="comment">#头文件啥的的预定义啥的</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.i -o test.s</span><br><span class="line"><span class="comment">#编译为汇编语言输出为.s文件</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c test.s -o test.o</span><br><span class="line"><span class="comment">#编译为机器语言输出为.o</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ test.o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#生成为可执行文件test，二进制的文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="GCC-G-的优化选项"><a href="#GCC-G-的优化选项" class="headerlink" title="GCC/G++的优化选项"></a>GCC/G++的优化选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本优化</span></span><br><span class="line">-O </span><br><span class="line"><span class="comment">#等效O1</span></span><br><span class="line">-O0</span><br><span class="line"><span class="comment">#不做优化</span></span><br><span class="line">-O1</span><br><span class="line"><span class="comment">#为默认优化</span></span><br><span class="line">-O2</span><br><span class="line"><span class="comment">#默认优化+额外的调整</span></span><br><span class="line">-O3</span><br><span class="line"><span class="comment">#默认优化+额外的调整+循环展开等处理特性的优化</span></span><br><span class="line"></span><br><span class="line">g++ test.cpp -O2 -o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#优化等级2生成可执行文件test</span></span><br></pre></td></tr></table></figure><p>所谓优化就是提升效率，编译时间换取执行效率</p><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span><span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> result;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> temp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> five;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有很多计算步骤都都在循环条件里</span></span><br><span class="line"><span class="keyword">for</span>(counter=<span class="number">0</span>;counter&lt;<span class="number">2000</span>*<span class="number">2000</span>*<span class="number">100</span>/<span class="number">4</span>+<span class="number">2010</span>;counter+=(<span class="number">10</span><span class="number">-6</span>)/<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">temp+=counter/<span class="number">1979</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">five=<span class="number">200</span>*<span class="number">200</span>/<span class="number">8000</span>;</span><br><span class="line">result=counter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;result=&quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试优化O2与不优化O0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -O2 -o Youhua</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -O0 -o NotYouhua</span><br></pre></td></tr></table></figure><p>再依次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time ./Youhua</span><br><span class="line">time ./NotYouhua</span><br></pre></td></tr></table></figure><p>可以看见优化后的执行效率相当高</p><h3 id="指定库文件与头文件"><a href="#指定库文件与头文件" class="headerlink" title="指定库文件与头文件"></a>指定库文件与头文件</h3><p>库的指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ -lglog test.cpp</span><br><span class="line"><span class="comment">#链接golg 库</span></span><br><span class="line"></span><br><span class="line">g++ -L/home/icrad/mylibfolder -lmylib test.cpp</span><br><span class="line"><span class="comment">#链接自己的指定的库文件夹下的库文件，需要大写</span></span><br></pre></td></tr></table></figure><p>头文件的指定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般来说，是不需要指定的，GCC默认去找include文件夹，当不存在时，就需要自己指定了头文件目录了</span></span><br><span class="line"></span><br><span class="line">g++ -I/myinclude test.cpp</span><br></pre></td></tr></table></figure><h3 id="基本常用的其他项"><a href="#基本常用的其他项" class="headerlink" title="基本常用的其他项"></a>基本常用的其他项</h3><ul><li><p>-Wall</p><p>打印警告信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall test.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-w</p><p>关闭警告信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -W test.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-std=c++11</p><p>指定C++ 特性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 test.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-o</p><p>编译输出可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-D</p><p>定义宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用场景，可以在编译的时候选择是否 执行宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;DEBUG_LOG&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ubuntu,yes!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译这个文件时可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -DDEBUG test.cpp -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>生成的执行文件会将宏定义中的代码输出</p><p>如果没有定义宏，只会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu,yes!</span><br></pre></td></tr></table></figure></li></ul><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g test.cpp -o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#生成可调试的执行文件</span></span><br></pre></td></tr></table></figure><h3 id="编译示例"><a href="#编译示例" class="headerlink" title="编译示例"></a>编译示例</h3><h4 id="多文件夹的目录结构"><a href="#多文件夹的目录结构" class="headerlink" title="多文件夹的目录结构"></a>多文件夹的目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── include</span><br><span class="line">│   └── swap.h</span><br><span class="line">├── math.cpp</span><br><span class="line">└── src</span><br><span class="line">    └── swap.cpp</span><br></pre></td></tr></table></figure><ul><li><h4 id="直接编译"><a href="#直接编译" class="headerlink" title="直接编译"></a>直接编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ math.cpp -std=c++11 src/swap.cpp -Iinclude</span><br><span class="line"><span class="comment">#记得引入头文件</span></span><br></pre></td></tr></table></figure><p>即可生成可执行文件a.out </p></li></ul><ul><li><h4 id="链接生成静态库"><a href="#链接生成静态库" class="headerlink" title="链接生成静态库"></a>链接生成静态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将src的文件夹下的swap.cpp生成为.o文件(汇编语言)</span></span><br><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line">g++ swap.cpp  -c -I../include</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行归档操作</span></span><br><span class="line">ar rs libswap.a swap.o</span><br><span class="line"><span class="comment">#作用是将swap.o归档为一个静态库文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..<span class="comment">#回到上级目录</span></span><br><span class="line">g++ math.cpp -lswap -Lsrc -I\include -o static_swap</span><br><span class="line"><span class="comment">#链接指定的静态库进行编译</span></span><br><span class="line"><span class="comment">#最终得到可执行文件static_swap</span></span><br></pre></td></tr></table></figure></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><ul><li><h4 id="链接生成动态库"><a href="#链接生成动态库" class="headerlink" title="链接生成动态库"></a>链接生成动态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line"></span><br><span class="line">g++ swap.cpp -I../include -fPIC -shared -o libswap.so</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">gccswap.cpp -I../include -c -fPIC </span><br><span class="line"><span class="comment">#生成.o文件</span></span><br><span class="line">gcc -shared -o libswap.so swap.o</span><br><span class="line"><span class="comment">#生成静态库文件libswap.so</span></span><br><span class="line"></span><br><span class="line">回到上级目录</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">g++ math .cpp -Iinclude -lswap -Lsrc -o dyna_swap</span><br><span class="line"><span class="comment">#生成了可执行的文件dyna_swap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态库的可执行文件需要指定搜索路径</p><p>为什不直接设定系统的环境变量？避免与系统重复</p><p>第一种方法（临时测试用 ——推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=src ./dyna_swap</span><br><span class="line"><span class="comment">#指定了动态库的搜索路径运行该可执行文件</span></span><br></pre></td></tr></table></figure><p>第二种方法：可以配置用户终端的环境变量（不推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改当前目录的bashrc文件</span><br><span class="line">再最后行加入动态库的路径</span><br><span class="line">LD_LIBRARY_PATH=</span><br></pre></td></tr></table></figure></li><li><p>第三种的方法（推荐）</p><ul><li><p>找到动态库连接器的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">sudo vi ld.so.conf</span><br></pre></td></tr></table></figure></li><li><p>将动态库的路径写到配置文件中，绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态库的路径</span><br></pre></td></tr></table></figure></li><li><p>更新 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig -v</span><br></pre></td></tr></table></figure><p>更新后就可以使用该链接动态库的程序的执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd </span><br><span class="line"><span class="comment">#查看执行文件的动态库连接</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>静态库与静态库的区别：大小，前者更大，直接包含在执行文件中了，而动态库在调用相应函数时才会加载，所以在运行时，静态库不需要指定路径直接运行，而动态库需要。</p>]]></content>
      
      
      <categories>
          
          <category> GCC/G++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> G++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的更新与备份</title>
      <link href="/2022/07/14/blog/"/>
      <url>/2022/07/14/blog/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的更新与备份"><a href="#博客的更新与备份" class="headerlink" title="博客的更新与备份"></a>博客的更新与备份</h2><p>基于hexo的博客，搭建在github的仓库中</p><p>我们要实现在不同的系统与电脑中进行修改，与同步</p><span id="more"></span><h3 id="需要以下条件"><a href="#需要以下条件" class="headerlink" title="需要以下条件"></a>需要以下条件</h3><ol><li>Nodes.js</li><li>npm</li><li>git</li><li>博客源文件已经部署在github的仓库中（建议部署在分支中）</li></ol><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><p>首先新系统下的git配置，关键点在于重新配置ssh密匙</p><p>其次是Nodes.js与npm需要最新版本（有多新装多新</p><h3 id="初始化另一台电脑的操作"><a href="#初始化另一台电脑的操作" class="headerlink" title="初始化另一台电脑的操作"></a>初始化另一台电脑的操作</h3><ol><li><p>git bash 将远程仓库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 博客所在仓库地址</span><br></pre></td></tr></table></figure></li><li><p>进入项目目录，安装依赖启动博客服务器，生成静态文件</p><p>并在本地部署，通过<a href="http://localhost:4000进行访问">http://localhost:4000进行访问</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">hexo g&amp;hexo s</span><br></pre></td></tr></table></figure></li><li><p>发布文章与之前相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo c&amp;hexo d -g</span><br></pre></td></tr></table></figure></li></ol><h3 id="另一台电脑同步"><a href="#另一台电脑同步" class="headerlink" title="另一台电脑同步"></a>另一台电脑同步</h3><p>​        在博客目录下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>​        后执行更新原始文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull </span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;描述&quot;</span></span><br><span class="line">git push origin hexo </span><br></pre></td></tr></table></figure><p>​        每次有新的操作的时候，在另一台电脑上也同时进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull hexo <span class="comment">#拉取源文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的写一个makefile</title>
      <link href="/2022/07/14/makefile/"/>
      <url>/2022/07/14/makefile/</url>
      
        <content type="html"><![CDATA[<h3 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h3><p>什么是MakeFile？很好理解，是一种规则，什么规则呢？顾名思义：生成文件的规则</p><p>这是一条基本语法(伪代码)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标:依赖</span></span><br><span class="line">依赖操作成为目标的指令</span><br></pre></td></tr></table></figure><p>三个要素：</p><ul><li>目标<ul><li>需要的结果</li></ul></li><li>依赖<ul><li>执行中需要的文件</li></ul></li><li>指令<ul><li>执行的操作代码</li></ul></li></ul><p> make指令执行的顺序模式是：自顶向下，典型的树状结构</p><p>可以理解为，执行最顶部的目标生成规则，根据当前目标所需的依赖向下查找依赖的生成规则。</p><p>最终目标生成规则一般都写在最上方，第一条</p><p>简单看一个简单的makefiiewe文件的简单编写伪代码</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>makeFile文件的简单的编写格式如下</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  target=最终文件名</span><br><span class="line">  </span><br><span class="line">  obj=子文件1 子文件2 子文件3 ....</span><br><span class="line">  </span><br><span class="line">    <span class="variable">$(target)</span>：<span class="variable">$(obj)</span></span><br><span class="line">     具体操作命令</span><br><span class="line">   子文件%：源文件%</span><br><span class="line">     具体操作命令</span><br><span class="line">     ....</span><br><span class="line">     .PHONY:clean</span><br><span class="line">     clean:</span><br><span class="line">     -rm</span><br><span class="line">rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br><span class="line"><span class="comment">#-f 强制执行</span></span><br></pre></td></tr></table></figure><h4 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h4><p>  自动变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&lt;</span>：规则中的第一个依赖(就是子文件1)</span><br><span class="line"><span class="variable">$@</span>：当前规则中的目标</span><br></pre></td></tr></table></figure><p>每次生成的会对子依赖进行检查是否有修改</p><p>函数的使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">指定目录下的所有.c文件</span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> ./%.o, ./%.c, $(<span class="built_in">wildcard</span> ./*.c)</span>)</span><br><span class="line">将的所有.o 字符 替换为.c </span><br></pre></td></tr></table></figure><p>删除之前生成的子文件，因为不是我们的最终目标，是临时的文件，需要手动删除那不如加条目标指令进行删除。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br><span class="line"><span class="comment">#-f 强制执行</span></span><br></pre></td></tr></table></figure><p>makefile加入该删除代码后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line"><span class="comment">#只执行clean</span></span><br></pre></td></tr></table></figure><p>举例验证：加入一个hello目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:</span></span><br><span class="line">echo <span class="string">&quot;hello,makefile!&quot;</span></span><br></pre></td></tr></table></figure><p>在终端执行:就会只执行hello目标的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make hello</span><br></pre></td></tr></table></figure><p>将目标声明为伪目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> .PHONY:clean</span><br><span class="line"><span class="comment">#就不回再重复比较文件，默认执行该目标操作</span></span><br></pre></td></tr></table></figure><p>而加入-rm的作用是</p><p>当出现报错无法执行是，忽略该报错执行下一条命令语句</p><p>还有更多函数和编写细节，用到了的时候再说罢。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>给我的感觉就是一个类脚本的语言，可以将不止是 C++ or JAVA 或者其他语言的项目，集成方便的进行编译的或者其他操作，挺有意思的.</p>]]></content>
      
      
      <categories>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake基础</title>
      <link href="/2022/07/12/cmake01/"/>
      <url>/2022/07/12/cmake01/</url>
      
        <content type="html"><![CDATA[<h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a><a href="">Cmake</a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux下cmake编译工具使用过程与windows的操作大同小异</p><p>单独开一篇文章对指令基础做个总结</p><span id="more"></span><h3 id="Corss-platform-development"><a href="#Corss-platform-development" class="headerlink" title="Corss-platform development"></a>Corss-platform development</h3><p>跨平台：毕竟做linux下的c++ 开发不用cmake 可不行,总不能徒手写makefile文件罢,利用cmake生成的makefile也相当块。</p><h3 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h3><p>指令格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令（参数1 参数2）</span><br></pre></td></tr></table></figure><p>不同参数需要用<strong>空格</strong>或者<strong>分号</strong>隔开</p><p>指令无关大小写，<strong>参数</strong>和<strong>变量</strong>是大小写<strong>相关</strong>的</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ul><li><p><strong>cmake_minimum_required</strong>:指定cmake版本</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cmake_minimum_required -指定cmake的最小版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>project</strong>:定义工程名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定 project(projectname [CXX][C][java])</span></span><br><span class="line"><span class="keyword">project</span>(HEllO CXX)</span><br><span class="line"><span class="comment">#指定工程名称为HELLO 支持C++ </span></span><br></pre></td></tr></table></figure></li><li><p><strong>set</strong>:显示的定义变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC sayhello.cpp hello.cpp)</span><br><span class="line"><span class="comment">#定义一个SRC变量 引用SRC 相当于引用sayhello.cpp hello.cpp</span></span><br></pre></td></tr></table></figure></li><li><p><strong>include_directories </strong>向工程添加多个特定的头文件搜索路径</p><p>假设文件夹路径是这样的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">└── myfolderinclude</span><br><span class="line">    └── othersfolderinclude</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(../myfolderinclude ./othersfolderinclude)</span><br><span class="line"><span class="comment">#类似于g++中的-I </span></span><br></pre></td></tr></table></figure></li><li><p><strong>link_directories</strong>:向工程添加多个指定的库文件搜索路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(../myfolderlib ./othersfolderlib)</span><br></pre></td></tr></table></figure></li><li><p><strong>add_library</strong>:生成库文件</p><p>比较重要的语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add-library(libname[SHARED|STATIC|MODULE][EXCLUDE_FORM_ALL]source1 source2 ..sourceN)</span></span><br><span class="line"><span class="comment">#通过变量SRC （上方代码中定义的SRC变量引用）生成动态[SHARED] 的libhellp.so文件</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="comment">#注意，变量的引用使用$&#123;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>add_compile_options</strong>：添加编译参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-Wall -std=c++ -O2)</span><br><span class="line"><span class="comment">#分别添加的是警告显示，定义语言特性，优化级数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>add_executable</strong> :生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="comment">#将main.cpp编译为 mian</span></span><br></pre></td></tr></table></figure></li><li><p><strong>target_link_libraries</strong>为target链接的动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#等价于g++ -l 编译器参数</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main hello)</span><br><span class="line"><span class="comment">#将hello动态库链接到可执行文件main </span></span><br></pre></td></tr></table></figure></li><li><p><strong>add_subdirectory</strong>向当前的工程添加存放源文件的子目录，指定中间二进制和目标二进制的存放位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="comment">#添加一个src子目录,src中需要也有一个CMakelists.txt</span></span><br></pre></td></tr></table></figure></li><li><p><strong>aux_source_directory</strong> 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="comment">#定义. （就是一个目录下所有的源文件） 为SRC变量</span></span><br><span class="line">add_exrcutable(mian <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="comment">#引用SRC 生成可执行文件</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><ul><li><p><strong>CMAKE_CXX_FLAGS</strong>：编译选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在CMAKE_CXX_FALGS编译选项后加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FALGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br><span class="line"><span class="comment">#类似CMAKE_CXX_FALGS+=-std=c++11</span></span><br></pre></td></tr></table></figure></li><li><p><strong>CMAKE_BUILDTYPE</strong>：编译类型</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"><span class="comment">#编译为Debug</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="comment">#编译为Release</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CMake编译"><a href="#CMake编译" class="headerlink" title="CMake编译"></a>CMake编译</h3><p>手动编写CMakeLists.txt</p><h4 id="两种编译规则"><a href="#两种编译规则" class="headerlink" title="两种编译规则"></a>两种编译规则</h4><ul><li><p>​    子目录无CMakeLists.txt</p></li><li><p>​    子目录包含CMakeLists.txt</p></li></ul><h4 id="两种构建方式"><a href="#两种构建方式" class="headerlink" title="两种构建方式"></a>两种构建方式</h4><ul><li><p>内部构建（不用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单纯的直接cmake 当前文件夹生成makefile</span><br><span class="line">再make 执行makefile 生成可执行文件等等，</span><br><span class="line">因为都生成在当前文件夹很乱，目录结构不清析。</span><br><span class="line">所以不用</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>外部构建（常用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在当前目录下新建一个build </span></span><br><span class="line"><span class="built_in">mkdir</span> build </span><br><span class="line"><span class="comment">#跳转</span></span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line"><span class="comment">#执行cmake,执行上层主目录下的CMakelists.txt</span></span><br><span class="line">cmake .. </span><br><span class="line"><span class="comment">#生成makefile和其他文件</span></span><br><span class="line">make </span><br><span class="line"><span class="comment">#执行</span></span><br><span class="line"><span class="comment">#所有的编译输出文件都存在了build目录中</span></span><br><span class="line"><span class="comment">#互不干扰结构明了</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CMake在vs-code下的甜点"><a href="#CMake在vs-code下的甜点" class="headerlink" title="CMake在vs.code下的甜点"></a>CMake在vs.code下的甜点</h3><p>​        当我们需要在vs.code调试CMake代码生成的可执行文件的时候，可以设置launch.json和一个task.json的调试脚本<del>个人觉得，只是锦上添花的操作，除了tasks.josn,我们可以写bat，或者shell都可以而且代码更少</del>，达到可以直接运行调试的效果，不需要在修改源代码后，再手动输入cmake与make 重新编译，实现自动化操作</p><p>​        首先我们选择运行与调试默认生成的launch.json，给出一个文件目录的示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles/....</span><br><span class="line">│   ├── cmake_install.cmake</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── main<span class="comment">#这个是生成的可执行文件</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── gun.h</span><br><span class="line">│   └── soilder.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    ├── gun.cpp</span><br><span class="line">    └── soilder.cpp</span><br></pre></td></tr></table></figure><p>根据文件目录我们将默认生成的launch.json进行改动</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/main&quot;</span><span class="punctuation">,</span><span class="comment">//这里需要更改为你的可执行文件</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            </span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Build&quot;</span><span class="punctuation">,</span> <span class="comment">//这是里我们需要修改的地方</span></span><br><span class="line">            <span class="comment">//上方代码的意思是，执行调试前的前置任务，所以我们需要再生成一个tasks.json文件</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span><span class="comment">//默认添加</span></span><br><span class="line">            </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再编写一个简单的tasks.json，可以直接在vs.code终端菜单下直接生成一个简单的任务范例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><span class="comment">//指定工作区下的目录</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;step1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmake&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;..&quot;</span>  <span class="comment">//参数</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;step2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                </span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dependsOrder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sequence&quot;</span><span class="punctuation">,</span><span class="comment">//依赖顺序设置为顺序执行</span></span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span>   <span class="comment">//顺序</span></span><br><span class="line">                <span class="string">&quot;step1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;step2&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用VScode与CMake做C++开发环境</title>
      <link href="/2022/07/11/zatan01/"/>
      <url>/2022/07/11/zatan01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//v2-49a45b8c622434dbf79463ccab9fa627_720w.png" alt=""></p><h3 id="啥事cmake"><a href="#啥事cmake" class="headerlink" title="啥事cmake?"></a>啥事cmake?</h3><p>​        CMake 是一个开源、跨平台的工具，旨在构建、测试和打包您的程序。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。这套 CMake 工具由 Kitware 创建，以满足 ITK 和 VTK 等开源项目对强大的跨平台构建环境的需求。</p><p>​        说白了，这玩意只是个配置器，配置你的编译器该如何进行编译</p><span id="more"></span><h3 id="cmake的好处："><a href="#cmake的好处：" class="headerlink" title="cmake的好处："></a>cmake的好处：</h3><pre><code>&lt;center&gt;“Write once, run everywhere”&lt;/center&gt;</code></pre><p>​        非常好理解，就是只写一次，到处运行</p><p>​        对我来说就三个字：跨平台。</p><h3 id="cmake的缺点："><a href="#cmake的缺点：" class="headerlink" title="cmake的缺点："></a>cmake的缺点：</h3><p>​        缺点：麻烦，步骤繁多        </p><p>​        断点调试挺麻烦的，VScode里的插件可以，但是需要对luanch.json和tasks.json进行修改，尤其是出现多个目录多个源文件等大项目的编译，修改虽然不复杂，但是麻烦。想要调试添加额外配置参数来打印所执行的所有代码及行号，插入log等方式检查问题。</p><p>​        有这弱语言的共通问题，就是容易出问题。</p><p>总而言之，挺麻烦的</p><p><del>要不是最近需要将Qmake项目迁移到cmake，还真不想用这玩意</del></p><h3 id="利用CMake编译一个简单的C-程序"><a href="#利用CMake编译一个简单的C-程序" class="headerlink" title="利用CMake编译一个简单的C++程序"></a>利用CMake编译一个简单的C++程序</h3><p>首先vscode需要下载两个插件，CMAKE与C/C++,这些我默认就有，因为在下载之前就一直用着VS2022，模块化无脑安装。</p><p>然后配置CMake和MINGW环境变量，这些我默认也有，安装Qt自带，直接指向Qt/tools里的对应路径即可。</p><p>前提条件准备得那是相当充足。</p><p>直接就随便顺手写一个冒泡排序的小例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建这样一个目录结构</span><br><span class="line">└── src</span><br><span class="line">    └── sort.cpp</span><br><span class="line">└── include</span><br><span class="line">    └── sort.h</span><br><span class="line">└── main.cpp    </span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    Sort sort;</span><br><span class="line">    <span class="built_in">sort</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.<span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>-i<span class="number">-1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span>(x[j]&lt;x[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp=x[j];</span><br><span class="line">                    x[j]=x[j+<span class="number">1</span>];</span><br><span class="line">                    x[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sort.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&quot;sort.h&quot;</span><br><span class="line">void Sort::test()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;test\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，前提源文件准备工作结束</p><p>开始编写CMakelists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这种写法非常简单，无脑摁写，但是不够直观</span></span><br><span class="line"><span class="keyword">project</span>(Sorttest) <span class="comment">#项目名称</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src SRC_SUB) <span class="comment">#项目根目录下的所有子项目</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_CUR)  <span class="comment">#同理</span></span><br><span class="line"><span class="keyword">add_executable</span>(sort <span class="variable">$&#123;SRC_SUB&#125;</span> <span class="variable">$&#123;SRC_CUR&#125;</span>) <span class="comment">#同理</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>) <span class="comment">#头文件包含目录</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>) <span class="comment">#最低版本需求</span></span><br><span class="line"><span class="keyword">project</span>(Sorttest) <span class="comment">#项目名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#头文键包含</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main</span><br><span class="line">               <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/main.cpp <span class="comment">#这个路径看这个main.cpp位于哪里了              </span></span><br><span class="line">               <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/sort.cpp)</span><br></pre></td></tr></table></figure><p>后者相对前者直观一些，效果都是一样的</p><p>在CMakelist.txt视窗中按下快捷键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift+ctrl+p</span><br></pre></td></tr></table></figure><p>唤起</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711223231514.png" alt="image-20220711223231514"></p><p>选择CMake配置，一切自动化帮你构建build文件夹目录</p><p>再新终端下方 cd跳转到build目录中</p><p>输入以下指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>运行如下工具 (这个是根据build的中的Makefile中的规则经行对源文件进行编译)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make.exe </span><br></pre></td></tr></table></figure><p>可以看到运行后在Bulid目录下多出一个sort.exe</p><p>在终端中输入运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\sort.exe</span><br></pre></td></tr></table></figure><p>既可以看到程序的输出结果：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711224250666.png" alt="image-20220711224250666"></p><p>至此编译到此结束</p>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
            <tag> VScode </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础00| 简单常用的几个基础指令</title>
      <link href="/2022/07/11/linux00/"/>
      <url>/2022/07/11/linux00/</url>
      
        <content type="html"><![CDATA[<h2 id="linux基础中的基础"><a href="#linux基础中的基础" class="headerlink" title="linux基础中的基础"></a>linux基础中的基础</h2><h3 id="linux-的基础命令"><a href="#linux-的基础命令" class="headerlink" title="linux  的基础命令"></a>linux  的基础命令</h3><h4 id="指令默认格式"><a href="#指令默认格式" class="headerlink" title="指令默认格式"></a>指令默认格式</h4><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令 [选项] [操作对象]</span><br></pre></td></tr></table></figure><p>注意：中括号代表的意思是可以省略内容不输入，一样可以运行该指令</p><p>默认打开终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Alt+T</span><br></pre></td></tr></table></figure><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>打印当前所在的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>打印当前目录下的文件与文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>ls的用法扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [文件路径]</span><br><span class="line"><span class="comment">#文件路径：</span></span><br><span class="line"><span class="comment">#相对路径or绝对路径</span></span><br></pre></td></tr></table></figure><p>打开文件目录下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 选项 [文件路径]</span><br><span class="line"><span class="comment">#选项：指定方式显示</span></span><br></pre></td></tr></table></figure><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a <span class="comment">#表示显示所有的(all)文件与文件夹，包括隐藏</span></span><br><span class="line">-l <span class="comment">#表示详细列表的方式展示(list)</span></span><br><span class="line">-h <span class="comment">#以可读性较高的形式显示</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="cd-chanage-directory"><a href="#cd-chanage-directory" class="headerlink" title="cd(chanage directory)"></a>cd(chanage directory)</h4></li></ul><p>：跳转目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  </span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#作用都是直接回到家目录</span></span><br></pre></td></tr></table></figure><p>与ls类似的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [文件路径]</span><br><span class="line"><span class="comment">#文件路径：</span></span><br><span class="line"><span class="comment">#相对路径or绝对路径</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a>mkdir(make directories)</h4></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> myfolder </span><br><span class="line"><span class="comment">#在当前的目录下创建一个mydir文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> myfolder1 myfolder2</span><br><span class="line"><span class="comment">#在当前目录下创建两个文件夹，分别是 myfolder1，myfolder2</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/a/b/c</span><br><span class="line"><span class="comment">#-p 选项是必须的</span></span><br><span class="line"><span class="comment">#当前家目录下(~)创建多层不存在的目录</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="touch-change-file-timestamps"><a href="#touch-change-file-timestamps" class="headerlink" title="touch-change file timestamps"></a>touch-change file timestamps</h4></li></ul><p>作用：创建文件（虽然本意不是这个）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span>  test.txt</span><br><span class="line"><span class="comment">#在当前目录下生成一个 test.txt文件</span></span><br><span class="line"><span class="built_in">touch</span> ../test1  <span class="comment">#（相对路径)</span></span><br><span class="line"><span class="comment">#在当前目录的上级目录下生成一个 test1文件</span></span><br><span class="line"><span class="built_in">touch</span> ~/test2  <span class="comment">#(绝对路径)</span></span><br><span class="line"><span class="comment">#在~（家)目录下生成一个 test2文件</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm (remove )"></a>rm (remove )</h4></li></ul><p>删除指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> [选项] [路径]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.txt</span><br><span class="line"><span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">rm</span> ../test1</span><br><span class="line"><span class="comment">#删除上级目录的文件</span></span><br><span class="line"><span class="built_in">rm</span> ~/test2</span><br><span class="line"><span class="comment">#在~（家)目录下删除test2文件</span></span><br></pre></td></tr></table></figure><p>删除文件夹和文件夹下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf [文件夹路径]</span><br><span class="line"><span class="comment">#删除文件夹</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a>cp(copy)</h4></li></ul><p>作用：复制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [复制的文件路径] [副本的文件路径]</span><br><span class="line"><span class="built_in">cp</span> ../test ./test.txt</span><br><span class="line"><span class="comment">#上级的目录下的test文件复制到当前目录下 并且换了个名字（加了个.txt后缀名）</span></span><br></pre></td></tr></table></figure><p>复制文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r [文件夹路径] [副本文件夹的路径]</span><br><span class="line"><span class="comment">#-r是递归的意思</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="mv-move"><a href="#mv-move" class="headerlink" title="mv (move)"></a>mv (move)</h4></li></ul><p>作用：移动文件位置，或者重命名文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> <span class="built_in">test</span> test.txt</span><br><span class="line"><span class="comment">#重新命名test文件为 test.txt(在当前目录下)</span></span><br><span class="line"><span class="comment">#等效 mv test ./test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> <span class="built_in">test</span> ../test.txt </span><br><span class="line"><span class="comment">#重新命名并且移动到了上级目录中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="men-menu"><a href="#men-menu" class="headerlink" title="men (menu)"></a>men (menu)</h4><p>说明书目录:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#参看命令ls的手册</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在man中无cd的手册</span></span><br><span class="line"><span class="comment">#我们在cd help中可以看到</span></span><br><span class="line"></span><br><span class="line">man man </span><br><span class="line"><span class="comment">#参看man的命令手册</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line"><span class="comment">#立即重启</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>关机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h [时间]</span><br><span class="line"></span><br><span class="line">shutdown -h now </span><br><span class="line"><span class="comment">#立即关机</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="文件的编辑"><a href="#文件的编辑" class="headerlink" title="文件的编辑"></a>文件的编辑</h3><ul><li><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>一句话：<strong>编辑器之神</strong></p><p>安装：(Ubuntu LTS 22.04)</p><p><del>想用的时候居然没有安装</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#建议安装：</span></span><br><span class="line"> ctags vim-doc vim-scripts</span><br><span class="line"><span class="comment">#顺带一并安装#都是vim的插件</span></span><br><span class="line">sudo apt-get install ctags</span><br><span class="line">sudo apt-get install vim-doc</span><br><span class="line">sudo apt-get install vim-scripts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/2018101511335895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9jeTY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="助记图"></p></li></ul><p>  这里不继续详细的说明，将会新开一篇文章来记录VIM 的使用</p><p>  简单的使用：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim [file]</span><br><span class="line">#直接打开文本</span><br></pre></td></tr></table></figure><p>  终端直接变成了文本编辑器</p><p>  键盘摁下 i 键</p><p>  可以可以看见左下角状态变更为 插入 （insert）</p><p>  此时即可以输入文本进行编辑了</p><p>  保存需摁下</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift </span><br></pre></td></tr></table></figure><p>  输入： </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:w #保存文本</span><br><span class="line">:q #退出vim编辑器</span><br></pre></td></tr></table></figure><ul><li><h4 id="geidt"><a href="#geidt" class="headerlink" title="geidt"></a>geidt</h4><p>纯文本的编辑器，ubuntu 都是自带的,默认的编辑器</p></li></ul><p>  简单的使用：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim [file]</span><br><span class="line"><span class="comment">#直接打开文本编辑框，</span></span><br></pre></td></tr></table></figure><p>  与vim不同点在于 弹出的geidt的编辑界面，对新手挺友好的</p><p>  直接按照Windows下的记事本使用即可</p><ul><li><h4 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h4><p>与Vim类似，但是比vim简单而且小巧</p><p>简单的使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano [file]</span><br><span class="line"><span class="comment">#终端变成nano界面</span></span><br></pre></td></tr></table></figure><p>指令都在下方直观的显示出来</p><p>修饰键是Ctrl ，使用起来非常简单</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习第一节|Qt基础</title>
      <link href="/2022/06/26/QTstudy/"/>
      <url>/2022/06/26/QTstudy/</url>
      
        <content type="html"><![CDATA[<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628200812272.png" alt=""></p><p>基于C++的跨平台的图形引擎</p><p>发行于1991年 <del>就记了个大概，不知道的咱可以百度不是</del></p><span id="more"></span><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.跨平台</p><p>2.接口简单</p><p>3.一定程度简化了内存回收</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.WPS</p><p>2.linux-KDE</p><p>3.vlc多媒体播放</p><h2 id="创建第一个Qt"><a href="#创建第一个Qt" class="headerlink" title="创建第一个Qt"></a>创建第一个Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111650699.png" alt=""></p><p>系统环境：windows11<br>软件环境：Qt6.2.3(MSVC 2019 64bit)</p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>一开始可以直接打开官方的Qt Creator，暂且不需要使用MSVS上进行调试开发，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-&gt; new project</span><br></pre></td></tr></table></figure><h4 id="选择模板（tempates"><a href="#选择模板（tempates" class="headerlink" title="选择模板（tempates)"></a>选择模板（tempates)</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110514448.png" alt=""></p><p>默认<strong>Qt widget application</strong>（最基本的，也是最常用的窗口应用）</p><p>新建文件名和选择路径需要注意：（名字 路径，都不要有中文）</p><h4 id="选择构建系统（build-system）"><a href="#选择构建系统（build-system）" class="headerlink" title="选择构建系统（build system）"></a>选择构建系统（build system）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110646484.png" alt=""></p><p>因为做的是第一个程序，要快速上手选择qmake（Qt自带，不过个人建议cmake）。</p><h4 id="细节（details）"><a href="#细节（details）" class="headerlink" title="细节（details）"></a>细节（details）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111032398.png" alt=""></p><p>名字都可以默认，也可以更改随喜好，注意事项（中文不行，空格禁止）</p><p><strong>重点在于Base class（基类）</strong></p><p>窗口类型介绍：QMainWindow、QWidget、QDialog三个类都可以用来创建窗口，可以直接使用，也可以继承后使用。</p><p>　　QMainWindow窗口包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式，也可以说是GUI程序的主窗口。</p><p>　　QDialog是对话框窗口的基类。对话框主要用来执行短期任务，或者与用户进行互动，它可以是模态的，也可以是非模态的。他没有菜单栏、工具栏、状态栏等。</p><p>　　如果是主窗口，就使用QMainWindow类；</p><p>　　如果是对话框，就使用QDialog类；</p><p>　　如果不确定，有可能作为顶层窗口，也有可能嵌入到其他窗口，就使用QWidget类。</p><p>​        第一个程序我们可以默认直接选QWidget类</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202512898.png" alt=""></p><p>这个是生成一个UI界面，一开始做第一个程序可以不选，因为需要学习一下UI底层的实现代码。</p><h4 id="Kits-选择"><a href="#Kits-选择" class="headerlink" title="Kits 选择"></a>Kits 选择</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202115437.png" alt=""></p><p>这里我因为安装时选择需要MSVC调试开发，所以会出现MSVC，默认有MInGW,一般可全选，创建第一个项目的时候不容易出错</p><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202912401.png" alt="">选择版本控制系统，一开始第一个程序用不上，实际是做大项目开发用的源代码管理工具选择，比如说我们常见的git ，svn等。具体可看这篇CSDN博文：<a href="https://blog.csdn.net/weixin_45627194/article/details/110050361">源代码管理工具 </a></p><p>点击完成至此，创建一个Qt项目完成</p><h4 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ctrl / 注释</span><br><span class="line">//ctrl r 运行</span><br><span class="line">//ctrl b 编译</span><br><span class="line">//ctrl i 自动对齐</span><br><span class="line">//F4 快捷切换同名文件</span><br></pre></td></tr></table></figure><h3 id="生成的代码文件"><a href="#生成的代码文件" class="headerlink" title="生成的代码文件"></a>生成的代码文件</h3><h3 id="需要掌握的："><a href="#需要掌握的：" class="headerlink" title="需要掌握的："></a>需要掌握的：</h3><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">//argc为命令行变量的数量</span></span><br><span class="line"><span class="comment">//*argv变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;<span class="comment">//a即为应用程序对象，有且仅有一个</span></span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="comment">//窗口对象 （子类widger ：public QWidget）</span></span><br><span class="line">    <span class="comment">//默认不显示；</span></span><br><span class="line">    <span class="comment">//需要以下函数调用，调用的是顶层窗口函数</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">     <span class="comment">//让应用程序对象进入消息循环机制</span></span><br><span class="line">    <span class="comment">//类似while（true）</span></span><br><span class="line">    <span class="comment">//触发条件退出循环结束程序</span></span><br><span class="line">    <span class="comment">//堵塞你的代码运行</span></span><br><span class="line">    <span class="comment">//与system(&quot;pause&quot;)作用类似</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//之后的代码依旧会顺序执行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>widget.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include&lt;QDebug&gt;</span><br><span class="line">#include&lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent): QWidget(parent)//这不就是初始化列表么</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个按钮</span><br><span class="line">    QPushButton *btn = new QPushButton;</span><br><span class="line">    //btn-&gt;show();//单独弹出一个顶层的窗口来弹出窗口控件</span><br><span class="line">    //所以我们需要将Btn对象依赖在Widget窗口中</span><br><span class="line">    btn-&gt;setParent(this);</span><br><span class="line">    //函数名直译，设置父母。</span><br><span class="line"></span><br><span class="line">    //给按钮显示值</span><br><span class="line">    btn-&gt;setText(&quot;第一个按钮&quot;);</span><br><span class="line"></span><br><span class="line">//    创建第二个按钮</span><br><span class="line">    QPushButton *btn2=new QPushButton(&quot;第二个按钮&quot;,this);//有参构造</span><br><span class="line">    //但是有问题，只会按照空间的大小创建窗口</span><br><span class="line">    //我们可以自己设定默认窗口大小</span><br><span class="line">    //可修改</span><br><span class="line">    resize(600,400);</span><br><span class="line">   //我想要窗口固定大小，就需要</span><br><span class="line">    setFixedSize(600,400);</span><br><span class="line">    //同理，按钮需要定义大小也可以</span><br><span class="line">    btn-&gt;resize(50,20);</span><br><span class="line"></span><br><span class="line">    //但是运行还是只有一个按钮没因为默认位置将第一个按钮覆盖显示了，我们需要移动他</span><br><span class="line">    btn2-&gt;move (100,100);</span><br><span class="line">    //这样我们就可以看到两个按钮了，这个时候我也可以更改应用标题</span><br><span class="line">    setWindowTitle(&quot;第一个Qt&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //问题：</span><br><span class="line">    //我们的按钮都是开辟于堆区，不用去考虑释放内存的问题吗</span><br><span class="line">    //引入对象树的概念</span><br><span class="line">    //setparent(this)</span><br><span class="line">    //关键函数：</span><br><span class="line">//将这个类与类下的对象放入对象树中</span><br><span class="line">//析构的时候   --接以下注释--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug(&quot;父类的析构&quot;);</span><br><span class="line">    </span><br><span class="line">    //先执行自行添加的代码，然后</span><br><span class="line">    //底层在释放这个类之前判断是否有子类，如果有就找到子类析构，再执行自添加的代码，再判断，</span><br><span class="line">    //直到找不到子类，确认是最后一个子类后释放这个子类下的对象</span><br><span class="line">    //所以就会出现，先输出父类析构代码再输出子类的析构代码的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h4><p>Qt的学习重点，Qt的引以为豪的部分。</p><p>怎了么理解信号与槽？</p><p>我们现看个例子：</p><p>我打开一盏灯，灯亮了</p><p>信号的发送者，发送具体信号，信号的接收者，槽函数：信号的处理</p><p>connect （信号的发送者，发送具体信号；信号的接收者，信号的处理）</p><p>信号槽的优点，松散耦合：可以理解为信号发送与接收者没啥关联，通过connect的链接两端耦合在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接函数</span></span><br><span class="line"><span class="built_in">connect</span>(mybtn  ,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::close);</span><br><span class="line"><span class="comment">//参数1：信号发送者，参数2：信号这里填入地址；</span></span><br><span class="line"><span class="comment">//参数3：信号接收者，参数3；同样是地址槽（槽函数，执行行为）</span></span><br></pre></td></tr></table></figure><p>QT库中有现成的信号与槽函数，当然我们也可以自己写一个，具体实现：</p><p>更多内容在下一篇文章再说，<del>还没写呢。先玩游戏去辣</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628211036994.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Qt学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt6.2.3，C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章的技巧</title>
      <link href="/2022/06/25/hello-world/"/>
      <url>/2022/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        第一次利用Typora编写Md文件并且发布博客，有很多操作还是非常生疏，在这里记录个Md文件的文章编辑的常用代码。以供我啥时候突然给整忘了回来看看😁</p><p>​                                    <span id="more"></span></p><p>`                      </p><h3 id="文章阅读截止"><a href="#文章阅读截止" class="headerlink" title="文章阅读截止"></a>文章阅读截止</h3><p>​        将过长的文章截取，只显示代码上方的文章内容，避免文章过长的显示在博客主页（这个可以说是非常常用）</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h3 id="文章的新建命令"><a href="#文章的新建命令" class="headerlink" title="文章的新建命令"></a>文章的新建命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>​        在github bash 中使用 该指令可以新建一个页面：</p><p>​        使用实例如下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post 标题</span><br></pre></td></tr></table></figure><p>​        可以在hexo根文件的中的_post的文件夹中发现新建了一个标题.md    ，头部信息如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: //时间</span><br><span class="line">tags: //标签</span><br><span class="line">categories:  //分类</span><br></pre></td></tr></table></figure><h3 id="草稿的新建命令"><a href="#草稿的新建命令" class="headerlink" title="草稿的新建命令"></a>草稿的新建命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft title</span><br></pre></td></tr></table></figure><p>​        在github bash 中使用 该指令可以新建一个草稿：</p><p>​        使用实例如下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft 标题</span><br></pre></td></tr></table></figure><p>​        可以在hexo根文件的中的_drafts的文件夹中发现新建了一个标题.md    头部的信息如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: //时间</span><br><span class="line">tags: //标签</span><br><span class="line">categories:  //分类</span><br></pre></td></tr></table></figure><p>​        草稿不会显示在博客中，想要看到博客草稿需要在github bash 中使用如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -draft</span><br></pre></td></tr></table></figure><p>​        该指令的作用除了在本地运行博客部署以外，可以在博客中访问草稿.</p><h3 id="front-Matter"><a href="#front-Matter" class="headerlink" title="front  Matter"></a>front  Matter</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//20200916181236318.png" alt=""></p><p>​    每个创建的MD文件都在头端插入了名为front  Matter预定义读取参数,就是上文所说的头部信息。<br>​    可以看见这张图是有水印的，我们可以利用MD的文件中的画图代码画出相同的信息：</p><center>|    参数    |       描述       |       默认值       || :--------: | :--------------: | :----------------: ||   layout   |       布局       |         无         ||   title    |       标题       |         无         ||    date    |    建立的日期    |    文件建立日期    ||   update   |    更新的日期    | 每次文件更新的日期 ||  comments  | 该文章的评论功能 |  默认每个文章开启  ||    tags    |       标签       |         无         || categories |       分类       |         无         |</center>]]></content>
      
      
      <categories>
          
          <category> 博客技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的内存管理</title>
      <link href="/2022/05/01/memory/"/>
      <url>/2022/05/01/memory/</url>
      
        <content type="html"><![CDATA[<h1 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h1><p><code>心中自存丘壑，高楼起自平地</code></p><p>标准库，真是个好东西，使用者可以更少甚至不用考虑内存的分配。</p><p>内存的管理，我们常用到的工具比较常见的是</p><p>new/delete malloc/free  而标准库， 也提供了allocators 函数，然而在不同的编译器上，使用的借口和内存的分配操作实际上是有些许不同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#indef __GNUC__ </span></span><br><span class="line"><span class="type">void</span>* p1 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().allocate)(<span class="number">7</span>);</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span> ((<span class="type">int</span>*)p1,<span class="number">7</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/03/24/design/"/>
      <url>/2022/03/24/design/</url>
      
        <content type="html"><![CDATA[<p>设计模式第一讲</p><p>李建忠老师的课程</p><p>什么是是设计模式</p><p>提高在OOP时的代码复用性，直白的说就是</p><p><del>高效率且高质量的偷懒</del></p><p>深入理解面向对象，封装继承多态.</p><p>首先就是为了将变化赶到在一定区域</p><p>遇到一个比较复杂的要求时</p><p>我们通常有两种的应对方法</p><ol><li>分解</li><li>抽象</li></ol><p>这两种方法常常能满足要求</p><p>然而在程序设计之后常常会出现很多变化</p><p>客户要求的变化</p><p>市场平台的变化</p><p>…</p><p>如果使用分解的方式就需要在源代码中进行增量修改</p><p>每有一个轻微的变化就需要对源代码进行修改</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
