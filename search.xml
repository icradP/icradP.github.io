<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux基础07 | 同步与锁</title>
      <link href="/2022/08/23/linux07/"/>
      <url>/2022/08/23/linux07/</url>
      
        <content type="html"><![CDATA[<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>啥事同步，同时起步，协调一致的，然而不同的对象，又有不同的同步概念</p><p>设备同步，两个设备之间的一个共同时间的参考，数据库同步等等</p><p>在linxu中我们需要了解线程同步</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步即协同一致，按照预订的先后次序运行</p><p>一个线程调用一个函数时，为了保证其他线程调用时的数据一致性，不能调用其他函数</p><p>这个时候我们就需要给这个调用的数据，上一个锁，对共享的区域做一个保护</p><p>所以在linux中当多个流程操作一个共享资源时都需要加锁</p><h2 id="常用锁和常用原语"><a href="#常用锁和常用原语" class="headerlink" title="常用锁和常用原语"></a>常用锁和常用原语</h2><h3 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h3><h4 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h4><p>初始化一个互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><p>注意这个关键词restrict，指名只能使用该指针，不能通过其他指针操作内存指向</p><ul><li>pthread_mutex_t *restrict mutex 可以单纯理解为锁 ，锁上是为0,解锁为1</li><li>mutex,const pthread_mutexattr_t *restrict attr  锁的属性</li></ul><p>默认初始值为1</p><p>当不需要使用特殊配置时，可以直接使用宏变量赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITALIZER</span><br></pre></td></tr></table></figure><p>来代替该函数</p><h4 id="pthread-mutex-destory"><a href="#pthread-mutex-destory" class="headerlink" title="pthread_mutex_destory"></a>pthread_mutex_destory</h4><p>删除一个互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>一般在结束时，不再使用该锁时，进行调用删除</p><h4 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h4><p>顾名思义，上锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>可以简单理解为对锁进行减1操作</p><h4 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h4><p>顾名思义，释放锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>可以简单理解为对锁进行++操作</p><p>配合lock使用，</p><p>在不同的线程中需要访问同一个共享内存，都需要执行上锁和解锁的操作</p><p>使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">printHello</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world!\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//当调用成功mutex值为1</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, printHello, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error : %s&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD!\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);<span class="comment">//检查点在sleep具体是哪一个是随机的</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：锁的粒度应该是越小越好，访问共享操作后立即解锁</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是一种现象，而不是一种新的锁机制。</p><p>产生的原因</p><ul><li><p>没有解锁（unlock，对同一个共享内存加锁（会出现lock两次的情况</p><ul><li>可以理解为，一个唯一会开锁的小偷把自己锁在了保险库，其他同伙想进去，等待笨比解锁，而笨比被自己锁在里头了，自己又忘记了解锁密码。偷钱活动就此失败。想要打开保险库，必须触发保险库中的机关，这个机关会把保险库的小偷给杀死。</li></ul></li><li><p>两个锁造成的死锁</p><ul><li><p>有两个共享数据，线程一需要同时拿到两把锁才能访问两个共享数据，<br>假设</p><p>线程2只拿到锁1,当锁2拿到后才能释放锁1</p><p>线程1只拿到锁2,当锁1拿到后才能释放锁2</p><p>流沙河，你下来，你上来，你过来我就下去，你下来我就上去。</p></li></ul></li></ul><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); </span><br><span class="line">        b += <span class="number">100</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i m thread, a = %d , b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定一个死锁现象</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">        b += <span class="number">100</span>;  </span><br><span class="line">        pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i m main, a = %d , b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125; </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h4><ul><li>第一种死锁<ul><li>可以直接避免，只要你写的细心一点</li></ul></li><li>第二种<ul><li>调用trylock，线程一方拿不到锁时，主动释放锁</li></ul></li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>写独占，读共享。写锁的优先级更高</strong></p><p>对一个共享数据进行操作的锁，常用在读次数大于写的情况。</p><p>当线程1读操作时，其他线程也可以对其进行读操作，这是共享模式锁</p><p>当线程执行写操作上了写操作时，其他线程都无法对其进行任何操作，这是独占模式锁</p><h4 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h4><p>初始化读写锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h4><p>删除锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h4><p>设定一个读锁</p><h4 id="pthread-rwlock-wdlock"><a href="#pthread-rwlock-wdlock" class="headerlink" title="pthread_rwlock_wdlock"></a>pthread_rwlock_wdlock</h4><p>设定一个写锁</p><h4 id="pthread-rwlock-trywrlock"><a href="#pthread-rwlock-trywrlock" class="headerlink" title="pthread_rwlock_trywrlock"></a>pthread_rwlock_trywrlock</h4><p>尝试写锁，非阻塞的写法</p><h4 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a>pthread_rwlock_unlock</h4><p>解锁</p><p>其实读写锁的核心就14个字：</p><p>读时占用，写时共享，写锁优先级高</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> olda;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   olda = a;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;====write :%d olda = %d, a = %d \n&quot;</span>, i, olda, ++a);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read :%d a = %d\n&quot;</span>, i, a);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./name rtnums wtnums\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count_r = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> count_w = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tidr[count_r];</span><br><span class="line">    <span class="type">pthread_t</span> tidw[count_w];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count_w; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tidw[i], <span class="literal">NULL</span>, th_write, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_r; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tidr[i], <span class="literal">NULL</span>, th_read, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tidr[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_w; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tidw[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量本身不是锁,但是一样造成线程阻塞，说白了就是在互斥锁中进行条件判断，给多线程提供一个会合的场所</p><h4 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h4><p>阻塞等待一个条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个，老套路，一个结构体</li><li>第二个就有意思了，是一个互斥锁结构体。</li></ul><p>一个看就知道这个函数不是等闲之辈</p><p>重点就是这个函数，有三个作用</p><ul><li>阻塞等待条件变量cond满足</li><li>释放已掌握的互斥锁，实际上就是unlock(&amp;mutex);<ul><li>需要注意的是上方两个作用实际上只是一个原子操作。</li></ul></li><li>当被唤醒，pthread_cond_wait 函数返回时，解除阻塞并重新组阻塞并重新申请获取互斥锁相当于 lokc(&amp;mutex);</li></ul><p>注意这个唤醒，</p><p>有两种唤醒方式</p><ul><li>pthread_cond_signal<ul><li>唤醒一个</li></ul></li><li>pthread_cond_broadcast(广播)</li></ul><h4 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h4><p>唤醒满足条件变量的上的至少一个阻塞的线程</p><h4 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a>pthread_cond_broadcast</h4><p>唤醒所有的满足的条件变量阻塞的线程</p><h4 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="pthread_cond_timedwait"></a>pthread_cond_timedwait</h4><p>设定一个默认时间自动唤醒的wait</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>相较于一般的wait，多了一个结构体参数</p><p>const struct timespec abstime</p><ul><li>绝对时间的意思</li><li>绝对时间实际上也是相对的，从1970年1月1号0000开始计时</li><li>time_t tv_sec 秒</li><li>long tv_nsec 纳秒</li></ul><p>想要定时5秒钟实际上需要使用操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> cur =time(<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">struct</span> timespec t;</span><br><span class="line">t.tv_sec = cur + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模型实现"><a href="#生产者消费者模型实现" class="headerlink" title="生产者消费者模型实现"></a>生产者消费者模型实现</h3><p>一个典型的线程同步的模型</p><p>生产者，产品，消费者</p><p>生产者进程负责生产产品</p><p>消费者进程负责消费产品</p><p>一个简单的实现代码</p><p>这里是定义了一个简单的链表节点，一个生产者每次生产一个，一个消费者也每次消费一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)<span class="comment">//这里用while是精髓</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume ----%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        mp-&gt;num = rand() %<span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Produce ----%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> sid, cid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_create(&amp;sid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(sid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h4><p>相较于mutex，能减少不必要的竞争，如果没有释放，多个进程之间还会互相竞争</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>进化版的互斥锁，虽然也是线程库函数里的东西，但是，是<strong>可以用在进程间的锁</strong></p><p>初始化的值是N值<em>（与互斥锁默认值为1不同，N值是自己可以指定任意数值(必须是正整数)，可以理解为锁的钥匙，资源量，<em>*可以同时使用这把锁的进程数</em></em>。</p><p>出现的考量，是为了多个进程or线程需要共同访问一个的共享资源的同时，保证线程或者进程的并发性。</p><h4 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_t sem</li><li>pshared 是否在进程共享</li><li>unsigned int value 设定的值</li></ul><h4 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy"></a>sem_destroy</h4><p>对应的删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait"></a>sem_wait</h4><p>加锁函数，等同于lock,一样可以理解为—操作，当值为0时，进行阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait"></a>sem_trywait</h4><p>尝试加锁，同理trylock,非阻塞式加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h4><p>解锁，等同于unlock，一样可以理解为++操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-timedwait"><a href="#sem-timedwait" class="headerlink" title="sem_timedwait"></a>sem_timedwait</h4><p>定时加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>同样是绝对时间</p><p>直接看代码示例吧</p><p>比如说实现一个线程每隔五秒打印“hello world”，用户与输入立马打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> lock;</span><br><span class="line"><span class="type">char</span> str[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">printHello</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> ;</span></span><br><span class="line">        t.tv_sec = cur + <span class="number">5</span>;</span><br><span class="line">        sem_timedwait(&amp;lock, &amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hellp world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">scanInput</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;    </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strlen</span>(str) == <span class="number">0</span>)&#123;</span><br><span class="line">           fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;lock);</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    sem_init(&amp;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, printHello, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, scanInput, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="还是典型的消费者生产者模型"><a href="#还是典型的消费者生产者模型" class="headerlink" title="还是典型的消费者生产者模型"></a>还是典型的消费者生产者模型</h3><p>上方实现的模型的一对一的进化版</p><p>一个生产者，多个产品，一个消费者，不过此时消费者在某种意义上来说也是一种生产者的角色，生产一个空，此时公共区产品使用queue（队列）表示</p><p>一个生产者，多个产品，二个消费者，生产速率和消费速率是随机的，代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CNUM 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];</span><br><span class="line"><span class="type">sem_t</span> blank_number, product_number;</span><br><span class="line"><span class="type">sem_t</span> consumer_number;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(&amp;blank_number);</span><br><span class="line">        <span class="built_in">queue</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Produce----%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number);</span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;<span class="comment">//循环赋值</span></span><br><span class="line">        sleep(rand() % <span class="number">1</span>);<span class="comment">//模拟生产产品时间，随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(&amp;product_number);</span><br><span class="line">        sem_wait(&amp;consumer_number);</span><br><span class="line">         <span class="keyword">while</span> (<span class="built_in">queue</span>[i] == <span class="number">0</span>)&#123;</span><br><span class="line">             i = (i+<span class="number">1</span>) % NUM;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer NO.%d----%d\n&quot;</span>, j, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;</span><br><span class="line">        sem_post(&amp;consumer_number);</span><br><span class="line">        sem_post(&amp;blank_number);</span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;<span class="comment">//循环遍历</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//随机数，模拟消费者对产品的消化时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> cid[CNUM], pid;</span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM);</span><br><span class="line">    sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;consumer_number, <span class="number">0</span>, CNUM);</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CNUM; i++)&#123;  </span><br><span class="line">      pthread_create(&amp;cid[i], <span class="literal">NULL</span>, consumer, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CNUM; i++)&#123;</span><br><span class="line">        pthread_join(cid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这其实只是一对多的情况，一个生产者，多个产品，多个消费者，双方的速率也都是随机的，而且没有将“拿出”和“消耗”的产品的操作单独分开，比较简陋</strong></p><p>单纯讨论线程间的同步问题，双方速率和产品 暂且不论，有两个关键变量，生产者个数，消费者个数，就有4种情况</p><ul><li><p>一生产，一消费。</p></li><li><p>多生产，一消费。</p></li><li>一生产，多消费。</li><li>多生产，多消费。</li></ul><p>思想是一样的，每有需要进行同步的线程组，就需要设定一个锁（不是绝对，根据需要</p><p>生产者与消费者之间，就需要一个锁，而消费者与消费者之间也会需要一个锁，确保每个消费者都能拿到数据</p><h3 id="进程间的互斥量"><a href="#进程间的互斥量" class="headerlink" title="进程间的互斥量"></a>进程间的互斥量</h3><p>如果想要将这些线程库中的锁给进程使用呢？</p><p>这个时候就需要在进行锁的定义时对锁的属性进行修改</p><h4 id="进程的锁"><a href="#进程的锁" class="headerlink" title="进程的锁"></a>进程的锁</h4><p>定义一个锁属性的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mutexattr;</span><br></pre></td></tr></table></figure><p>需要对这个属性在进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_init(&amp;mutexattr);</span><br></pre></td></tr></table></figure><p>调用设置属性函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_setpshared(&amp;mutexattr， <span class="type">int</span> pshared);</span><br></pre></td></tr></table></figure><p>注意第二个参数的取值</p><ul><li>PTHREAD_PROCESS_SHARED(公开给进程使用的锁)</li><li>PTHREAD__PROCESS_PRIVATE(线程私有的锁)；</li></ul><p>当不需要使用该属性结构体时同样需要调用destroy函数对属性进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_destroy(&amp;mutexattr);</span><br></pre></td></tr></table></figure><h4 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h4><p>基于fcntl实现，说实话我都忘了咋怎么用了，隐约记得一般用来修改文件的属性。</p><p>锁的设置，区别不大其实，只不过换了个函数实现而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>需要用到的宏参，第二个参数</p><ul><li>F_SETLK 设置文件锁（trylock）</li><li>F_SETLKW 设置文件锁 （lokc) W wait</li><li>F_GETLK 获取当前文件锁 </li></ul><p>要设置的锁的结构体，同时也是第三个参数</p><p>struct flock（这里列用到的数据）</p><ul><li>…..</li><li>short l_type;<ul><li>锁的类型</li><li>F_RDLCK（读锁）</li><li>F_WRLCK（写锁）</li><li>F_UNLCK（无文件锁）</li></ul></li><li>short l_whence<ul><li>文件的指针的起始位置<ul><li>SEEK_SET</li><li>SEEK_END</li><li>SEEK_CUR</li></ul></li></ul></li><li>off_t l_start<ul><li>从哪开始出现锁的位置，相对于起始位置的偏移量</li></ul></li><li>off_t l_len<ul><li>要锁的字节量</li><li>特殊值0 ，所有的</li></ul></li><li>pid_t l_pid<ul><li>当使用F_GETlK时才会获取到该锁的进程id</li></ul></li></ul><p>使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;filelock r/w\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;文件锁文件.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_whence = SEEK_SET;</span><br><span class="line">    lock.l_start = <span class="number">0</span>;</span><br><span class="line">    lock.l_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        lock.l_type = F_RDLCK;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lock.l_type = F_WRLCK;</span><br><span class="line">    &#125;</span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get flokc\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);<span class="comment">//这个10s假设我在进行写操作 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unlock!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开了两个终端测试发现，文件锁的规则其实就是，写时独占，读时共享</p><p><strong>注意这是，进程间独占的锁机制</strong></p><p>在线程中实际上使用的读写锁</p><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><p>五个哲学家在一个餐桌上吃饭，每个人只有一根筷子，想要吃上中间的菜，一个人需要完整的一双筷子（</p><p>一个人想要吃菜，就拿下一个人的筷子（咦惹</p><p>1—-2</p><p>2—-3</p><p>3—-4</p><p>4—-5</p><p>5—-1</p><p>这个时候如果5个人同时想吃菜，五个人都拿了下一个人的筷子，自己的筷子同时也被前一个人拿走了，这个时候就出现一个一比较尴尬的状态。如果此时谁也不肯放那么就没有人能够吃菜。</p><p>代码模拟一下这个问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 5</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">       pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[COUNT];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_init(&amp;mutex[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, diner, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说我运气有点好。运行了好5秒都没出现死锁现象，还以为写错了，好在第二次进行运行时死锁了。</p><p>死锁了咋整呢？</p><p>有三种解决方案</p><ul><li>有个人主动放弃拿自己的筷子，先去拿别人的筷子，这样就能保证自己的筷子能被下一个人拿到凑成两个。</li><li>再定义一个互斥量，用来锁住其他人拿到筷子，保证有一个人拿到一双</li><li>嘶，想了想好像不知三种解决方案啊。比如什么不同的序号不同取筷子的顺序，或者定义一个为n-1的信号量，有一个人必须等待其他n个人执行拿筷子动作后都成功后才能拿筷子。等等。</li></ul><p>归根结底，只要保证有一个人肯定能够拿到一双筷子就可以实现永动。</p><p>对了忘了这里再补个进程版的哲学家问题。</p><p>这里使用信号量作为锁</p><p>当然也可以用mutex</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">nt <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">sem_t</span> *lock= mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sem_t</span>)* count, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_init(&amp;lock[i], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">           left = i;</span><br><span class="line">           right = <span class="number">0</span>;     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          left = i;</span><br><span class="line">          right = i + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;    </span><br><span class="line">            sem_wait(&amp;lock[left]);</span><br><span class="line">            sem_wait(&amp;lock[right]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 进餐\n&quot;</span>, i);</span><br><span class="line">            sem_post(&amp;lock[left]);</span><br><span class="line">            sem_post(&amp;lock[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG); </span><br><span class="line">            <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(wpid != <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_destroy(&amp;lock[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap(lock,<span class="keyword">sizeof</span>(<span class="type">sem_t</span>)*count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的事进程需要用到锁时</p><p>注意初始化的锁的属性，是否分享给进程使用。</p><h4 id="解决方案代码"><a href="#解决方案代码" class="headerlink" title="解决方案代码"></a>解决方案代码</h4><p>这里简单例一个比较简单的解决方式</p><p>再加一个锁，获取当有有人拿起筷子时，其他人都不能动</p><p>当然，这样原本好好的并行线程就给搞成串行了，能不能再优化呢？答案是可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只需要，把加的读写锁改成信号量，最多可以实现4个线程，不过有一个线程就得先当冤大头了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"><span class="type">sem_t</span> lock;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">            sem_wait(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            sem_post(&amp;lock);</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            sem_wait(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            sem_post(&amp;lock);</span><br><span class="line">            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然也可以，将奇数线程，先拿左手筷子，偶数线程先拿右手筷子，交错拿。也可以避免死锁问题</p><p>等等，思想是不变的，保证只要总有边界资源能够释放就是可以避免</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础06 | 时序竞态与守护进程</title>
      <link href="/2022/08/20/linux06/"/>
      <url>/2022/08/20/linux06/</url>
      
        <content type="html"><![CDATA[<h1 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h1><p>CPU进程之间的竞争</p><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h3><p>调用该函数的进程主动挂起，等待任意信号唤醒，然后执行这个信号的默认行为，想要让这个程序继续运行就需要对这个信号进行捕捉，执行自定义的响应函数</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    </span><br><span class="line">    act.sa_flags= <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = catch;</span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret = pause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno == EINTR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pause sucess\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret =  alarm(<span class="number">0</span>);<span class="comment">//手动结束闹钟//当出现预期之外的信号干扰而唤醒时，提前结束这个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//还原信号捕捉函数的系统默认设置（上一个旧设置）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这里就会出现了一个比较致命的问题，设想这么个情况</p><p>假设在mysleep的闹钟函数中，</p><p>确实执行了定时器alarm函数成功定时了（这里假设只定时了1秒），准备执行pause时突然有其他进程抢占了CPU导致这个pause暂时得不到资源运行，足足停止了2秒钟没有运行，这时定时器已经发送过信号了，可这个信号是被捕捉的信号什么也不做的前提下，pause却这个时候执行了，进程挂起，可是再也收不到信号了，就会一直等啊等,导致整个进程阻塞。</p><p>在没有其他的函数处理这个时序竞态问题的话，首先想到的方法：</p><ul><li>在响应函数中，进行一个pause语句是否执行的判断（利用一个全局变量接受pause的返回值就行），如果没有执行，就再一次重置该闹钟。直到pause语句能够执行。</li></ul><p>这个方法我感觉可行，没有测试过，有能力条件的可以测试一下运行几千几万次试试效果。</p><p>第二个方法：</p><ul><li>函数sigsuspend()与信号集操作函数代替pause()的阻塞功能</li></ul><h3 id="sigsuspend"><a href="#sigsuspend" class="headerlink" title="sigsuspend"></a>sigsuspend</h3><p>函数的作用就是设定一个临时的信号屏蔽字，当收到其中一个没有被信号之前，进行一个挂起的操作pause,从而代替pause</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mysleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> newmask, oldmask, susmask;</span><br><span class="line">    </span><br><span class="line">    act.sa_flags= <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = catch;</span><br><span class="line">    ret = sigaction(SIGALRM, &amp;act, &amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);<span class="comment">//将之前进程中的信号屏蔽字取出放入oldmask </span></span><br><span class="line">    </span><br><span class="line">    susmask = oldmask; </span><br><span class="line">    sigdelset(&amp;susmask, SIGALRM);<span class="comment">//保证这个信号在临时的信号集没有被屏蔽</span></span><br><span class="line"></span><br><span class="line">    alarm(seconds);</span><br><span class="line">    ret =  alarm(<span class="number">0</span>);<span class="comment">//手动结束闹钟//当出现预期之外的信号干扰而唤醒时，提前结束这个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//还原信号捕捉函数的系统默认设置（上一个旧设置）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    sigsuspend(&amp;susmask);</span><br><span class="line">    <span class="type">int</span> unslept = alarm(<span class="number">0</span>);<span class="comment">//手动结束闹钟//当出现预期之外的信号干扰而唤醒时，提前结束这个闹钟</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复对信号SIGALRM的处理动作</span></span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oldmask,<span class="literal">NULL</span>);<span class="comment">//恢复对信号进行屏蔽前的设置</span></span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时序竞态的产生原因"><a href="#时序竞态的产生原因" class="headerlink" title="时序竞态的产生原因"></a>时序竞态的产生原因</h3><p>CPU的竞争，系统负载</p><p>也表明了信号确实也不是很可靠啊</p><p>解决方法：</p><p>主动预见其产生，主动编写函数处理，原子操作</p><h3 id="全局变量的异步IO"><a href="#全局变量的异步IO" class="headerlink" title="全局变量的异步IO"></a>全局变量的异步IO</h3><p>分析父子进程交替数数程序，当前捕捉函数里的sleep取消，就会出现的必然问题（时序竞态的问题放大）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ParentCatch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am Parent %d\t%d\n&quot;</span>, getpid(), count);</span><br><span class="line">    count += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//sleep(1);   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ChildCatch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am Child %d\t%d\n&quot;</span>, getpid(), count);</span><br><span class="line">    count += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>; </span><br><span class="line">   <span class="comment">// sleep(1);    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        count = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = ChildCatch;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                kill(getppid(),SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">//保证子进程注册信号捕捉</span></span><br><span class="line">        act.sa_handler = ParentCatch;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        ParentCatch(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">                kill(pid,SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常有sleep的时运行是没有问题的，可去掉sleep后运行之后可以发现，明明应该无限执行的进程，突然就死在某个数字上不动了，说明，发生了异常，这个异常的本质原因就是时序竞态，而直接原因，就是sleep被删除，没有足够时间进行CPU资源的争抢导致信号没发出去，比如子/父进程不检查flag值，也没有发送信号。</p><p>解决方法：</p><ul><li>去掉flag这个用来判断的全局变量，很显然的，flag根本没用，多此一举，直接在信号响应函数中发送信号，就没这么多屁事了</li><li>还可以使用锁，锁住这个flag全局变量。但是没必要（）</li></ul><h3 id="可重入与不可重入函数"><a href="#可重入与不可重入函数" class="headerlink" title="可重入与不可重入函数"></a>可重入与不可重入函数</h3><h4 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h4><p>一个函数在调用执行期间由于某种时序又被调用，称之为“重入”</p><p>递归函数就是一个重入函数形式</p><p>重入函数不应该含有全局变量,不要有malloc和free!</p><p>信号处理函数中有些可以重入，有些不可重入</p><p>safely called inside(可重入)</p><p>不可重入的：</p><ul><li>包含静态与全局</li><li>标准的I/O函数</li><li>有内存操作 malloc free new delete</li></ul><h3 id="子进程信号SIGCHLD"><a href="#子进程信号SIGCHLD" class="headerlink" title="子进程信号SIGCHLD"></a>子进程信号SIGCHLD</h3><p>信号的产生条件</p><ul><li>子进程终止时</li><li>子进程接收到SIGSTOP时</li><li>子进程处在停止态，接收到SIGCONT后唤醒时</li></ul><p>利用这个信号我们也可以回收子进程，不过需要注意信号集是个set集合</p><h3 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h3><p>信号也可以携带一定量的参数数据，</p><p>可以使用sigqueue函数对应kill函数</p><p>可在指定进程发送信号的同时携带参数,可以是一个int 和一个指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br></pre></td></tr></table></figure><h4 id="捕捉信号传参"><a href="#捕捉信号传参" class="headerlink" title="捕捉信号传参"></a>捕捉信号传参</h4><p>捕捉信号发送的参数，同样也可以使用sigaction函数 在传出参数的int&amp;</p><p>struct sigaction 的       void     (<em>sa_sigaction)(int, siginfo_t </em>, void *);</p><p>捕捉到相关信号的参数存储在 int 或者 siginfo_t* 的类型的结构体中</p><p>具体结构体可查阅man文档，需要注意的使用的时候需要配置sa_flag</p><h3 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h3><p>慢速的系统调用</p><p>会永久阻塞系统调用进程的</p><ul><li>pause</li><li>wait</li><li>read<ul><li>读空洞，读网络，读管道的时候，读设备（键盘等）</li></ul></li><li>等等</li></ul><p>其他系统调用：</p><ul><li>除了慢速系统调用都是</li></ul><p>慢速的系统调用 收到信号打断，或者唤醒</p><p>当慢速系统调用收到信号打断，就被成为终端系统调用</p><p>在慢速系统调用中我们需要对信号捕捉判断处理除了判断是否成功捕获还需要判断errno 是否为EINTR（表示慢速系统调用函数被信号打断）</p><p>打断后的处理方式通过sa_flag的配置</p><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>主进程默认创建了无数个子进程</p><p>子进程的进程组ID实际上就是主进程的PID</p><h4 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a>进程组操作函数</h4><p>getpgrp();<br>获取当前进程的进程组id</p><p>getpgid(pid);<br>获取指定进程的进程组ID</p><p>setpgid(pid,pgid);<br>设置指定进程的父进程id</p><p>结合使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        setpgid(pid, pid);<span class="comment">//让子进程脱离父进程</span></span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程：id:%u \n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程的父进程的id：id:%u \n&quot;</span>, getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程的所属的进程组：id:%u \n&quot;</span>, getpgrp());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设置父进程的的进程组是自己父进程\n&quot;</span>);</span><br><span class="line">        setpgid(getpid(), getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程的所属的进程组：id:%u \n&quot;</span>, getpgrp());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的pid %u 所属进程组 %u\n&quot;</span>, getpid(), getpgrp());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程的pid %u 所属进程组 %u\n&quot;</span>, getpid(), getpgrp());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="会话（session）"><a href="#会话（session）" class="headerlink" title="会话（session）"></a>会话（session）</h3><p>进程组是进程的集合</p><p>而进程组的集合，就是会话</p><p>创建会话</p><ul><li>创建会话的进程不能是已有的组长进程</li><li>创建会话的进程会成为一个新进程组的组长进程</li><li>需要root权限（ubuntu不需要）</li><li>新会话丢弃原有的控制终端，该会话没有控制终端</li><li>调用进程是组长进程出错返回</li><li>建立新会话时 ，执行顺序为：fork 终止父进程，子进程调用setsid。</li></ul><p>子进程是野鸡变凤凰了，自立门户并且成为组长，会话ID也变成自己</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Daemon(精灵)进程，是linux的后台服务进程，通常独立于控制终端并且周期性执行某种任务或等待处理。</p><p>可以理解为后台服务，没有控制终端，很多服务器进程就是守护进程</p><p>一般守护进程名字末尾都是d</p><h4 id="创建一个守护进程"><a href="#创建一个守护进程" class="headerlink" title="创建一个守护进程"></a>创建一个守护进程</h4><ul><li>最关键的步骤其实就是创建会话<ul><li>创建子进程，关闭主进程，创建会话</li></ul></li><li>改变当前工作目录为根目录chdir();<ul><li>防止占用可卸载的文件系统（U盘，扩展内存卡等外设存储设备）</li><li>可以更改其他路径</li></ul></li><li>重设文件权限掩码umask一般都是0002，有特殊需要就设置</li><li>关闭文件描述符标准输出输入和出错 fd[0,1,2]<ul><li>不过一般都不关闭，而是进行重定向到黑洞NULL文件</li><li>dup2(fd[1], null)</li></ul></li><li>开始执行守护进程的核心进程</li></ul><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mydaemon</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步，子进程创建</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> sid = setsid();<span class="comment">//子进程变更为会话</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/icrad&quot;</span>);<span class="comment">//改变会话的工作目录</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">mode_t</span> mask = <span class="number">0000</span>; <span class="comment">//改变会话的文件权限掩码</span></span><br><span class="line">    umask(mask);</span><br><span class="line">    </span><br><span class="line">    close(STDIN_FILENO);  <span class="comment">//关闭一个输入端</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">//打开黑洞文件</span></span><br><span class="line">    dup2(STDIN_FILENO, STDERR_FILENO); <span class="comment">//把标准输出和错误全部都导向黑洞</span></span><br><span class="line">    dup2(STDIN_FILENO, STDOUT_FILENO);</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    mydaemon();<span class="comment">//创建一个守护进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主进程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="守护进程特性"><a href="#守护进程特性" class="headerlink" title="守护进程特性"></a>守护进程特性</h4><ul><li>不受用户注销，挂起的影响，除非你关机</li><li>快乐</li></ul><p>编写一个守护进程：每隔一定时间输出系统时间到一个文件中</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeDate</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd_r = open(<span class="string">&quot;Date.log&quot;</span>, O_CREAT|O_RDWR|O_APPEND, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd_r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案一:出错，无法写入</span></span><br><span class="line">    <span class="comment">//dup2(STDOUT_FILENO,fd_r);</span></span><br><span class="line">    <span class="comment">//execlp(&quot;date&quot;, &quot;date&quot;, NULL);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方案2</span></span><br><span class="line">    <span class="type">time_t</span> timp;</span><br><span class="line">    time(&amp;timp);</span><br><span class="line">    <span class="type">char</span>* time = asctime(localtime(&amp;timp));</span><br><span class="line">    write(fd_r,time,<span class="built_in">strlen</span>(time));</span><br><span class="line">    <span class="comment">//close(fd_r);</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mydaemon</span><span class="params">(<span class="type">int</span> sec)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步，子进程创建</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> sid = setsid();<span class="comment">//子进程变更为会话</span></span><br><span class="line">    <span class="type">int</span> ret = chdir(<span class="string">&quot;/home/icrad&quot;</span>);<span class="comment">//改变会话的工作目录</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">mode_t</span> mask = <span class="number">0000</span>; <span class="comment">//改变会话的文件权限掩码</span></span><br><span class="line">    umask(mask);</span><br><span class="line">    close(STDIN_FILENO);  <span class="comment">//关闭一个输入端</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">//打开黑洞文件</span></span><br><span class="line">    dup2(STDIN_FILENO, STDERR_FILENO); <span class="comment">//把标准输出和错误全部都导向黑洞</span></span><br><span class="line">    dup2(STDIN_FILENO, STDOUT_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">settime</span>;</span></span><br><span class="line">    settime.it_interval.tv_sec = sec;</span><br><span class="line">    settime.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    settime.it_value.tv_sec = sec;</span><br><span class="line">    settime.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, writeDate);</span><br><span class="line">    setitimer(ITIMER_REAL, &amp;settime, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入打印间隔时间\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> time = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印间隔为%ds\n&quot;</span>, time);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印间隔输入有误,默认为5秒\n&quot;</span>);</span><br><span class="line">        time = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mydaemon(time);<span class="comment">//创建一个守护进程</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础06|同步</title>
      <link href="/2022/08/20/tongbu/"/>
      <url>/2022/08/20/tongbu/</url>
      
        <content type="html"><![CDATA[<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>啥事同步</p><p>一般都说有两个对象以上，同时起步的，协调步调的进行操作。然而不同的对象，又有不同的同步概念</p><p>设备同步，两个设备之间的一个共同时间的参考，数据库同步等等</p><p>在linxu中我们需要了解线程同步，与进程同步的概念，以便我们更好的设计多进程多线程业务。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>同步即协同步调，按照预订的先后次序运行</p><p>一个线程调用一个函数时，为了保证其他线程调用时的数据一致性，不能调用其他函数</p><p>这个时候我们就需要给这个调用的数据，上一个锁，对共享的区域做一个保护。</p><p>在linux中，当多个流程操作一个共享资源时根据需求加锁</p><h2 id="常见锁"><a href="#常见锁" class="headerlink" title="常见锁"></a>常见锁</h2><h3 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h3><h4 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a>pthread_mutex_init</h4><p>初始化一个互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><p>注意这个关键词restrict，指名只能使用该指针，不能通过其他指针操作内存指向</p><ul><li>pthread_mutex_t *restrict mutex 可以单纯理解为锁 ，锁上是为0,解锁为1</li><li>mutex,const pthread_mutexattr_t *restrict attr  锁的属性</li></ul><p>默认初始值为1</p><p>当不需要使用特殊配置时，可以直接使用宏变量赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITALIZER</span><br></pre></td></tr></table></figure><p>来代替该函数</p><h4 id="pthread-mutex-destory"><a href="#pthread-mutex-destory" class="headerlink" title="pthread_mutex_destory"></a>pthread_mutex_destory</h4><p>删除一个互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>一般在结束时，不再使用该锁时，进行调用删除</p><h4 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a>pthread_mutex_lock</h4><p>顾名思义，上锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>可以简单理解为对锁进行减1操作</p><h4 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a>pthread_mutex_unlock</h4><p>顾名思义，释放锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>可以简单理解为对锁进行++操作</p><p>配合lock使用，</p><p>在不同的线程中需要访问同一个共享内存，都需要执行上锁和解锁的操作</p><p>使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">printHello</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;world!\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//当调用成功mutex值为1</span></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, printHello, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;error : %s&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WORLD!\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(tid);<span class="comment">//检查点在sleep具体是哪一个是随机的</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：锁的粒度应该是越小越好，访问共享操作后立即解锁</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>是一种现象，而不是一种新的锁机制。</p><p>产生的原因</p><ul><li><p>没有解锁（unlock，对同一个共享内存加锁（会出现lock两次的情况</p><ul><li>可以理解为，一个唯一会开锁的小偷把自己锁在了保险库，其他同伙想进去，等待笨比解锁，而笨比被自己锁在里头了，自己又忘记了解锁密码。偷钱活动就此失败。想要打开保险库，必须触发保险库中的机关，这个机关会把保险库的小偷给杀死。</li></ul></li><li><p>两个锁造成的死锁</p><ul><li><p>有两个共享数据，线程一需要同时拿到两把锁才能访问两个共享数据，<br>假设</p><p>线程2只拿到锁1,当锁2拿到后才能释放锁1</p><p>线程1只拿到锁2,当锁1拿到后才能释放锁2</p><p>流沙河，你下来，你上来，你过来我就下去，你下来我就上去。</p></li></ul></li></ul><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">()</span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>); </span><br><span class="line">        b += <span class="number">100</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i m thread, a = %d , b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定一个死锁现象</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, tfn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count--)&#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex1);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex2);</span><br><span class="line">        b += <span class="number">100</span>;  </span><br><span class="line">        pthread_mutex_unlock(&amp;mutex1);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i m main, a = %d , b = %d \n&quot;</span>, a, b);</span><br><span class="line">    &#125; </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex1);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex2);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h4><ul><li>第一种死锁<ul><li>可以直接避免，只要你写的细心一点</li></ul></li><li>第二种<ul><li>调用trylock，线程一方拿不到锁时，主动释放锁</li></ul></li></ul><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><strong>写独占，读共享。写锁的优先级更高</strong></p><p>对一个共享数据进行操作的锁，常用在读次数大于写的情况。</p><p>当线程1读操作时，其他线程也可以对其进行读操作，这是共享模式锁</p><p>当线程执行写操作上了写操作时，其他线程都无法对其进行任何操作，这是独占模式锁</p><h4 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h4><p>初始化读写锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h4><p>删除锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h4 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h4><p>设定一个读锁</p><h4 id="pthread-rwlock-wdlock"><a href="#pthread-rwlock-wdlock" class="headerlink" title="pthread_rwlock_wdlock"></a>pthread_rwlock_wdlock</h4><p>设定一个写锁</p><h4 id="pthread-rwlock-trywrlock"><a href="#pthread-rwlock-trywrlock" class="headerlink" title="pthread_rwlock_trywrlock"></a>pthread_rwlock_trywrlock</h4><p>尝试写锁，非阻塞的写法</p><h4 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a>pthread_rwlock_unlock</h4><p>解锁</p><p>其实读写锁的核心就14个字：</p><p>读时占用，写时共享，写锁优先级高</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> olda;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   olda = a;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;====write :%d olda = %d, a = %d \n&quot;</span>, i, olda, ++a);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read :%d a = %d\n&quot;</span>, i, a);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">900</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./name rtnums wtnums\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count_r = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> count_w = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tidr[count_r];</span><br><span class="line">    <span class="type">pthread_t</span> tidw[count_w];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; count_w; i++)&#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tidw[i], <span class="literal">NULL</span>, th_write, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_r; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tidr[i], <span class="literal">NULL</span>, th_read, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tidr[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count_w; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tidw[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量本身不是锁,但是一样造成线程阻塞，说白了就是在互斥锁中进行条件判断，给多线程提供一个会合的场所</p><h4 id="pthread-cond-wait"><a href="#pthread-cond-wait" class="headerlink" title="pthread_cond_wait"></a>pthread_cond_wait</h4><p>阻塞等待一个条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li>第一个，老套路，一个结构体</li><li>第二个就有意思了，是一个互斥锁结构体。</li></ul><p>一个看就知道这个函数不是等闲之辈</p><p>重点就是这个函数，有三个作用</p><ul><li>阻塞等待条件变量cond满足</li><li>释放已掌握的互斥锁，实际上就是unlock(&amp;mutex);<ul><li>需要注意的是上方两个作用实际上只是一个原子操作。</li></ul></li><li>当被唤醒，pthread_cond_wait 函数返回时，解除阻塞并重新组阻塞并重新申请获取互斥锁相当于 lokc(&amp;mutex);</li></ul><p>注意这个唤醒，</p><p>有两种唤醒方式</p><ul><li>pthread_cond_signal<ul><li>唤醒一个</li></ul></li><li>pthread_cond_broadcast(广播)</li></ul><h4 id="pthread-cond-signal"><a href="#pthread-cond-signal" class="headerlink" title="pthread_cond_signal"></a>pthread_cond_signal</h4><p>唤醒满足条件变量的上的至少一个阻塞的线程</p><h4 id="pthread-cond-broadcast"><a href="#pthread-cond-broadcast" class="headerlink" title="pthread_cond_broadcast"></a>pthread_cond_broadcast</h4><p>唤醒所有的满足的条件变量阻塞的线程</p><h4 id="pthread-cond-timedwait"><a href="#pthread-cond-timedwait" class="headerlink" title="pthread_cond_timedwait"></a>pthread_cond_timedwait</h4><p>设定一个默认时间自动唤醒的wait</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>相较于一般的wait，多了一个结构体参数</p><p>const struct timespec abstime</p><ul><li>绝对时间的意思</li><li>绝对时间实际上也是相对的，从1970年1月1号0000开始计时</li><li>time_t tv_sec 秒</li><li>long tv_nsec 纳秒</li></ul><p>想要定时5秒钟实际上需要使用操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> cur =time(<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">struct</span> timespec t;</span><br><span class="line">t.tv_sec = cur + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模型实现"><a href="#生产者消费者模型实现" class="headerlink" title="生产者消费者模型实现"></a>生产者消费者模型实现</h3><p>一个典型的线程同步的模型</p><p>生产者，产品，消费者</p><p>生产者进程负责生产产品</p><p>消费者进程负责消费产品</p><p>一个简单的实现代码</p><p>这里是定义了一个简单的链表节点，一个生产者每次生产一个，一个消费者也每次消费一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">while</span> (head == <span class="literal">NULL</span>)<span class="comment">//这里用while是精髓</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        mp = head;</span><br><span class="line">        head = mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Consume ----%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        mp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        mp-&gt;num = rand() %<span class="number">1000</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-Produce ----%d\n&quot;</span>, mp-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        mp-&gt;next = head;</span><br><span class="line">        head = mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> sid, cid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_create(&amp;sid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(sid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h4><p>相较于mutex，能减少不必要的竞争，如果没有释放，多个进程之间还会互相竞争</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>进化版的互斥锁，虽然也是线程库函数里的东西，但是，是<strong>可以用在进程间的锁</strong></p><p>初始化的值是N值<em>（与互斥锁默认值为1不同，N值是自己可以指定任意数值(必须是正整数)，可以理解为锁的钥匙，资源量，<em>*可以同时使用这把锁的进程数</em></em>。</p><p>出现的考量，是为了多个进程or线程需要共同访问一个的共享资源的同时，保证线程或者进程的并发性。</p><h4 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_t sem</li><li>pshared 是否在进程共享</li><li>unsigned int value 设定的值</li></ul><h4 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy"></a>sem_destroy</h4><p>对应的删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait"></a>sem_wait</h4><p>加锁函数，等同于lock,一样可以理解为—操作，当值为0时，进行阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait"></a>sem_trywait</h4><p>尝试加锁，同理trylock,非阻塞式加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h4><p>解锁，等同于unlock，一样可以理解为++操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="sem-timedwait"><a href="#sem-timedwait" class="headerlink" title="sem_timedwait"></a>sem_timedwait</h4><p>定时加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>同样是绝对时间</p><p>直接看代码示例吧</p><p>比如说实现一个线程每隔五秒打印“hello world”，用户与输入立马打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> lock;</span><br><span class="line"><span class="type">char</span> str[<span class="number">64</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">printHello</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> ;</span></span><br><span class="line">        t.tv_sec = cur + <span class="number">5</span>;</span><br><span class="line">        sem_timedwait(&amp;lock, &amp;t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hellp world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">scanInput</span><span class="params">(<span class="type">void</span> *p)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;    </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strlen</span>(str) == <span class="number">0</span>)&#123;</span><br><span class="line">           fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        sem_post(&amp;lock);</span><br><span class="line">        <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pid, cid;</span><br><span class="line">    sem_init(&amp;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, printHello, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cid, <span class="literal">NULL</span>, scanInput, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="还是典型的消费者生产者模型"><a href="#还是典型的消费者生产者模型" class="headerlink" title="还是典型的消费者生产者模型"></a>还是典型的消费者生产者模型</h3><p>上方实现的模型的一对一的进化版</p><p>一个生产者，多个产品，一个消费者，不过此时消费者在某种意义上来说也是一种生产者的角色，生产一个空，此时公共区产品使用queue（队列）表示</p><p>一个生产者，多个产品，二个消费者，生产速率和消费速率是随机的，代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CNUM 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];</span><br><span class="line"><span class="type">sem_t</span> blank_number, product_number;</span><br><span class="line"><span class="type">sem_t</span> consumer_number;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(&amp;blank_number);</span><br><span class="line">        <span class="built_in">queue</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Produce----%d\n&quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number);</span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;<span class="comment">//循环赋值</span></span><br><span class="line">        sleep(rand() % <span class="number">1</span>);<span class="comment">//模拟生产产品时间，随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(&amp;product_number);</span><br><span class="line">        sem_wait(&amp;consumer_number);</span><br><span class="line">         <span class="keyword">while</span> (<span class="built_in">queue</span>[i] == <span class="number">0</span>)&#123;</span><br><span class="line">             i = (i+<span class="number">1</span>) % NUM;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Consumer NO.%d----%d\n&quot;</span>, j, <span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i] = <span class="number">0</span>;</span><br><span class="line">        sem_post(&amp;consumer_number);</span><br><span class="line">        sem_post(&amp;blank_number);</span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;<span class="comment">//循环遍历</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);<span class="comment">//随机数，模拟消费者对产品的消化时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> cid[CNUM], pid;</span><br><span class="line">    sem_init(&amp;blank_number, <span class="number">0</span>, NUM);</span><br><span class="line">    sem_init(&amp;product_number, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;consumer_number, <span class="number">0</span>, CNUM);</span><br><span class="line">    pthread_create(&amp;pid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CNUM; i++)&#123;  </span><br><span class="line">      pthread_create(&amp;cid[i], <span class="literal">NULL</span>, consumer, (<span class="type">void</span> *)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CNUM; i++)&#123;</span><br><span class="line">        pthread_join(cid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(pid, <span class="literal">NULL</span>);</span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这其实只是一对多的情况，一个生产者，多个产品，多个消费者，双方的速率也都是随机的，而且没有将“拿出”和“消耗”的产品的操作单独分开，比较简陋</strong></p><p>单纯讨论线程间的同步问题，双方速率和产品 暂且不论，有两个关键变量，生产者个数，消费者个数，就有4种情况</p><ul><li><p>一生产，一消费。</p></li><li><p>多生产，一消费。</p></li><li>一生产，多消费。</li><li>多生产，多消费。</li></ul><p>思想是一样的，每有需要进行同步的线程组，就需要设定一个锁（不是绝对，根据需要</p><p>生产者与消费者之间，就需要一个锁，而消费者与消费者之间也会需要一个锁，确保每个消费者都能拿到数据</p><h3 id="进程间的互斥量"><a href="#进程间的互斥量" class="headerlink" title="进程间的互斥量"></a>进程间的互斥量</h3><p>如果想要将这些线程库中的锁给进程使用呢？</p><p>这个时候就需要在进行锁的定义时对锁的属性进行修改</p><h4 id="进程的锁"><a href="#进程的锁" class="headerlink" title="进程的锁"></a>进程的锁</h4><p>定义一个锁属性的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutexattr_t</span> mutexattr;</span><br></pre></td></tr></table></figure><p>需要对这个属性在进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_init(&amp;mutexattr);</span><br></pre></td></tr></table></figure><p>调用设置属性函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_setpshared(&amp;mutexattr， <span class="type">int</span> pshared);</span><br></pre></td></tr></table></figure><p>注意第二个参数的取值</p><ul><li>PTHREAD_PROCESS_SHARED(公开给进程使用的锁)</li><li>PTHREAD__PROCESS_PRIVATE(线程私有的锁)；</li></ul><p>当不需要使用该属性结构体时同样需要调用destroy函数对属性进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_destroy(&amp;mutexattr);</span><br></pre></td></tr></table></figure><h4 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h4><p>基于fcntl实现，说实话我都忘了咋怎么用了，隐约记得一般用来修改文件的属性。</p><p>锁的设置，区别不大其实，只不过换了个函数实现而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><p>需要用到的宏参，第二个参数</p><ul><li>F_SETLK 设置文件锁（trylock）</li><li>F_SETLKW 设置文件锁 （lokc) W wait</li><li>F_GETLK 获取当前文件锁 </li></ul><p>要设置的锁的结构体，同时也是第三个参数</p><p>struct flock（这里列用到的数据）</p><ul><li>…..</li><li>short l_type;<ul><li>锁的类型</li><li>F_RDLCK（读锁）</li><li>F_WRLCK（写锁）</li><li>F_UNLCK（无文件锁）</li></ul></li><li>short l_whence<ul><li>文件的指针的起始位置<ul><li>SEEK_SET</li><li>SEEK_END</li><li>SEEK_CUR</li></ul></li></ul></li><li>off_t l_start<ul><li>从哪开始出现锁的位置，相对于起始位置的偏移量</li></ul></li><li>off_t l_len<ul><li>要锁的字节量</li><li>特殊值0 ，所有的</li></ul></li><li>pid_t l_pid<ul><li>当使用F_GETlK时才会获取到该锁的进程id</li></ul></li></ul><p>使用代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;filelock r/w\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;文件锁文件.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">    lock.l_whence = SEEK_SET;</span><br><span class="line">    lock.l_start = <span class="number">0</span>;</span><br><span class="line">    lock.l_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        lock.l_type = F_RDLCK;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        lock.l_type = F_WRLCK;</span><br><span class="line">    &#125;</span><br><span class="line">    fcntl(fd, F_SETLKW, &amp;lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get flokc\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);<span class="comment">//这个10s假设我在进行写操作 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unlock!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开了两个终端测试发现，文件锁的规则其实就是，写时独占，读时共享</p><p><strong>注意这是，进程间独占的锁机制</strong></p><p>在线程中实际上使用的读写锁</p><h3 id="哲学家进餐"><a href="#哲学家进餐" class="headerlink" title="哲学家进餐"></a>哲学家进餐</h3><p>五个哲学家在一个餐桌上吃饭，每个人只有一根筷子，想要吃上中间的菜，一个人需要完整的一双筷子（</p><p>一个人想要吃菜，就拿下一个人的筷子（咦惹</p><p>1—-2</p><p>2—-3</p><p>3—-4</p><p>4—-5</p><p>5—-1</p><p>这个时候如果5个人同时想吃菜，五个人都拿了下一个人的筷子，自己的筷子同时也被前一个人拿走了，这个时候就出现一个一比较尴尬的状态。如果此时谁也不肯放那么就没有人能够吃菜。</p><p>代码模拟一下这个问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 5</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">       pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pthread_t</span> tid[COUNT];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      pthread_mutex_init(&amp;mutex[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, diner, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error:%s&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说我运气有点好。运行了好5秒都没出现死锁现象，还以为写错了，好在第二次进行运行时死锁了。</p><p>死锁了咋整呢？</p><p>有三种解决方案</p><ul><li>有个人主动放弃拿自己的筷子，先去拿别人的筷子，这样就能保证自己的筷子能被下一个人拿到凑成两个。</li><li>再定义一个互斥量，用来锁住其他人拿到筷子，保证有一个人拿到一双</li><li>嘶，想了想好像不知三种解决方案啊。比如什么不同的序号不同取筷子的顺序，或者定义一个为n-1的信号量，有一个人必须等待其他n个人执行拿筷子动作后都成功后才能拿筷子。等等。</li></ul><p>归根结底，只要保证有一个人肯定能够拿到一双筷子就可以实现永动。</p><p>对了忘了这里再补个进程版的哲学家问题。</p><p>这里使用信号量作为锁</p><p>当然也可以用mutex</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">nt <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">sem_t</span> *lock= mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">sem_t</span>)* count, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_init(&amp;lock[i], <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">           left = i;</span><br><span class="line">           right = <span class="number">0</span>;     </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          left = i;</span><br><span class="line">          right = i + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;    </span><br><span class="line">            sem_wait(&amp;lock[left]);</span><br><span class="line">            sem_wait(&amp;lock[right]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: 进餐\n&quot;</span>, i);</span><br><span class="line">            sem_post(&amp;lock[left]);</span><br><span class="line">            sem_post(&amp;lock[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG); </span><br><span class="line">            <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(wpid != <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_destroy(&amp;lock[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap(lock,<span class="keyword">sizeof</span>(<span class="type">sem_t</span>)*count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的事进程需要用到锁时</p><p>注意初始化的锁的属性，是否分享给进程使用。</p><h4 id="解决方案代码"><a href="#解决方案代码" class="headerlink" title="解决方案代码"></a>解决方案代码</h4><p>这里简单例一个比较简单的解决方式</p><p>再加一个锁，获取当有有人拿起筷子时，其他人都不能动</p><p>当然，这样原本好好的并行线程就给搞成串行了，能不能再优化呢？答案是可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            pthread_mutex_lock(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只需要，把加的读写锁改成信号量，最多可以实现4个线程，不过有一个线程就得先当冤大头了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex[COUNT];</span><br><span class="line"><span class="type">sem_t</span> lock;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">diner</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">            sem_wait(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            sem_post(&amp;lock);</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            sem_wait(&amp;lock);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i]);</span><br><span class="line">            pthread_mutex_lock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:好吃！\n&quot;</span>, i);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i]); </span><br><span class="line">            sem_post(&amp;lock);</span><br><span class="line">            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然也可以，将奇数线程，先拿左手筷子，偶数线程先拿右手筷子，交错拿。也可以避免死锁问题</p><p>等等，思想是不变的，保证只要总有边界资源能够释放就可以避免</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础05 | 线程</title>
      <link href="/2022/08/15/linuxlwp/"/>
      <url>/2022/08/15/linuxlwp/</url>
      
        <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>LWP：light weight process</p><p>轻量级的进程，本质仍是进程（linux环境下）</p><p>与win不同，区别挺大的，实现原理都不一样。</p><p>独立的进制空间，拥有PCB</p><p>线程：也有PCB，但没有独立的地址空间（共享）</p><p>区别：在于是否共享地址空间。</p><p>进程可以理解为独居</p><p>线程可以理解为合租</p><p>linux下的最小执行单位：线程</p><p>最小的资源分配单位：进程。</p><h3 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h3><p>进程进行类似fork的操作，但是没有对父进程地址空间进行克隆clone，而是使用原有进程的三级页表，页表最终指向物理页面，中间有三次映射，也被称为三级映射</p><p>进程-&gt;虚拟地址(页目录-&gt;页表-&gt;物理页面)MMU-&gt;物理地址</p><p>不过线程不是完全使用进程的三级页表，实际上线程与进程的区别在于寄存器和栈的内容，不一样</p><p>函数指针调用分配在栈中(用户程序之间的栈)</p><p>两个指针(ebp,esp)组合规划（滑动窗口）一个栈帧，一个函数（还有局部变量等）占用的就是一个栈帧</p><p>进程在切换时要保存寄存器的值，这些值分配在内核区的栈空间之中</p><h4 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h4><ul><li><p>文件文件描述符表</p></li><li><p>共享信号处理方式（信号建议不要与线程混用）</p></li><li><p>除了栈空间都共享</p></li></ul><h4 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h4><ul><li><p>线程Id</p></li><li><p>处理器现场（寄存器）和内核栈</p></li><li><p>独立的栈空间</p></li><li><p>errno变量（在代码段中）</p></li><li><p>信号屏蔽字</p></li><li><p>调度优先级</p></li></ul><h3 id="线程优缺"><a href="#线程优缺" class="headerlink" title="线程优缺"></a>线程优缺</h3><p>优点：程序并发性高，开销小，数据通信，共享数据方便</p><p>缺点：库函数不稳定，调试，编写困难，gdb不支持，对信号支持不好。</p><p>优点相对突出，缺点不是硬伤，linux下由于实现方法，进程，线程差别不是很大。</p><h2 id="控制原语"><a href="#控制原语" class="headerlink" title="控制原语"></a>控制原语</h2><h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self()"></a>pthread_self()</h3><p>获取线程id 注意不是LWP。</p><p>gcc编译的时候需要加入 -pthread。</p><h3 id="pthread-creat"><a href="#pthread-creat" class="headerlink" title="pthread_creat()"></a>pthread_creat()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>thread：线程id(传出)</li><li>attr：线程属性（传入）</li><li>start_routine：线程的主控函数（传入）</li><li>arg ：线程主控函数的参数（传入）</li></ul><p>返回值：int，成功0 ，出错返回error的错误编号</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thrd_func</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    var += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In %d thread  : %ld\n&quot;</span>, i+<span class="number">1</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var = %d\n&quot;</span>, var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h3><p>单个线程退出</p><p>与exit退出进程不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>retval 退出时当前线程状态，传出参数</li></ul><p>在线程中执行exit（）会直接将进程和线程退出</p><h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join()"></a>pthread_join()</h3><p>阻塞等待线程退出，获取线程退出状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125;<span class="type">test_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thrd_func</span><span class="params">(<span class="type">void</span>* retvar)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">test_t</span>* retval = (<span class="type">test_t</span>*)retvar;</span><br><span class="line">    retval-&gt;ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    retval-&gt;var = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(retval-&gt;str, <span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)retval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">test_t</span>* retval = (<span class="type">test_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">test_t</span>));</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="type">void</span>*)retval);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, (<span class="type">void</span> **)&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c , var = %d , str = %s&quot;</span>, retval-&gt;ch, retval-&gt;var, retval-&gt;str);</span><br><span class="line">    <span class="built_in">free</span>(retval);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回收COUNT个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tfn</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">        var = <span class="number">333</span>;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">        var = <span class="number">777</span>;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)&#123;</span><br><span class="line">        var = <span class="number">666</span>;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *tid[COUNT];</span><br><span class="line">    <span class="type">int</span> *ret[COUNT];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; COUNT; i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, tfn, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COUNT; i++)&#123;</span><br><span class="line">        pthread_join(tid[i], (<span class="type">void</span>**)&amp;ret[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回收了第%d个子线程，返回值ret= %d\n&quot;</span>, i+<span class="number">1</span>, ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prthread-detach"><a href="#prthread-detach" class="headerlink" title="prthread_detach()"></a>prthread_detach()</h3><p>线程设定为分离态，设定一个线程退出时自行回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>再进行回收就会报错了,</p><h3 id="prthread-cancel"><a href="#prthread-cancel" class="headerlink" title="prthread_cancel()"></a>prthread_cancel()</h3><p>取消线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>这个线程的取消并不是实时的，需要达到一个取消点才会取消，比如说内核调用，系统调用。或者自己设定1个取消点在线程中</p><p>具体取消点函数可看man 7 pthreads 或者apue 12.7</p><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>创建线程的第二个参数，pthread_attr_t;</p><h3 id="attr-t结构"><a href="#attr-t结构" class="headerlink" title="attr_t结构"></a>attr_t结构</h3><ul><li><strong>int etachstate</strong> <ul><li><strong>线程的分离状态</strong></li></ul></li><li>int schedpolicy<ul><li>线程调度策略</li></ul></li><li>struct sched_param schedparam<ul><li>线程调度参数</li></ul></li><li>int inheritsched<ul><li>线程调度继承性</li></ul></li><li>int scope<ul><li>作用域</li></ul></li><li><strong>size_t guardsize</strong><ul><li><strong>线程栈末尾的警戒缓冲区大小</strong></li><li>栈空间的函数地址的线程栈并非连着的，之间有一个警戒区分割</li></ul></li><li>int stackaddr_set<ul><li>线程的栈设置</li></ul></li><li>void* stackaddr<ul><li>线程栈的地址位置</li></ul></li><li><strong>size_t stacksize</strong><ul><li><strong>线程栈的大小</strong></li><li>最大线程大小，N个线程对这块大小进行均分分配</li></ul></li></ul><p>加粗的是一般比较常用的属性</p><h3 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h3><p>提前定义一个结构体pthread_attr</p><p>调用pthread_attr_init()，进行值的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>常用的：</p><h4 id="设置状态"><a href="#设置状态" class="headerlink" title="设置状态"></a>设置状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br></pre></td></tr></table></figure><p>参数二有两个宏参数可以使用</p><ul><li>PTHREAD_CREATE_DETACHED<ul><li>分离态</li></ul></li><li>PTHREAD_CREATE_JOINABLE<ul><li>可回收态</li></ul></li></ul><p>需要注意的是，在分离态的子线程如果结束过快，create函数的返回的线程id，可能就是错误的id，需要在该子线程中调用一个pthread_cond_timedwait()函数，保证在结束前返回线程id。</p><h4 id="修改线程栈空间"><a href="#修改线程栈空间" class="headerlink" title="修改线程栈空间"></a>修改线程栈空间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstack</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *stackaddr, <span class="type">size_t</span> stacksize)</span>;</span><br></pre></td></tr></table></figure><p> 参数二传入一个栈地址，参数三就是要设定的大小</p><p>需要先在在堆空间申请一个空间(毕竟说到底，用户能修改使用的还是堆)</p><p>stackaddr = malloc (SIZE);</p><p>设定好栈空间后，创建的函数就会放到这个设置好的新的空间中</p><p>大小的限制取决于用户的malloc的最大大小。</p><p>而当过小过大都会回到栈默认值中</p><h2 id="线程使用注意点"><a href="#线程使用注意点" class="headerlink" title="线程使用注意点"></a>线程使用注意点</h2><ul><li>需要注意NPTL：线程库的版本</li><li>避免僵尸。</li><li>线程中一般不使用fork创建子进程<ul><li>子进程中只有调用子进程的线程存在</li></ul></li><li>线程中避免使用信号</li></ul><h2 id="多线程拷贝"><a href="#多线程拷贝" class="headerlink" title="多线程拷贝"></a>多线程拷贝</h2><p>之前有做过的多进程拷贝，这次再做个多线程拷贝，在linux系统下线程本质上还是进程，所以区别不大，IPC依旧选择MMAP。</p><p>这里直接上代码，没有难点，巩固一下线程的基本原语和基本特性</p><p>这里试了试最大线程数：我可以开辟的最大线程为15297个线程,如果需要更大的线程数，就需要手动将内存空间开辟到堆中，自己设定进程大小。在这个代码中就不演示了想要加的话可以在写一个判断设置线程空间大小，单纯图一乐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> fsize = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tnums = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* fmw = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* fmr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fileCopy</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> len = fsize/tnums;  </span><br><span class="line">    <span class="keyword">if</span>(i &lt; tnums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == tnums<span class="number">-1</span>)&#123;</span><br><span class="line">            memmove(fmw + (len*i), fmr + (len*i), len + (<span class="type">int</span>)(fsize%len));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            memmove(fmw + (len*i), fmr + (len*i), len);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">progressBar</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buff,<span class="string">&#x27;\0&#x27;</span>,<span class="number">40</span>);</span><br><span class="line">    <span class="type">char</span> label[] = <span class="string">&quot;\\/\\/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-39s][%c][%.lf%%]\r&quot;</span>,buff, label[i%<span class="number">4</span>], (i+<span class="number">1</span>)*<span class="number">2.5</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        buff[i] = <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">        usleep(<span class="number">50000</span>/tnums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;食用方法：源文件名，新文件名，使用的线程数\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fdr = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;源文件&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fdw =open(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fdw &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;目的文件&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">finfo</span>;</span></span><br><span class="line">    fstat(fdr,&amp;finfo);</span><br><span class="line">    fsize = finfo.st_size;</span><br><span class="line">    <span class="type">int</span> ret = ftruncate(fdw, fsize);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;truncate error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmr = mmap(<span class="literal">NULL</span>, fsize, PROT_READ, MAP_SHARED, fdr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fmr == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;目的文件映射&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdr);</span><br><span class="line">    fmw = mmap(<span class="literal">NULL</span>, fsize, PROT_WRITE, MAP_SHARED, fdw, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fmw == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;源文件映射&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fdw);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据线程数创建线程  </span></span><br><span class="line">    tnums = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span>(tnums &gt;= <span class="number">10000</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;你要复制什么玩意？确定要这么多进程数？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pthread_t</span> tid[tnums + <span class="number">1</span>];<span class="comment">//这里是之前测试回收是否成功的记录</span></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tnums; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i], &amp;attr, fileCopy, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid[tnums], &amp;attr, progressBar, (<span class="type">void</span> *)i);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;errno :%d: %s&quot;</span>, ret, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap(fmr, fsize);</span><br><span class="line">    munmap(fmw, fsize);  </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础04 | 信号</title>
      <link href="/2022/08/11/linuxsig/"/>
      <url>/2022/08/11/linuxsig/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><ul><li><p>摔杯为号</p></li><li><p>一只穿云箭，千军万马来相见</p></li></ul><p>从这里可以看出信号几个特性，简单，迅速，明显，有条件触发的，多种的</p><p>信号是信息的载体，linux 古老的经典的通信方式，主要的通信手段</p><p>早期的信号不是很可靠，POSIX.1对可靠信号例程进行了标准化</p><p>信号基于linux内核进程间通信，<strong>内核发送内核处理</strong></p><p>时钟中断基于硬件</p><p>信号早期相当于软中断</p><p>软中断与硬件中断相比实际上并不是很可靠</p><h3 id="信号的4要素"><a href="#信号的4要素" class="headerlink" title="信号的4要素"></a>信号的4要素</h3><ul><li>信号名</li><li>信号编号</li><li>信号默认处理动作<ul><li>term：终止进程</li><li>ign：忽略，子进程死亡，默认会向父进程发送这样的信号，让父进程保持运行，比如SIGHLD</li><li>Core：终止进程，GDB等调试的工具中比较常见</li><li>Stop：停止（暂停）进程</li><li>Cont：继续</li></ul></li><li>信号对应事件</li></ul><p>man 7 signal查看帮助文档</p><h2 id="信号的产生5种方式"><a href="#信号的产生5种方式" class="headerlink" title="信号的产生5种方式"></a>信号的产生5种方式</h2><p><strong>注意：这里讨论的是ARM/X86的系统内核下的信号编号</strong></p><ul><li>按键产生<ul><li>Ctrl+c 产生SIG INT(2)终止/中断（interrupt）</li><li>Ctrl+z 产生SIG T STP(20)终端暂停</li><li>Ctrl+\ 产生SIGQUIT(3)退出</li></ul></li><li>系统调用<ul><li>kill，raise，</li></ul></li><li>软件条件<ul><li>定时器alarm</li></ul></li><li>硬件异常<ul><li>内存非法访问 SIGSEGV（11）段错误</li><li>除零 SIGFPE(8) 浮点数例外</li><li>总线 SIGBUS（7）总线错误</li></ul></li><li>命令产生<ul><li>kill命令 默认信号是11（终止进程）</li></ul></li></ul><h3 id="信号状态"><a href="#信号状态" class="headerlink" title="信号状态"></a>信号状态</h3><h4 id="递达态"><a href="#递达态" class="headerlink" title="递达态"></a>递达态</h4><p>信号产生后，内核会立刻递送，并到达，速度相当于光速，可以认为是瞬时的；</p><h4 id="阻塞态（屏蔽）（未决）"><a href="#阻塞态（屏蔽）（未决）" class="headerlink" title="阻塞态（屏蔽）（未决）"></a>阻塞态（屏蔽）（未决）</h4><p>信号产生后不可递达目的地接收时的状态</p><p>记录着信号状态的是位于进程控制块PCB中的</p><ul><li>阻塞信号集（信号屏蔽字）</li></ul><ul><li>未决信号集<ul><li>没有进行处理的信号集合</li></ul></li></ul><p>在产生信号的前提下，阻塞信号集影响未决信号集</p><h3 id="信号的3种处理方式"><a href="#信号的3种处理方式" class="headerlink" title="信号的3种处理方式"></a>信号的3种处理方式</h3><ul><li>执行信号的默认动作</li><li><del>草，走</del>，忽略（丢弃）</li><li>捕捉（调用户的处理函数）</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当出现信号都被屏蔽，捕捉或者忽略，唯一不会被阻塞的忽略的捕捉的两个信号</p><ul><li>SIGKILL（9）<ul><li>杀死进程 </li></ul></li><li>SIGSTOP（19）<ul><li>停止进程</li></ul></li></ul><h3 id="常见信号产生函数"><a href="#常见信号产生函数" class="headerlink" title="常见信号产生函数"></a>常见信号产生函数</h3><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><strong>注意kill函数其实并不是真的杀死进程，需要根据你选择发送的信号决定</strong></p><p>很简单看 man 文档就能知道了，这里直接上示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = kill(pid, SIGKILL);</span><br></pre></td></tr></table></figure><p>pid有四个特殊值：</p><ul><li>0 同一个进程组的所有进程</li><li>>0指定进程</li><li>\&lt;0 指定进程组</li><li>-1表示可发送的（权限）所有进程</li></ul><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>作用给当前进程发送一个信号（给自己发）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = raise(SIGSTOP);</span><br></pre></td></tr></table></figure><h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>作用就是自己给自己发一个异常信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abort</span>();</span><br></pre></td></tr></table></figure><h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h3><h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>设置一个定时器，设定内核指定时间发送一个SIGALRM（14）信号</p><p>每个进程只有一个定时器</p><p>自然定时法，与进程的状态无关</p><p>返回值比较有意思，返回的是上一次调用距离当前调用的时间差</p><p>测试我的计算机一秒能数多少个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//计算我的计算机一秒能执行多少次++的操作</span></span><br><span class="line">    <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld \n&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现我的一秒只能执行140615次打印和++操作，<del>确实挺拉的</del></p><p>如果将打印操作重定向out中，可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat out | awk &#x27;END &#123;print&#125;&#x27;</span><br></pre></td></tr></table></figure><p>发现执行10590892了次++</p><p>可以发现IO极大的拖慢执行效率</p><p>实际执行时间 = 系统时间 + 用户时间 +等待时间 （等硬件资源，系统资源）</p><p>可以用 time 看出具体的系统时间和用户时间</p><h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h4><p>功能比timer更好更全，所以普遍使用该函数作为定时器</p><ul><li>可指定的三种计时方式<ul><li>TIMER_REAL自然定时 发送的信号SIGALRM</li><li>TIMER_VIRTUAL虚拟空间计时（用户空间）发送的信号 SIGVTALRM</li><li>ITIMER_PROF运行时计时（用户+内核）发送的信号SIGPROF</li><li><strong>注意三种定时器信号意味着一个进程中可以同时设置三种不同类型的定时器</strong></li></ul></li><li>可以指定精度微秒，可循环的定时器</li></ul><p>通过代码进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">my_alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sec)</span>&#123;</span><br><span class="line">    <span class="comment">//定义存储定时器的数据的结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    it.it_value.tv_sec = sec;<span class="comment">//秒</span></span><br><span class="line">    it.it_value.tv_usec = <span class="number">0</span>;<span class="comment">//微秒</span></span><br><span class="line">    <span class="comment">//下一次的定时定时器的时间</span></span><br><span class="line">    <span class="comment">//设置为0说明没有下一次定时器，只有一个</span></span><br><span class="line">    it.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">    it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个参数是选择计时类型，第二个是传入定时器的数据，第三个是传出参数，接收的是上一个定时器的间隔时间差</span></span><br><span class="line">    <span class="comment">//有了计时类型就同时设定三种不同类型的定时器</span></span><br><span class="line">    ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldit.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    my_alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(; ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要实现一个循环的定时器(周期定时)代码实现如下</p><p>具体：实现一个循环1秒发送SIGALRM信号的定时器，和一个0.5s的发送SIGTVALRM信号的定时器。信号调用用户自定义的行为：显示抓取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigroutine</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (signo)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SIGALRM:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Catch a signal - SIGALRM\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SIGVTALRM:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Catch a signal - SIGTVALRM\n&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sec, <span class="type">unsigned</span> <span class="type">int</span> usec, <span class="type">int</span> timetype )</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    it.it_value.tv_sec = sec;</span><br><span class="line">    it.it_value.tv_usec = usec;</span><br><span class="line">    </span><br><span class="line">    it.it_interval.tv_sec = sec;</span><br><span class="line">    it.it_interval.tv_usec = usec;</span><br><span class="line">    <span class="type">int</span> type = timetype;</span><br><span class="line">    ret = setitimer(type, &amp;it, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    signal(SIGALRM, sigroutine);</span><br><span class="line">    signal(SIGVTALRM, sigroutine);</span><br><span class="line">    my_alarm(<span class="number">1</span>, <span class="number">0</span>, ITIMER_REAL);</span><br><span class="line">    my_alarm(<span class="number">0</span>, <span class="number">500000</span>, ITIMER_VIRTUAL);</span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++的写法可以使用lambda函数写捕获能精简自定义响应函数部分</p><h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p>对未决信号集和阻塞信号集的操作</p><h4 id="信号集的设定"><a href="#信号集的设定" class="headerlink" title="信号集的设定"></a>信号集的设定</h4><p>本质上是一个集合，一个无序不重复的数组，类似C++的set容器，在c库types.h中定义了一个sigset_t，用来存放信号集合</p><p>提供了5个函数对该sigset_t进行操作 </p><ul><li>sigemptyset(sigset_t* set) ; 将信号集清0  </li><li>sigfillset(sigset_t* set ); 将信号集设置为1  </li><li>sigaddset(sigset_t* set, int signum);将某一个信号加入集合当中，信号编号对应值设置为1</li><li>sigdelset(sigset_t* set, int signum);将某一个信号删除。将编号对应值设置为0</li><li>sigismember(sigset_t* set, int signum):取信号在该信号集的对应的值</li></ul><p>实际上未决信号集屏蔽信号集都在pcb中，用户函数是无法直接对其进行位操作，正常也不会</p><h4 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask()"></a>sigpromask()</h4><p>我们需要使用一个函数对将我们自定义的集合设置到屏蔽信号集中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = sigprocmask(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>,  <span class="type">sigset_t</span>* oldset)</span><br></pre></td></tr></table></figure><p>需要注意的是，屏蔽实际上只是暂缓信号，直到解除屏蔽</p><ul><li>SIG_BLOCK 表示需要屏蔽的信号 mask = mask | set</li><li>SIG_UNBLOCK 表示需要解除屏蔽的信号， mask = mask&amp; ~set</li><li>SIG_SETMASK 表示set用于替代原始屏蔽集的新屏蔽集 mask = set</li></ul><h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending()"></a>sigpending()</h4><p>读取当前进程的未决信号集</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span>* <span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><p>程序示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPending</span><span class="params">(<span class="type">sigset_t</span>* pend)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">33</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(pend,i))&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> myset, oldset, pend;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;myset, SIGTSTP);</span><br><span class="line">    sigaddset(&amp;myset, SIGINT);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;myset, &amp;oldset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sigpending(&amp;pend);</span><br><span class="line">        printPending(&amp;pend);</span><br><span class="line">        sleep(<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>注册一个内核信号捕捉的行为 </p><p>类似qt信号槽，前端插件开发中的hooks钩子</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__sighandler_t</span>  handler= signal(SIG, handler);</span><br><span class="line"><span class="keyword">if</span>(handler == SIG_ERR)&#123;</span><br><span class="line">    perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意返回的值是一个函数指针，指向的其实就是handler这个函数</p><p>由此可见这是一个典型的callback函数</p><h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>作用比signal更强。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br></pre></td></tr></table></figure><p>先来看看这个结构体又是什么构造,看看man文档</p><ul><li><p>sa_sigaction </p><ul><li>扩展信号响应函数指针</li></ul></li><li><p>sigset_t  sa_mask</p><ul><li>使用sa_mask 进行信号的临时屏蔽阻塞<ul><li>一般用于捕捉函数需要运行中收到同一个或者其他信号时，保证捕捉响应函数处理结束</li><li>仅在捕捉响应函数执行期间生效</li></ul></li></ul></li><li><p>int sa_flag</p><ul><li>标志位</li><li>0 采用默认的属性，在信号捕捉函数执行期间自动屏蔽本信号</li><li>SA_NOCLDSTOP 子进程暂停时不提醒</li><li>SA_NOCLDWAIT 子进程死亡不回收</li><li>SA_NODEFER 不屏蔽信号响应函数中的信号</li><li>SA_ONSTACK 信号响应函数在替补栈中分配内存</li><li>SA_RESETHAND 响应函数执行一遍重置信号响应策略（只执行一次）</li><li>SA_RESTART 自动重启被该信号中断的某些系统调用</li><li>SA_SIGINFO 使用扩展信号响应函数而不是标准响应函数</li></ul></li><li><p>viod* (sa_handler)(int);</p><ul><li>阔号代表两个可用类型</li><li>实际上就是捕捉函数的函数指针</li></ul></li></ul><p>多说无益代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">docatch</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d signal is caught\n&quot;</span>, signo);</span><br><span class="line">    <span class="comment">//sleep(10);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">   <span class="comment">// sigaddset(&amp;act.sa_mask, SIGQUIT);</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要注意的特性"><a href="#需要注意的特性" class="headerlink" title="需要注意的特性"></a>需要注意的特性</h4><ul><li><p>PCB中的信号屏蔽集mask和函数提供的sa_mask，在响应函数运行期间sa_mask最优</p></li><li><p>当出现多个同一个信号被屏蔽阻塞，解除屏蔽后，只会处理一次信号，不户籍进行排队</p></li></ul><h2 id="内核捕捉信号过程"><a href="#内核捕捉信号过程" class="headerlink" title="内核捕捉信号过程"></a>内核捕捉信号过程</h2><ol><li>执行主控制流程的某条指令时因为中断或者异常系统调用进入内核</li><li>内核处理完异常准备回用户模式之前，先处理当前进程中可以递送的信号</li><li>如果信号的处理动作 是自定义的信号处理函数，则回到用户模式执行信号处理函数（而不是回到主控制流程）</li><li>信号处理函数返回时执行特殊的系统调用sigreturn 再次进入内核</li><li>在内核中,在返回用户模式，从主控制流程中上次被中断的地方继续向下执行</li></ol><p><del>图,改日再画</del></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础02 | 程序和进程第一节</title>
      <link href="/2022/08/10/linux02/"/>
      <url>/2022/08/10/linux02/</url>
      
        <content type="html"><![CDATA[<h1 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h1><p>程序是二进制文件，在磁盘上，不占用系统资源（CPU，内存，打开的文件，设备，锁….)</p><p>进程,比较抽象的概念，活跃的程序，占用系统资源</p><p>可以通俗理解为：程序是剧本，进程是上演的戏剧</p><h2 id="需要知道的前置知识"><a href="#需要知道的前置知识" class="headerlink" title="需要知道的前置知识"></a>需要知道的前置知识</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>单道程序设计：DOS系统，程序只能排队占用CPU执行，</p><p>多道程序设计：想要实现多开进程，而CPU如果只有一个，需要划分时间分片设置一个时间中断，硬件手段，给打开的多个程序时间中断，给进程们进行分配CPU的使用时限，由于CPU计算相当快，人眼看不到停止轮次，就会认为是并行运行，实际上是并发</p><h3 id="CPU和MMU"><a href="#CPU和MMU" class="headerlink" title="CPU和MMU"></a>CPU和MMU</h3><p>CPU：硅，<del>去沙滩抓把沙子做一做就弄明白了</del><br>请移步机组文章</p><p>这里单独拿出MMU</p><h4 id="MMU基本工作原理"><a href="#MMU基本工作原理" class="headerlink" title="MMU基本工作原理"></a>MMU基本工作原理</h4><p>MMU是一个内存管理单元，在CPU中</p><p>虚拟内存只是个概念，需要MMU将虚拟内存的虚拟地址映射在对应的物理地址上。除了映射功能，还能设置内存访问的级别，一般英特尔cpu设定的内存访问级别都有四个级别</p><p>linux只使用了3级与0级两种级别</p><p>0级的内核空间，3级就是用户空间</p><p>在运行的两个进程，即使程序相同，但是用户区的映射的不是同一块的物理进程，内核区指向的物理内存实在同一块，但是PCB是不一样的，具体还是请移步机组文章</p><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>进程描述符（linux系统下的通用称呼)</p><p>PCB本质是一个结构体组</p><p>结构体成员</p><ul><li>进程id，系统中每个进程有唯一的id,</li><li>进程的状态<ol><li>初始化</li><li>就绪：等待CPU分配时间片</li><li>运行</li><li>挂起：等待除了CPU以外的其他资源，主动放弃CPU，可以理解为阻塞状态</li><li>终止</li></ol></li><li>进程切换时需要进行保存的和恢复的一些CPU资源和寄存器的值。</li><li>描述虚拟地址空间的信息<ul><li>MMU维护这一个虚拟地址映射到物理地址的表</li></ul></li><li>描述控制终端的信息<ul><li>运行该进程的终端信息呗</li></ul></li><li>当前工作目录<ul><li>当前进程的工作目录，具体请看chdir函数</li></ul></li><li>umask掩码<ul><li>文件的保护控制权限用</li></ul></li><li>文件描述符表<ul><li>包含很多指向文件结构体的指针,就是fd，</li></ul></li><li>信号相关的信息</li><li>用户id和组id</li><li>会话（Session）和进程组</li><li>进程可以使用的资源上限（Resource Limit)<ul><li>使用ulimit -a命令查看linux中的所有的进程组使用的资源上限</li></ul></li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>linux是什么系统，多用户多任务的开源操作系统</p><p>每个用户的配置都不一样，每个人都有不同的启动桌面，不同的默认工具设置，等等，实际上就是环境变量不一样</p><p>我们所常见的全局环境变量，用户环境变量可以这么理解</p><p>几个常用环境变量</p><ul><li>PATH：二进制的执行文件路径</li><li>SHELL：当前的命令解析器</li><li>LANG：当前的语言</li></ul><p>环境变量的打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个环境变量的函数</p><ul><li>setenv()</li><li>getenv()</li><li>clearenv()</li></ul><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* val;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1,%s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line">    setenv(name, <span class="string">&quot;自定义一个环境变量&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2,%s = %s\n&quot;</span>, name, val); </span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="type">int</span> ret = unsetenv(<span class="string">&quot;ABCDE&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret: %d\n&quot;</span>, ret);</span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3,%s = %s\n&quot;</span>, name, val);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    <span class="type">int</span> ret = unsetenv(<span class="string">&quot;ABCDE&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret: %d\n&quot;</span>, ret);</span><br><span class="line">    val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3,%s = %s\n&quot;</span>, name, val); </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>fork函数</p><p>通过函数fork创建一个子进程</p><p>fork函数有两个返回值，一个是是子进程的id,一个是flag（是创建进程成功）</p><p>父进程的fork返回的是子进程的id，子进程fork返回的是flag</p><p>创建一个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程测试&quot;</span>);</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">       _exit(<span class="number">1</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程,pid= %u,我的父进程的 ppid= %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主进程,pid= %u,我的父进程的 ppid= %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主进程睡眠1秒保证子进程先运行一会</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;测试子进程会不会也执行\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环创建五个子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程测试\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="comment">//第一个进程睡眠一秒依次类推</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子进程,pid是：%u, 父进程ppid是：%u\n&quot;</span>, i+<span class="number">1</span>, getpid(),getppid());   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主进程结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>以上所有的进程实际上都在同时争夺CPU，需要做进程状态的控制才能保证到底是哪个进程先使用CPU</p><p>如果将所有的sleep休眠函数都删除，那么结果其实也是一样的，只是显示上有问题</p><h4 id="父子进程的异同"><a href="#父子进程的异同" class="headerlink" title="父子进程的异同"></a>父子进程的异同</h4><p>主要是值的相同</p><p>相同：</p><ul><li>全局变量，</li><li>.data</li><li>.text</li><li>栈</li><li>堆</li><li>环境变量</li><li>用户ID</li><li>宿主目录</li><li>进程工作目录</li><li>信号处理方式等</li></ul><p>不同</p><ul><li>进程ID</li><li>fork返回值</li><li>父进程ID</li><li>进程运行时间</li><li>定时器</li><li>未决信号集</li></ul><p>父子进程间遵循</p><p><strong>读时共享，写时复制</strong></p><p>共享的</p><ol><li>文件描述符</li><li>mmap建立的映射区</li></ol><h4 id="父子进程的调试"><a href="#父子进程的调试" class="headerlink" title="父子进程的调试"></a>父子进程的调试</h4><p>gdb调试默认父进程</p><p>在调用子进程函数之前<br>设置跟踪子进程，就可以走子进程的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child</span><br></pre></td></tr></table></figure><p>如果有多个子进程，那就需要设置好条件断点，通过进程的索引值比如你设定的id，或者直接使用pid判断来进入不同的子进程</p><h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p>除了子父进程，子进程还可以执行别的程序</p><p>换核不换壳，pid ppid都不变，改变的其实是代码区和等等。</p><p>利用的是exec函数族</p><h4 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h4><p>exec函数族之一的函数</p><p>l  代表的是list(具体可以理解为就是指令参数0~n),而p 表示的是PATH环境变量</p><p>利用execlp函数实现子进程执行 环境变量中指定的地址二进制文件ls文件，打印当前的进程的目录下的文件<br>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这里是父进程&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解析一下execlp的使用：</p><p>第一个参数表示的是执行的是ls这个文件</p><p>第二个参数表示argv[0],第三个就是argv[1]依次类推</p><p>直到选项参数结束为NULL</p><p>假设我们要执行我们自己的程序</p><p>可以使用execl （不用指定环境变量）</p><p>除了以上的execlp和execl</p><p>还有execv和execvp, execvpe, execle</p><p>参数：</p><ul><li>l(list) 参数列表</li><li>p(path) 参数的环境变量path</li><li>v(vector) 参数的数组</li><li>e(environment) 参数的所有的环境变量<ul><li>在使用e时，需要先导入环境变量表extren </li></ul></li></ul><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p><del>没爹没妈的进程</del></p><p>没有父进程回收，系统会将其父进程设置为init进程，<del>可以理解为孤儿院领养了</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让父进程先死，后子进程打印ID，打印的父进程ID是init进程ID</span><br></pre></td></tr></table></figure><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>父进程忘记给子进程结束后收尸了</p><p>子进程会残留在PCB中，成为僵尸进程，kill无法终止</p><p>代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，pid: %u,父进程ppid: %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程：啊，我死了\n&quot;</span>);   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">        <span class="comment">//主进程</span></span><br><span class="line">        <span class="comment">//循环运行没有给结束的子进程进行收尸</span></span><br><span class="line">        <span class="comment">//循环打印</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，pid: %u,我的子进程ppid: %u\n&quot;</span>, getpid(), pid);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;主进程发呆中呀~\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在终端查看进程可以看见</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220808141216762.png" alt=""></p><p>看见一个状态为Z+ 进程名字使用中括号括起（一般买书的时候发现作者名字被中括号扩起说明作者已经过世了）<br>那么该怎么将上面这两种子进程回收呢</p><p>我们需要使用以下函数</p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><ul><li><p>阻塞主进程，等待子进程退出，然后回收</p></li><li><p>获取子进程的结束状态</p><p>根据wait的传出参数是一个整形数int* status，该怎么得知对应状态呢？</p><p>需要系统提供的宏函数来进一步判断进程终止的具体原因，重点掌握</p><ul><li>正常结束：</li><li>WIFEXITED(status) 为非0    进程正常结束</li><li>WEXITSATUS(status) 如果是进程正常结束，返回进程的退出的值</li><li>异常结束：</li><li>WIFSIGNALED(status) 为非0    进程异常结束</li><li>WTERMSIG(status) 如果进程异常结束，返回收到的是第几种信号造成的 结束<ul><li>kill默认15号信号杀死进程</li><li>我们常见的访问不可访问的内存空间会返回的是11号信号，表示的是段错误信号</li></ul></li></ul></li></ul><p><strong>代码示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">__pid_t</span> pid;</span><br><span class="line">    <span class="type">__pid_t</span> wpid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        execl(<span class="string">&quot;02app&quot;</span>, <span class="string">&quot;02app&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程，pid: %u,父进程ppid: %u\n&quot;</span>, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程：我死了\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">121</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，pid: %u,我的子进程ppid: %u\n&quot;</span>, getpid(), pid);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            wpid = wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;正常关闭，关闭的返回值为:%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;异常关闭，受到的是信号为 %d 号\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响"><a href="#实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响" class="headerlink" title="实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响"></a>实际上可以这么说，几乎所有进程的异常终止，都是收到信号的影响</h4><p>问题来了</p><p>一次wait函数调用能回收几个子进程？<strong>一个</strong>,想要回收多个子进程，需要多次调用</p><p>但是自动默认选择的是先结束的子进程。</p><p>显然这是有些局限的，不能指定回收哪一个子进程</p><p>问题解决：</p><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h4><p>作用与wait大体相同，不同点，也是关键点</p><ul><li><p>可以选择不阻塞主进程，使用轮询方式判断子进程是否结束，需要设置第三个参数为WNOHANG（wait not hang)主进程不挂起</p><p>回收指定的子进程并且不挂起主进程代码示例：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">__pid_t</span> pid, wpid;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="type">__pid_t</span> wpid3;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            wpid3 = pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; count)&#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子进程,我的pid是: %u,我的父进程id是: %u\n&quot;</span>, i+<span class="number">1</span>, getpid(), getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            wpid = waitpid(wpid3, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (wpid != wpid3);<span class="comment">//当没有子进程回收跳出轮询</span></span><br><span class="line">        <span class="comment">//这里有一个BUG，会极大的占用cpu资源，在下方的代码有修正</span></span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第三个进程结束成功回收\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;所有进程都回收成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要回收所有的子进程并且不挂起，将waitpid的第一个参数和跳出轮询的判断设置为 -1（-1表示没有一个进程需要回收，如果收成功，返回的是回收成功的pid）</p><p>第一个参数有四个特殊的值</p><ul><li>大于0，表示回收指定的PID的进程</li><li>0 ，回收本组的任意一个子进程</li><li>-1，表示回收任意一个子进程，等价于 wait(NULL)；</li><li>小于-1的值，表示回收指定的进程组GPID的任意子进程</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>假设需要定义一个进程任务，任务内容要求主进程有三个子进程</p><p>第一个子进程实现ps_dup2，第二个子进程实现自定义的程序，第三个出段信号引发错误的程序。</p><p>最后主进程再不结束运行的情况下对所有进程进行回收</p><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">w1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;ps.out&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">121</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd, STDOUT_FILENO);</span><br><span class="line">    execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程2&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;w2&quot;</span>, <span class="string">&quot;w2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">w3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程3&quot;</span>);</span><br><span class="line">    execl(<span class="string">&quot;w3&quot;</span>, <span class="string">&quot;w3&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">3</span>;</span><br><span class="line">    <span class="type">pid_t</span> w3pid;<span class="comment">//第三个进程</span></span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;<span class="comment">//设定一个轮询次数，否则极大浪费cpu资源</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            w3pid = pid;</span><br><span class="line">            <span class="comment">//记录测试用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            w1();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            w2();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">            w3();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;轮询次数为：%d\n&quot;</span>, n);</span><br><span class="line">            <span class="comment">//回收所有的子进程</span></span><br><span class="line">            <span class="comment">//轮询方式,不挂起主程序</span></span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">               wpid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG); </span><br><span class="line">               <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                n--;</span><br><span class="line">               <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回收值：%d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;异常信号为：%d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;   </span><br><span class="line">            &#125;<span class="keyword">while</span>(wpid != <span class="number">-1</span> || n &gt; <span class="number">0</span> );</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主程序时间已过，再次自动回收所有的子进程\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;轮询次数为：%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux小作业 | 多进程拷贝</title>
      <link href="/2022/08/10/linuxwork01/"/>
      <url>/2022/08/10/linuxwork01/</url>
      
        <content type="html"><![CDATA[<h1 id="小作业01：多进程拷贝"><a href="#小作业01：多进程拷贝" class="headerlink" title="小作业01：多进程拷贝"></a>小作业01：多进程拷贝</h1><p>作业要求：实现多进程分段拷贝文件，可指定拷贝的文件的路径，和拷贝使用的进程数，</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>系统函数有：</p><ul><li>fork<ul><li>进程创建</li></ul></li><li>waitpid<ul><li>子进程死亡回收</li></ul></li><li>stat<ul><li>获取文件大小</li></ul></li><li>open<ul><li>打开文件</li></ul></li><li>mmap<ul><li>内存映射</li></ul></li></ul><h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><p>也算不上什么难点，只不过需要对每个进程所需要的写入的片段字节大小和和偏移量思考一下,其余的无非就是细节上的问题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./mcp rfilepath wfilepath n\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程数为 %d\n&quot;</span>, n);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程数默认为 %d\n&quot;</span>, n);</span><br><span class="line">        n = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_r = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd_r == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;read init error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fr</span>;</span>  </span><br><span class="line">    fstat(fd_r,&amp;fr);</span><br><span class="line">    <span class="type">size_t</span> size = fr.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd_w = open(argv[<span class="number">2</span>], O_RDWR | O_CREAT |O_TRUNC, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd_w == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;write init error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓宽写文件</span></span><br><span class="line">    ftruncate(fd_w, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对读文件进行mmap</span></span><br><span class="line">    <span class="type">char</span>* mm_r = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd_r, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm_r == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap readfile error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd_r);</span><br><span class="line">    <span class="comment">//对写文件进行mmap</span></span><br><span class="line">    <span class="type">char</span>* mm_w = mmap(<span class="literal">NULL</span>, size, PROT_READ| PROT_WRITE, MAP_SHARED, fd_w, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mm_w == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap writefile error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd_w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据所选进程数求出字节数和进程数</span></span><br><span class="line">    <span class="type">int</span> len = size/n;</span><br><span class="line">    <span class="comment">//最后一个进程需要处理的子节数</span></span><br><span class="line">    <span class="type">int</span> len_end = len + (size%len);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid ,wpid;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span>(i &lt; n<span class="number">-1</span> || n == <span class="number">1</span> &amp;&amp; pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//前倒数第一个子进程们</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 个子进程 ,偏移的数据长度为 %u 字节, 复制了%u字节\n&quot;</span>, i+<span class="number">1</span>, len*i, len);</span><br><span class="line">         memmove(mm_w+(len*i), mm_r+(len*i), len);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//倒数第一个子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最后一个子进程, 偏移的数据长度为 %u 字节，复制了%u字节\n&quot;</span>, len*i, len_end);</span><br><span class="line">         memmove(mm_w+(i*len), mm_r+(i*len), len_end);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//主进程//进行回收</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">           wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">           <span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(wpid !=<span class="number">-1</span> || n &gt; <span class="number">0</span> );</span><br><span class="line">        munmap(mm_r, size);</span><br><span class="line">        munmap(mm_w, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node项目需要注意的</title>
      <link href="/2022/08/02/nodetip/"/>
      <url>/2022/08/02/nodetip/</url>
      
        <content type="html"><![CDATA[<h3 id="Node项目需要注意的"><a href="#Node项目需要注意的" class="headerlink" title="Node项目需要注意的"></a>Node项目需要注意的</h3><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>NPM的第三方的包过大时</p><p>将node_modules文件夹，添加到.gitgnore的忽略文件中</p><p>只需要创建一个package.json<br>在项目文件夹下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>自动将依赖的第三方包记录在package.json中</p><p>注意：执行该命令时项目不能有中文和空格</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>git clone一个项目后，</p><p>需要执行该项目先前执行依赖包的下载操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line"><span class="comment">#npm install</span></span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 指定的包名</span><br></pre></td></tr></table></figure><h3 id="需要了解"><a href="#需要了解" class="headerlink" title="需要了解"></a>需要了解</h3><p>包的项目上线之后如果不会用到，将包安装时的指令添加选项-D</p><p>例如安装webpack</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack -D </span><br></pre></td></tr></table></figure><p>该包就会放入开发阶段的结点中</p><p>devDependencies(开发依赖包)</p><p>如果上线和开发都需要使用</p><p>默认的安装包的方式就好</p><p>默认的结点</p><p>Dependencies（核心依赖包）</p><p>第三方包的使用具体查看www.npmjs.com查阅文档</p><p>当然也可以直接去寻找REAMD.md文档</p><h3 id="下包速度的提升"><a href="#下包速度的提升" class="headerlink" title="下包速度的提升"></a>下包速度的提升</h3><p>更换镜像源</p><ul><li>linux 下在家目录下的.npmrc文件添加这一行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><ul><li><p>windows</p><p>执行这一条指令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>通过指令查看当前配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><p>你问为什么不用淘宝镜像源？具体请访问<a href="https://npmmirror.com/">https://npmmirror.com/</a></p><h4 id="简单的自定义包的开发"><a href="#简单的自定义包的开发" class="headerlink" title="简单的自定义包的开发"></a>简单的自定义包的开发</h4><p>一个项目文件夹</p><p>package.json 包的信息</p><p>index.js：包的主体</p><p>README.md： 相关功能介绍说明文档</p><p>当然package.json可以在写好主体的所有部分最后在使用命令生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>比如自定义一个简单的第三方包作为例子</p><p>功能：转义HTML字符，防止简单的XXS攻击.再重新还原返回</p><p>主体文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">htmlstr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> htmlstr.<span class="title function_">replace</span>(<span class="regexp">/&lt;|&gt;|&quot;|&amp;/g</span>,<span class="function">(<span class="params">match</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;it;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;quot;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;amp;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">htmlUnEscape</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/&amp;it;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>,<span class="function">(<span class="params">match</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (match)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;it;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;quot;&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&amp;amp;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;&amp;;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    htmlEscape,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后在该项目文件夹执行npm包初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>得到的package.json内容修改如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;htmlescape&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;转义HTML字符，防止XXS攻击.再重新还原返回&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;htmlEscape.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;html&quot;</span><span class="punctuation">,</span><span class="string">&quot;escape&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;icrad&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再写个使用介绍文档就完成一个简单的包</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode|水果成篮|简单C++实现</title>
      <link href="/2022/07/31/shuiguochenglan/"/>
      <url>/2022/07/31/shuiguochenglan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没做题了，久违的简单题，却没想到花了我一个小时<del>我是一个一个一个究极菜狗啊啊</del>，好久没做，思路都不清晰了，特记该文章边做题边理清思路</p><span id="more"></span><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><pre><code>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</code></pre><p>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p><p>来源：力扣（LeetCode）<a href="https://leetcode.cn/problems/fruit-into-baskets">水果篮子</a><br>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>滑动窗口，也就是双指针</p><p>给了数组，需要返回子数组最大符合长度</p><h4 id="确定变量"><a href="#确定变量" class="headerlink" title="确定变量"></a>确定变量</h4><p>快指针：int fast=0</p><p>慢指针：int slow=0    </p><p>由题目可知：</p><p>明确判断点：是否满足一个最大数组长度 与 篮子存放的两种苹果种类的异同</p><p>需要记录两种苹果变量（动态的）</p><p>第一种：int first=0</p><p>第二种：int second=0</p><p>给出了果树的数组fruits</p><p>第一种类与慢指针绑定</p><p>第二种类与快指针绑定</p><p>first=fruits[fast];</p><p>second=fruits[slow];</p><p>最长数组计算:</p><p>fast-slow+1</p><p>需要返回的最大数组定义</p><p>int length=0;</p><h4 id="列出情况"><a href="#列出情况" class="headerlink" title="列出情况"></a>列出情况</h4><ol><li>快指针指向的果树等于第一种</li><li>快指针指向的果树等于第二种</li><li>快指针指向的果树没有一种相等</li></ol><p>三种情况，实际上是两种处理方式</p><p>1与2的可以合并一种情况处理，有一个条件满足即可:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fruits[fast]) == first || fruits[fast] == second)&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//更新返回长度</span></span><br><span class="line">   length = <span class="built_in">max</span>(fast-slow+<span class="number">1</span>, length)</span><br><span class="line">     fast++;<span class="comment">//快指针加一，慢指针不动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他（就是出现情况三）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//更新摘取果树顺序</span></span><br><span class="line">    slow=fast<span class="number">-1</span>;<span class="comment">//slow回退fast一格,此时的快指针指向的值一定不等于slow的指向</span></span><br><span class="line">    second=fruits[slow];<span class="comment">//将该值的给第二种果树篮子</span></span><br><span class="line">    frist=fruits[fast];<span class="comment">//当前指向的值给第一种果树篮子</span></span><br><span class="line">    <span class="comment">//前方每有一个与第二种种类相同的果树，慢指针回退一个</span></span><br><span class="line">    <span class="comment">//避免slow=-1 再加上条件</span></span><br><span class="line"><span class="keyword">while</span>(fruits[slow<span class="number">-1</span>] == second &amp;&amp; slow &gt;= <span class="number">1</span> )slow--;</span><br><span class="line">    <span class="comment">//更新返回长度</span></span><br><span class="line">   length = <span class="built_in">max</span>(fast-slow+<span class="number">1</span>, length);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> first = fruits[fast];</span><br><span class="line">        <span class="type">int</span> second = fruits[slow];</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; fruits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(fruits[fast] == first || fruits[fast] == second)&#123;</span><br><span class="line">                length = <span class="built_in">max</span>(fast - slow + <span class="number">1</span>, length);</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow = fast - <span class="number">1</span>;</span><br><span class="line">                second = fruits[slow];</span><br><span class="line">                first = fruits[fast];</span><br><span class="line">                <span class="keyword">while</span>(slow &gt;= <span class="number">1</span> &amp;&amp; fruits[slow - <span class="number">1</span>] == second) slow--;</span><br><span class="line">                length = <span class="built_in">max</span>(fast - slow + <span class="number">1</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>别看有两个while时间复杂度实际上是$O(n)$，时间复杂度主要还是看操作次数。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 基础，C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第六节|计网最高层</title>
      <link href="/2022/07/30/internet06/"/>
      <url>/2022/07/30/internet06/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>同学们，达到计网最高层了嗷</p><span id="more"></span><h2 id="应用层的两种方式"><a href="#应用层的两种方式" class="headerlink" title="应用层的两种方式"></a>应用层的两种方式</h2><h3 id="P2P方式"><a href="#P2P方式" class="headerlink" title="P2P方式"></a>P2P方式</h3><ul><li>对等方式，没有固定的服务请求者和服务提供者</li><li>服务分散型</li><li>可扩展性，系统新能不会因为规模的增大而降低</li><li>具有成本上的优势</li></ul><h3 id="c-s客户服务器方式"><a href="#c-s客户服务器方式" class="headerlink" title="c/s客户服务器方式"></a>c/s客户服务器方式</h3><ul><li><p>有明确的服务请求方，和服务提供方</p></li><li><p>服务器总是处于运行状态，等待客户的服务请求</p></li><li><p>服务集中型的</p></li><li><p>尝会出现服务器计算机跟不上众多客户机的请求情况</p></li><li><p>常用计算机群集，或者服务器场，构建一个强大的虚拟服务器</p></li></ul><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><p>DHCP作为应用层协议，使用的是客户/服务器方式，使用UDP提供的服务</p><p>作用是：动态的分配网络配置，不需要手动操作配置主机</p><p>DHCP UDP 端口67 </p><p>DHCP客户 UDP 端口68 UDP用户数据报</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><ol><li>主机，也就是DHCP客户，启动DHCP客户进程，广播发送一个DHCP DISCOVER（dhcp discover)报文DHCP发现报文，该报文主要包含<ol><li>事务ID</li><li>MAC地址</li><li>原地址0.0.0.0</li></ol></li><li>DHCP服务器收到该广播地址，根据其MAC地址，查找数据库找对应配置信息，没有就默认发送广播报文：DHCP OFFER（dhcp offer）DHCP提供服务<ol><li>事务ID：判断是否自己请求的报文</li><li>源地址</li><li>配置信息<ol><li>IP地址：ARP协议判断IP地址没有被占用</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li></ol></li></ol></li><li>DHCP客户收到DHCP OFFER，转而广播一个DHCP REQUERST（dhcp request)，请求DCHP的服务确认<ol><li>事务ID</li><li>请求的地址租期</li><li>mac地址</li><li>等等</li></ol></li><li>DHCP服务器收到后根据事务ID嗯，OK也回复一个广播表示认可DHCP ACK报文</li><li>当DHCP客户收到这个DHCP报文后，先ARP检测自己分配到的地址是否已被占用，若果被占用，就恢复一个谢绝报文DHCP DECLINE 撤销IP地址足月，重新再发送DHCP DISCOVER</li></ol><p>至此，DHCP客户可以使用该网络配置接入互联网</p><p>接下来的就是续约操作和解约释放由下图所示</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730114325137.png" alt=""></p><p>DHCP服务器总不能啊每一个网络都整一个</p><p>然后就有了DHCP中继代理的概念</p><h4 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730114705398.png" alt=""></p><p>给一个网络的路由器配置DHCP服务器的IP地址，使该路由器成为DHCP与主机的桥梁.</p><h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>（Domain Name System）</p><p>域名更便于记忆</p><p>主机里也有个高速缓存寻找域名地址对应的IP地址</p><p>如果没有就想DNS请求解析</p><p>DNS基于UDP提供的服务 端口53</p><h4 id="因特网采用层次树状结构的域名结构"><a href="#因特网采用层次树状结构的域名结构" class="headerlink" title="因特网采用层次树状结构的域名结构"></a>因特网采用层次树状结构的域名结构</h4><p>最右是顶级域名</p><ul><li>国家顶级nTLD</li><li>通用顶级gTLD</li><li>反向域arpa</li></ul><p>我国将二级域名划分两类</p><ul><li>类别域名</li><li>行政区取名</li></ul><p>次级域名</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730122442883.png" alt=""></p><p>这四类都分布在世界各地，构成的服务器群集。</p><p>域名服务器四类</p><ul><li>根域名服务器<ul><li>最高层次的域名服务器，记录所有的顶级域名及其IP地址，Internet有13个不同IP地址的根域名服务器群集，通常不直接域名进行解析，而是返回该域名所属域名的顶级域名服务器的IP地址</li></ul></li><li>顶级域名服务器<ul><li>负责管理顶级域名服务器注册的所有二级域名，收到DNS查询请求，有可能直接返回ip地址，也有可能返回下一集权限域名服务器的IP地址</li></ul></li><li>权限域名服务器<ul><li>负责管理某个区的域名，每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道器管辖的域名与IP地址映射关系，同样的知道下级域名服务器的地址</li></ul></li><li>本地域名服务器<ul><li>不会超过几个路由器的距离</li></ul></li></ul><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730164846918.png" alt=""></p><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730164917730.png" alt=""></p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><ul><li>为了提高DNS的查询效率，减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛的使用了 <strong>高速 缓存</strong>，高水缓存用来存放查询过的域名以及从何出获得域名映射信息的记录</li><li>高速缓存在主机和服务器都有，其中存在的项目一般存在两天，设定一个新的合理的值</li></ul><h2 id="FTP文件传送协议"><a href="#FTP文件传送协议" class="headerlink" title="FTP文件传送协议"></a>FTP文件传送协议</h2><p>基于TCP协议的 文件传输 </p><p>传送控制命令的TCP连接监听端口号21，会话期间一致保持打开</p><p>用于传送数据的TCP连接端口号20，使用开启，结束关闭</p><h4 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><ul><li>主动模式</li></ul><p>客户随机的端口号与服务器的21端口建立连接，控制命令</p><p>刚客户端主命令请求，并告知一个随机端口号，FTP服务器收到后主动将20端口与客户端该随机端口号建立连接</p><ul><li>被动方式</li></ul><p>与主动连接稍微不同的是，客户端发送命令，服务器需要先开启某个临时端口被动等待客户端另一个临时的端口号进行TCP连接</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730171105202.png" alt=""></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="STMP与POP3协议"><a href="#STMP与POP3协议" class="headerlink" title="STMP与POP3协议"></a>STMP与POP3协议</h3><p>实际上就是邮件发送与邮件读取协议</p><h4 id="SMTP简单邮件传送协议"><a href="#SMTP简单邮件传送协议" class="headerlink" title="SMTP简单邮件传送协议"></a>SMTP简单邮件传送协议</h4><p>基于TCP协议 25端口号</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>跟实际的邮件没有什么区别，只不过道路换成了了网络中的各种信道，连通路，信件成了数据</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730175311749.png" alt=""></p><p>电子邮件的信息格式不是由SMTP定义的，而是在RFC 822中单独定义的，首部和主体两部分构成</p><p>只能传送ASCII文本数据</p><p>为了解决SMTP进行传送中文，图片等多种</p><p>因此提出了MIME</p><p>多用途因特网邮件扩展</p><p>（multipurpose internet mail extensions)</p><ul><li>增加了5个新的邮件首部字段，这些字段提供有关文件主体的信息。</li><li>定义了许多有邮件内容的格式，对多媒体电子邮件的表示进行了标准化</li><li>定义了传送编码，可对任何内容格式进行转换</li></ul><p>实际上就是将非ASCII的文本的数据，转换为ASCII在传送</p><p>接收方读取内容同时也是需要MIME进行解析。</p><p>MIME不仅用于SMTP，也通榆面向ASCII字符的HTTP</p><h2 id="常用的读取协议"><a href="#常用的读取协议" class="headerlink" title="常用的读取协议"></a>常用的读取协议</h2><h3 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h3><ul><li>邮局协议（Post office protocol),pop3是第三个版本</li><li>简单功能有限</li><li>只能下载并删除 或者 下载并保留的方式从邮件服务器下载邮件到用户方计算机。</li><li>不允许用户在邮件服务器上管理自己的邮件。</li><li>采用TCP C/S 端口110</li><li>安装用户代理程序</li></ul><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><ul><li>因特网邮件访问协议IMAP（Internet Message Access Protocol),IMAP4是第四个版本，目前只是因特网的建议标准</li><li>功能比POP3强大，用户可以在自己计算机上可 以操控邮件服务器中的邮箱，跟本体操控一样。因此IMAP也是一个联机协议</li><li>采用TCP C/S 端口143</li><li>安装用户代理程序</li></ul><h4 id="基于万维网的邮件"><a href="#基于万维网的邮件" class="headerlink" title="基于万维网的邮件"></a>基于万维网的邮件</h4><ul><li>浏览器登录</li><li>不需要下载到本地管理，工作模式与IMAP类似</li></ul><p>​    </p><h2 id="www"><a href="#www" class="headerlink" title="www"></a>www</h2><p>World  Wide Web<strong>,不是特定的网络</strong>,是个大规模的，联机式的信息储藏所，<strong>是一个运行在因特网上 的一个分布式应用</strong></p><p>浏览器对网页内容基于渲染引擎进行解析显示</p><h3 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</span><br></pre></td></tr></table></figure><p>http端口默认为80,可以不显示</p><p>以下详情可以移步前端分类文章：</p><p>HTML：网页结构内容</p><p>CSS：层叠样式</p><p>JavaScipt：脚本语言控制网页行为</p><p>部署在服务器端传输给浏览器进行渲染</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议（HyperText Transfer Protocol)</p><p>定义浏览器怎么向服务器</p><ul><li>HTTP/1.0版本<strong>只能**</strong>非持续链接**，请求一个文件都需要与服务器建立TCP连接，收到响应立即关闭连接，听浪费时间的，假设建立多个TCP连接请求多个对象，又太浪费服务器资源</li><li>HTTP/1.1 <strong>可以</strong>采用<strong>持续连接</strong>的方式，在该方式下，万维忘服务器在发送响应请求依旧保持这条链接，所以现在大部分都是HTTP/1.1版本，实现更好的交互效果<ul><li>进一步提高效率，使用流水线方式，收到下一个响应报文之前就可以连续发送多个请求报文，同时服务器也就会发回一个接一个的响应报文，节省很多RTT时间.</li></ul></li></ul><h3 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h3><p>面向文本，每一个字段都是ASCII码串，每个字段长度都是不确定的（</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>眼熟么，就是请求头</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730191036914.png" alt=""></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="/home/icrad/.config/Typora/typora-user-images/image-20220730191109693.png" alt=""></p><h4 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730191127839.png" alt=""></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730191405387.png" alt=""></p><p>经典状态码就是404 短语：Not Found</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用cookie在服务器上记录用户信息</p><p>第一次HTTP请求报文中没有携带cookie</p><p>服务器收到后生成唯一的cookie，并且以此为索引在服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息</p><p>服务器的HTTP响应报文中就携带了该cookie  在首部字段中Set-Cookie</p><p>客户端从得到的报文中读取Cookie保存，再下一次访问时的请求报文就携带上了cookie</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730192422176.png" alt=""></p><h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><ul><li>在万维网中还可以使用缓存机制提高万维网的效率</li><li>万维网缓存又称为<strong>Web缓存</strong>（Web cache)，可位于客户机，也可位于中间系统上，位于中间系统上的web 缓存又称为<strong>代理服务器</strong>（Proxy Server)</li><li>web缓存吧一些请求和响应暂存在本地磁盘中，当新请求到达时，就烦一会暂存响应，而不是再次根据URL再次访问资源。</li></ul><p>假设原始服务器的文档更改，代理服务器中的副本没有更改，如果直接请求怎么说？会不会拿到旧的文档呢？</p><p>首先知道源主机向代理服务器发送响应时会给该响应设定一个有效日期。（人为设定）</p><p>答案是： 8会，你猜猜文件为什么会有创建日期和修改日期捏？主机用户请求时，<strong>没有过期</strong>还是直接发回响应，假设有效日期<strong>过期了</strong>：代理服务器将会询问源主机响应是否发生改变，假设修改日期的不同，源主机会返回最新的响应给代理服务器，代理服务器再将该文档封装报文发给请求的主机。如果相同，源主机就会回复一个响应报文状态码为304 Not Modified</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220730193949043.png" alt=""></p><h2 id="补充：HTTPS"><a href="#补充：HTTPS" class="headerlink" title="补充：HTTPS"></a>补充：HTTPS</h2><p>实际上可以这么理解</p><p>是HTTP Secure （安全加强版）</p><p>全称为Hypertext Transfer Protocol over Secure Socket Layer</p><p><strong>在原有的HTTP下加入SSL层在（HTTP与TCP之间） </strong></p><p><strong>使HTTP明文传输变成加密传输</strong></p><p><strong>端口是443</strong></p><p>之前有说过纯HTML是无状态的，加入SSL 就不一样了是有特定状态的响应，</p><p>提供了身份验证与加密通讯方法。</p><p><strong>https协议需要到ca申请证书，一般免费证书很少，需要交费。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第五节|运输层</title>
      <link href="/2022/07/28/Internet05/"/>
      <url>/2022/07/28/Internet05/</url>
      
        <content type="html"><![CDATA[<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>物理层，数据链路层 ，网络层，实现了主机到主机的通信</p><p>但实际上，通信的真正实体其实是通信进程</p><span id="more"></span><p>P2P（端到端）运输层的协议</p><h3 id="两种主要协议"><a href="#两种主要协议" class="headerlink" title="两种主要协议"></a>两种主要协议</h3><p>面向链接的TCP</p><p>无连接的UDP</p><h3 id="AP（Applications-Process）"><a href="#AP（Applications-Process）" class="headerlink" title="AP（Applications Process）"></a>AP（Applications Process）</h3><p>由于因特网上会出现不同的操作系统，不同格式的进程标识符，就需要统一的方法对TCP/IP体系的应用进程进行标识</p><h3 id="端口-Port"><a href="#端口-Port" class="headerlink" title="端口(Port)"></a>端口(Port)</h3><p>实际上是区分应用进程的标识符(PID)，并不是物理端口</p><h3 id="端口号（PID）"><a href="#端口号（PID）" class="headerlink" title="端口号（PID）"></a>端口号（PID）</h3><p>TCP/IP体系的运输层使用端口号来区分应用层不同的应用进程</p><ul><li>16比特表示，取值为0~65535</li><li>熟知端口号：0~1023,IANA把这些端口号指派给TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20，HTTP适用80，DNS使用53.</li><li>登记端口号：1024~49151,为没有熟知的端口号使用，这类端口号必须在IANA按照规定的手续登记，以防止重复，例如：Microsft RDP微软远程桌面使用的端口3389。</li><li>短暂端口号：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文是，就知道客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul><h3 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h3><h4 id="发送方的复用"><a href="#发送方的复用" class="headerlink" title="发送方的复用"></a>发送方的复用</h4><p>应用报文根据所选的<strong>端口号</strong>判断是<strong>UDP协议进行复用</strong>封装成<strong>用户数据报</strong>。</p><p>同上，应用报文根据所选的端口号判断是<strong>TCP进行复用</strong>封装成报文段。</p><p>无论是数据报，还是报文段，都封装为IP数据报（协议字段不同），这个操作称为IP复用</p><p>最后发送给接收方</p><h4 id="接收方的分用"><a href="#接收方的分用" class="headerlink" title="接收方的分用"></a>接收方的分用</h4><p>接收方对IP数据报进行解析，根据协议字段，分别解析出用户数据报和报文段，分别进行UDP分用，TCP分用，再通过端口号解析为应用报文传递给上层</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727092643417.png" alt="image-20220727092643417"></p><h4 id="常见的熟知端口号"><a href="#常见的熟知端口号" class="headerlink" title="常见的熟知端口号"></a>常见的熟知端口号</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727093153322.png" alt="image-20220727093153322"></p><h3 id="UDP与TCP"><a href="#UDP与TCP" class="headerlink" title="UDP与TCP"></a>UDP与TCP</h3><h4 id="用户数据报协议UDP（User-Datagram-Protocol"><a href="#用户数据报协议UDP（User-Datagram-Protocol" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol)"></a>用户数据报协议UDP（User Datagram Protocol)</h4><ul><li><p>可以随时发送数据</p></li><li><p>无连接，支持一对一，一对多，一对全的通信</p></li><li><p>面向应用报文</p></li><li><p>提供的也是无连接不可靠的服务，仅仅丢弃数据报，不做任何处理，尽最大努力交付，无流量控制和拥塞控制</p></li><li><p>UDP数据报首部格式</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727102339647.png" alt=""></p></li></ul><h4 id="传输控制协议TCP-Transmission-Control-Protocol"><a href="#传输控制协议TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议TCP (Transmission Control Protocol)"></a>传输控制协议TCP (Transmission Control Protocol)</h4><ul><li>必须使用三报文握手建立连接</li><li>必须使用四报文挥手释放连接</li><li>面向连接，仅支持单播：一对一的通信</li><li>面向字节流（数据流），不保证大小关系对应，实现可靠传输的基础</li><li>提供的事面向连接的可靠传输服务，使用流量控制和拥塞控制</li><li>TCP数据报格式</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727102410486.png" alt=""></p><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>为了保证可靠的传输，控制数据的发送速率的操作被称为流量控制</p><p>关键点：</p><ul><li><p>seq是数据的序号字段</p></li><li><p>原理实际上跟SR有点相似</p></li><li>也有发送窗口和接受窗口，但是也有GBN的累计确认。</li><li>流量控制的是接受窗口，接受窗口控制的接受多少数据，而接受窗口的大小呢由接受端的数据缓存大小决定</li><li>发送窗口随着接受窗口进行变化，接受方告诉发送方接受窗口的大小，发送方保持发送窗口大小跟接受窗口一致</li></ul><p><strong>例子如下：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727113757304.png" alt=""></p><p>出现死锁的局面：<br><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727114358434.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727120356308.png" alt=""></p><h4 id="通俗的语言来解释TCP的流量控制（小作文了属于是）"><a href="#通俗的语言来解释TCP的流量控制（小作文了属于是）" class="headerlink" title="通俗的语言来解释TCP的流量控制（小作文了属于是）"></a>通俗的语言来解释TCP的流量控制（小作文了属于是）</h4><ol><li>A有16个神奇的苹果（报文段），B的袋子可以放4个苹果（这苹果的神奇之处在于，递出去之后，必须要知道是否接受到才会彻底消失，<del>薛定谔的苹果</del>）</li><li>A问B一次袋子能装多少个，B回答4个（接收窗口）</li><li>A就连续的给B递4个苹果，并给每个苹果标上序号，可是当B放第3个时，把袋子撑破了，第3苹果掉在了地上烂了（<strong>报文段丢失</strong>）</li><li><strong>B就先拿回家处理了一下（流量控制），把接受到的苹果们放入了冰箱，发现袋子只能放3个苹果了</strong>，这时，B告诉A，现在我的袋子只能装3个了，并且第三个苹果烂了且<strong>只拿到前两个苹果</strong></li><li>B表示知道了，与此同时A这里的确认收到的苹果彻底消失了，从之前没消失的第三个（就是内个摔烂的没有确认收到的苹果）开始连续的给B递3个苹果，此时序号也从第三个开始，递完之后，A等待B告诉是否收到的信息（<strong>设定计时器</strong>）</li><li>B接过了所有的苹果，但是，突然大脑呆滞阿巴阿巴，忘记给A回复了，也忘记回家放苹果了（<strong>累计确认报文丢失</strong>）</li><li>A只好再次把之前的苹果们 的<strong>第一个苹果</strong>传递给B（<strong>超时重传</strong>），再次进行等待</li><li>B收到了重新传送的苹果，发现重复了序号3的苹果，就把重复的丢弃给A回复了，这个时候发现拿三个回家，原本应该拿四个的才对，却想越气，<strong>决定再空出一只手再拿一个苹果</strong>。这时，B回复A都收到了这三个苹果，<strong>并且表示我还能再拿一个（流量控制）</strong></li><li>A知道后表示ok,之前的三个消失了，从最新的一个开始拿，想起来B说还能再拿一个，就只递给B一个，然后等待B回复是否收到，<strong>B表示额外的一个已经把B塞满了，就先别递了（再次流量控制），</strong>A说OK，等你回复什么时候再给你递</li><li>B回家放苹果，当把袋子里的都放好，想起来手上还有一个苹果，也放好了，干脆再重新拿个袋子，顺带告诉A我又可以拿3个苹果了（发现之前袋子实际上装不了4个，最多装三个）</li><li>A啊等啊等，迟迟等不到B给他回信息，为啥呢，发现了 B回的信息A没看见（不要在意为啥看不见，问就是<strong>ACK丢失</strong>），因为A不知道B到底能不能拿，就再也没有递苹果。（但是在心里暗自决定再等10s）（<strong>持续计时器</strong>）</li><li>B呢以为A知道了可以递苹果了，在傻傻的等（无计时器），实际上却是：两边都在等，出现了死锁局面</li><li>这样的局面怎么打破呢？A还是等不下去了（<strong>计时器超时</strong>），向B打了一个问号 “?” （<strong>一个字节的0窗口探测报文</strong>）</li><li>B说啊，我现在可以拿3个，A表示OK，就开始向B就递苹果了，就<strong>打破了这个死锁的情况</strong><ul><li>假设：B这会打LOL，回复还是拿不了，A只能行叭，只好等一段时间就向B 打个问号 “?” 。（每收到一个0,就启动持续计时器）</li><li>再假设：这个B玩的亚索0-17，队友也一直再给他打问号，B没发现A给打的问号，也就没有给A回复，那么这种情况，A的也是有忍耐时间的（<strong>0窗口探测报文的计数器</strong>），见到B还没有回复，就再打个问号（<strong>超时重传</strong>）</li></ul></li></ol><p><strong>注意，以上情况没有考虑出现拥塞控制</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220727121632253.png" alt=""></p><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>四个字，供不应需</p><p>需求远远超过已有资源就会出现拥塞，若不进行控制，整个网络的<strong>吞吐量</strong>将随着输入的负荷<strong>增大而下降</strong>，降为0就进入<strong>死锁</strong>状态</p><p>需要进行需求控制，也被称为拥塞控制，是相当有必要的</p><h4 id="四种拥塞算法"><a href="#四种拥塞算法" class="headerlink" title="四种拥塞算法"></a>四种拥塞算法</h4><p>发送方维护一个拥塞窗口cwnd,取决于网络的拥塞程度，并且<strong>动态变化</strong></p><p>拥塞判断的依据是，发生超时重传</p><p>发送方将拥塞窗口作为发送窗口swnd，</p><p>发送方维护这一个慢开始门限ssthresh状态变量：</p><ul><li>当cwnd&lt;ss thresh,使用慢开始算法</li><li>当cwnd&gt;ss thresh,停止使用慢开始算法该用拥塞避免算法</li><li>当cwnd=ss thresh ,即可以使用慢开始算法，也可以使用拥塞避免算法</li></ul><p>(TCP Tahoe)</p><ul><li><p>慢开始(slow-start)</p><ul><li>拥塞窗口值按照指数规律增长，按传播轮次</li></ul></li><li><p>拥塞避免(congestion avoidance)</p><ul><li>拥塞窗口值线性+1，按传播轮次</li><li>假设出现拥塞，将ss thresh值更新为发生拥塞时cwnd的一半，cwnd回到默认值，重新开始执行按开始算法</li></ul></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728100559097.png" alt=""></p><p>当出现超时重传时不一定会出现拥塞，如果直接判断产生拥塞，cwnd就会回到默认值重新开始，那么会极大的降低传输效率，为了提升TCP性能，引入了新的拥塞控制算法（TCP Reno）</p><ul><li>快重传(fast retransmit)<ul><li>使发送方尽快进行重传，而不是等超时重传计时器超时再重传，目的是为了让发送方尽早知道发生了个别报文端的丢失</li><li>出现丢失，发送方依旧不管不顾的继续发送，在超时重传计时器还没超时之前，每接收到一个报文，接收方会提醒一次我接受到了一个，但是之前的丢的还没给我补发（重复的确认我只收到了丢失的前一个），发送方连续收到<strong>三次</strong>重复确认丢失之前一个的报文的确认，立刻重传丢失的报文，这就是<strong>快重传</strong></li></ul></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728101840094.png" alt=""></p><ul><li>快恢复(fast recovery)<ul><li>发送方一但收到三个重复确认，就知道只是丢失了个别的报文段，并不是出现拥塞，转而执行快恢复算法</li><li>发送方讲慢开始文献ssthresh 和拥塞窗口cwnd调整为当前窗口的一半，开始执行拥塞避免算法</li><li>也有的块恢复实现是把快恢复开始时的拥塞窗口cwnd再增大一些 至少加3<ul><li>既然发送方收到了三个重复的确认，说明有三个数据报文段已经离开了网络，不需要消耗资源，就可以增加拥塞窗口，尽可能扩大TCP的传输速率</li></ul></li></ul></li></ul><p>四者结合动态实现拥塞控制</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728102803073.png" alt=""></p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>这是TCP最复杂的问题之一</p><p>太小不行，会出现重复</p><p>太大，会浪费传输效率</p><p>而且，RTT  ，数据传输时间是受各层影响的</p><p>所以不能直接使用某次测量的RTT样本超时重传时间RTO</p><p>利用每次测量的到的RTT样本，计算加权平均往返时间RTT，计算一个平滑的往返时间</p><script type="math/tex; mode=display">RTT_{S1}=RTT_1</script><script type="math/tex; mode=display">新的RTT_s=(1-a)*旧的RTT_s+a*新的RTT样本</script><p>在上式中$0\leq a &lt; 1$:</p><ul><li>若很接近0,则新的$RTT$样本$RTT_S$影响不大；</li><li>若很接近1,则新的$RTT$样本$RTT_S$影响较大；</li></ul><p>建议标准的RFC6298推荐的值为1/8，即0.125.</p><ul><li>该方法得到的值就比测量的RTT的值更加平滑，因此超时重传的时间就应该略大于$RTT_S$</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728105335061.png" alt="image-20220728105335061"></p><p>即使如此，对于RTT样本的测量一样会出现很多问题</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728105544856.png" alt=""></p><p>出现以上情况会出现计算差错</p><p>对此，karn提出一个算法：出现报文段重传，就不采用这段往返时间RTT作为样本</p><p>但是这有引起了新的问题：实际传播的时延突然增大，并且不再减小，就会一直出现超时重传的情况，那么RTO就无法再进行更新，就会一直重复发送数据报文段</p><p>进而对Karn算法进行修正，加入报文段每重传一次，就把超时重传时间RTO增大一些。典型的做法是：将RTO的值取为旧值得两倍。</p><p>​    举例说明</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728110426058.png" alt=""></p><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><ul><li>字节为单位的滑动窗口来实现可靠传输</li><li>发送窗口，出现拥塞采用拥塞窗口cwnd，未出现拥塞采用接受窗口值rwnd</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728111043844.png" alt="image-20220728111043844"></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728112050879.png" alt=""></p><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><ul><li>建立TCP连接</li></ul><ol><li><p>TCP客户端和TCP服务端都处于CLOSED状态</p></li><li><p>TCP服务端需要建立一个传输控制块</p><ol><li><p>TCP连接表</p></li><li><p>指向发送和接受缓存的指针</p></li><li><p>当前发送和接收的序号</p><p>……</p></li><li><p>建立好之后准备接受TCP客户的连接请求进而变更状态为监听LISTEN状态（该状态也称为被动打开连接状态）</p></li></ol></li><li><p>TCP客户进程同样首先创建传输控制块</p><ol><li>TCP连接表</li><li>指向发送和接受缓存的指针</li><li>当前发送和接收的序号</li><li>…….</li><li>发送TCP连接请求并更行状态为SYN-SENT（同步已发送）（主动打开连接）发送<strong>第一个报文</strong>（该报文用来请求TCP服务器的SYN-RCVD同步状态</li><li><strong>来简单的说明这个报文：发送的是一个带着SYN标志的报文，该值为1,说明这个报文是专门用来请求连接建立的，seq=x,这个X其实可以为任意值，由客户决定，表示的是序号</strong></li></ol></li><li><p>TCP服务器收到了<strong>第一条请求报文</strong>，为了表示请求成功，状态变为<strong>SYN_RCVD</strong>，回应了<strong>第二条新的报文</strong> ：标志ack=x+1（序号+1,表示上一个序号为x的报文确认收到了,请求序号为x+1的报文段）SYN=1 同时也表示这是用来建立连接的报文，不能携带数据，ACK=1<strong>标志表示这是一个确认的报文</strong> seq=y(同理第一条报文段，这个值可以由服务端自由设定)</p></li><li><p>当TCP客户端收到第二条报文，根据报文表示没问题，变为<strong>连接建立状态</strong>，并且发送<strong>第三条报文端</strong>，：该报问段是普通报文段 <strong>没有SYN标志</strong>，ACK=1表明这个是用来确认服务器的状态，seq=x+1，是该报文段的序号，ack=y+1则表示请求下一条服务器报文段的序号</p></li><li><p><strong>TCP服务器收到第三条报文，明白了TCP客户端是想建立连接，将自己状态改为连接已建立状态。</strong></p></li></ol><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728114322618.png" alt=""></p><p>其中建立连接用了<strong>三个报文</strong>，因此被成为三报文握手</p><p>假说不进行确认同步状态，直接双方一起建立连接，去掉第三个报文，改为两报文建立连接，就会出现第一报文丢失重发导致已关闭的TCP服务器误开，浪费网络资源。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728145452314.png" alt=""></p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><ul><li><p><strong>释放TCP连接的过程</strong></p><p>小可：我要走了</p><p>过了一会</p><p>小符：你确定你要走吗</p><p>小符，思考了一会，再次问：</p><p>你真的确定你要走了么？</p><p>（这时可以扔一些小石头之类的（数据）给小可）</p><p>过了一会</p><p>小可：嗯</p><p>小符听到后，小声嘟囔着一句</p><p>​    笨蛋</p><p>,然后头也不回的走了</p><p>小可有点怅然若失。</p><p>等了一会，最后也走了</p><p>如图所示：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728171424738.png" alt=""></p><p><strong>急着下班的小可</strong>（如果少了最后一次握手）</p><p>小可最后回复时，一阵大风，</p><p>小符没有听到小可最后的回复</p><p>而且小可直接溜了，</p><p>小符一直等啊等，等小可的最后回答</p><p>每等一段就问，</p><p>你真的要回去了吗？</p><p>……</p><p>可是小可早就run了。</p><p>即使听到了什么也不再理踩。</p></li></ul><p>  如图所示</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728171343533.png" alt=""></p><ul><li><p><strong>不想活的小可</strong></p><p>小可突然不想活了，吊在大本钟下</p><p>小符等了一会，发现小可没有再说话</p><p>就每等一会问一次</p><p>你特么还活着么？</p><p>连续问了十次</p><p>小符知道了，</p><p>小可估计是寄了</p><p>小符走了。</p></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728172420036.png" alt=""></p><p><del>才，才不是因为想偷懒呢</del></p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><ul><li><p>面向字节流</p></li><li><p>发送缓存中一部分或者全部字节给其添加一个首部成为TCP报文段然后发送</p></li><li><p>一个TCP报文段由首部和数据载荷两部分构成</p></li><li><p>TCP的全部功能都体现在它首部中个字段的作用</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728173523044.png" alt=""></p></li><li><p>源端口，目的端口</p><ul><li>源端口：顾名思义，进程端口，协议进程的端口，主机自己设定的暂时端口等</li></ul></li><li><p>序号</p><ul><li>取值 32比特，循环的，当最后一个值加一，回到0重新继续加，数据载荷的第一个字节的序号</li></ul></li><li><p>确认号（ack），标志位(ACK/URG/PSH/RST/SYN/FIN)</p><ul><li>确认号取值 32比特，循环的，当最后一个值加一，回到0重新继续加，搭配确认标志号ACK取值为1时才生效</li><li>TCP协议其实有规定，在建立连接后，ACK都必须为1</li><li>ack表示请求序号的下一个，并且表明我已经收到了之前的全部数据</li><li>标志位：(URG/ACK/PSH/RST/SYN/FIN)：表明报文段类型<ul><li>RST复位，表示TCP连接异常，必须释放连接，再重新建立，也可以拒绝非法报文段，禁止打开一个TCP连接</li><li>PSH推送，尽快上交，不用等待发送缓存</li><li>URG紧急标志，与紧急指针搭配，1生效，0无效</li></ul></li></ul></li><li><p>数据偏移，保留，窗口</p><ul><li>数据偏移：占4个比特，表示数据载荷部分起始处距离报文段起始的值，<strong>以四个字节为单位</strong></li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220728175151668.png" alt=""></li><li>保留：占6比特，默认为0；</li><li>窗口：占16比特，就是发送本报文段的一方的接收窗口</li></ul></li><li><p>校验和，紧急指针</p><ul><li>检验和：一种检错的数据</li><li>紧急指针与标志位搭配，指明出紧急的数据载荷部分长度，VIP指针，也不用排队上交给应用层</li></ul></li><li><p>选项（可选）</p><ul><li>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度</li><li>窗口扩大选项：扩大窗口，提高吞吐</li><li>时间戳选项<ul><li>计算往返时间RTT</li><li>处理序号超过范围的情况，防止序号绕回</li></ul></li><li>选择确认选项：选择确认功能</li></ul></li><li><p>填充</p><ul><li>用来保证首部能被4整除</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这部分还挺简单的，接下来就即将到达计网最高层了捏</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 运输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第四节|网络层</title>
      <link href="/2022/07/25/internet04/"/>
      <url>/2022/07/25/internet04/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层-重点掌握"><a href="#网络层-重点掌握" class="headerlink" title="网络层(重点掌握)"></a>网络层(重点掌握)</h1><p>网络层的任务</p><p>实现网络互连，进而实现数据包在各网络之间传输</p><p>网络层需要解决的问题</p><ul><li>提供运输层的服务</li><li>网络层寻址</li><li>路由选择问题</li></ul><span id="more"></span><p>因特网（Internet）使用的是TCP/IP协议栈</p><p><strong>网络层</strong>也常被称为<strong>网际层</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723081216440.png" alt=""></p><h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><ul><li><p>必须建立网络层连接 虚电路VC（Virtual Circuit)</p></li><li><p>可靠性由网络来保证</p></li><li><p>分组按序，走虚电路到达</p></li><li>在通信结束需要释放之前建立的虚电路</li></ul><h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><ul><li><p>可靠通行应当由用户主机来保证</p></li><li><p>不需要建立网络层连接</p></li><li>首部必须携带目的主机的完整地址</li><li>可以走不同的路由</li><li>容易出现误码，乱序等问题</li></ul><p>在TCP/IP全栈体系中</p><p>网际层提供的<strong>简单灵活的</strong>，<strong>无连接的</strong>，<strong>尽最大努力交付</strong>的<strong>数据报</strong>服务</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h3><p>全世界范围内唯一的 32比特的标识符（每一台主机或路由器的每一个接口）</p><p>IP地址由因特网名字和数字分配机构ICANN进行分配</p><ul><li>2011 IANA（互联网号码分配管理局）宣布IPv4分配完毕</li><li>2014~2015 我国逐渐停止分配IPv4,同时开始全面部署IPv6</li></ul><p>这里由时间发展，解释IPv4的编址方法的三个历史阶段</p><ol><li>1981年 <strong>分类编址</strong></li><li>1985年 <strong>划分子网</strong></li><li>1993年  <strong>无分类编址</strong></li></ol><h3 id="IPV4表示"><a href="#IPV4表示" class="headerlink" title="IPV4表示"></a>IPV4表示</h3><p>32位的IPv4地址采用点分十进制的表示方法</p><p>每八个比特分为一组，每组的十进制数，用点来分隔</p><p>快速计算</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723085508368.png" alt=""></p><p>凑值法</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723085734030.png" alt=""></p><h3 id="IPV6地址"><a href="#IPV6地址" class="headerlink" title="IPV6地址"></a>IPV6地址</h3><p>是IPv432位地址4倍长度，一样用的是CIDR记法</p><ul><li>扩展了路由和寻址的能力</li><li>报头格式的简化</li><li>对可选项更大的支持</li><li>身份验证和保密</li><li>支持无状态自动地址配置</li></ul><h2 id="编址阶段"><a href="#编址阶段" class="headerlink" title="编址阶段"></a>编址阶段</h2><h3 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h3><p>分出了五类依次按照ABCDE排序</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723090501132.png" alt=""></p><p>注意</p><ul><li>ABC可以分配给网络中的主机或路由器的各接口</li><li>主机号全为0的是网络地址，不能分配</li><li>主机号全为1的事广播地址，不能分配</li></ul><p><strong>A类</strong></p><ul><li><p>网络号全为0<strong>：最小网络号</strong>,<strong>保留不指派</strong></p><p>可指派的网络号起始为00000001</p></li><li><p><strong>最大网络号为</strong>：01111111， 为<strong>本地环回测试地址</strong>，<strong>不指派</strong></p><p>最小的本地环回测试地址为127.0.0.1</p><p>最大的本地环回测试地址为127.255.255.254</p></li></ul><p>所以可分配的范围为1~126，每个网络号的最大主机数：$2^{24}-2$</p><p>​    注意0.0.0.0只能最为源地址使用</p><p><strong>B类</strong></p><ul><li><p>最小网络号全为 0 ，也是<strong>第一个可指派</strong>的网络号，128.0<br>网络地址为128.0.0.0（给荷兰用的)</p></li><li><p>最大网络号也是最后一个可指派的网络号 ，191.255</p><p>网络地址为191.255.0.0</p><p>所以可分配的范围为1~126，每个网络号的最大主机数：$2^{16}-2$</p></li></ul><p><strong>C类</strong></p><ul><li>最小网络号192.0.0.0 ，也<strong>是可以指派的网络号</strong></li><li>最大网络号223.255.255.0</li></ul><p>所以可分配的范围为1~126，每个网络号的最大主机数：$2^{8}-2$</p><p><strong>特殊的ip地址：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723101245507.png" alt=""></p><p><strong>注意：两台路由器通过链路直连也是一个网络，也需要分配IP给各个端口。</strong></p><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>网络号申请得花钱。开销还很大，浪费原有网络号中剩余的主机号地址</p><p>那我在主机号中再划分各个子网，就充分利用了网络资源</p><ul><li>利用子网掩网使用连续的比特1来对应网络号和子网号</li><li>连续的的比特0；来对应主机号</li></ul><p>子网掩码将原有的耳机结构划分为了三级结构：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723102824555.png" alt=""></p><p>划分细节示例：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723102527353.png" alt=""></p><p>一个比特相当于将IP再次划分了两部分，子网0和子网1</p><p>同时子网0和子网1同时也有自己的广播地址和最小网络地址。</p><p>例题：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723103701163.png" alt=""></p><p><strong>注意事项：</strong></p><ul><li>在确定子网掩码时需要先确定网络类型，根据<strong>网络类型网络号</strong>确认<strong>默认子网掩码</strong></li></ul><h3 id="无分类编址"><a href="#无分类编址" class="headerlink" title="无分类编址"></a><strong>无分类编址</strong></h3><p>虽然划分了子网呢一定程度上解决些问题，但还是8太顶用，因为主机号与网络号不成正比。</p><p>CIDR（无分类的域间路由选择）</p><p>CIDR消除了传统的A类B类和C类地址,以及划分子网的概念</p><p>CIDR使用“斜线记法”，即在IPv4地址后面加上/  数字代表网络前缀占用数量</p><p>示例：  </p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723112642980.png" alt=""></p><h4 id="路由聚合（超网"><a href="#路由聚合（超网" class="headerlink" title="路由聚合（超网)"></a>路由聚合（超网)</h4><p>用来节省路由器中的路由表的占用，所以就叫做路由聚合。</p><p>将多个目的网络聚合在一个地址块。</p><p>聚合出来的地址块就称为聚合地址块</p><p><strong>聚合地址块</strong>根据 <strong>所有的目的地址的共同前缀</strong> ：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723113352483.png" alt="image-20220723113352483"></p><p><strong>聚合得到的地址块</strong>即为：172.1.4.0/22</p><p><strong>网络前缀越长，地址块越小，路由就越具体</strong></p><p>当路由器查表转发分组的时候就会发现又有多条路由可选，就会选择网络前缀最长的那条，被称为<strong>最长前缀匹配。</strong></p><h3 id="应用规划"><a href="#应用规划" class="headerlink" title="应用规划"></a>应用规划</h3><h4 id="定长子网掩码划分（FLSM）"><a href="#定长子网掩码划分（FLSM）" class="headerlink" title="定长子网掩码划分（FLSM）"></a>定长子网掩码划分（FLSM）</h4><p>上面的子网掩码实际上都归类为地场子网划分，只能划分2的n次方的子网（n是子网比特数)，但只要划分9个子网时，很有可能造成资源浪费，比如定长子网掩码 只能划分16个子网，就造成极大浪费</p><h4 id="变长子网掩码划分（VLSM）"><a href="#变长子网掩码划分（VLSM）" class="headerlink" title="变长子网掩码划分（VLSM）"></a>变长子网掩码划分（VLSM）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723174229568.png" alt=""></p><p>按需分配：</p><p>分配原则选分配地址数量最多的网络开始</p><p>尽可能减少了浪费，在不添加主机的情况下还是又一点点浪费</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220723181943846.png" alt=""></p><h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><h4 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a><strong>IPv4数据报的首部格式</strong></h4><p>实现iP协议的基础</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726120944091.png" alt=""></p><ul><li><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul><li>半个字节（字段）4位，通信双方协议版本必须一致，一般记为4（IPv4)</li></ul></li><li><h4 id="首部长度"><a href="#首部长度" class="headerlink" title="首部长度"></a>首部长度</h4><ul><li>同占4位，表示该IP数据报的首部的长度，改字段的取值是以4字节为单位，最小值为5（十进制，即20个字节），最大为15（同理，为60字节） </li></ul></li><li><h4 id="可选字段"><a href="#可选字段" class="headerlink" title="可选字段"></a>可选字段</h4><ul><li>可选字段，1~40个子接，用来支持拍错，测量及安全等措施，但是很少用</li></ul></li><li><h4 id="填充字段"><a href="#填充字段" class="headerlink" title="填充字段"></a>填充字段</h4><ul><li>确保首部长度字段为4字节的整数倍</li></ul></li><li><h4 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h4><ul><li>用来获得更好的服务，实际上没咋使用过。</li></ul></li><li><h4 id="总长度"><a href="#总长度" class="headerlink" title="总长度"></a>总长度</h4><ul><li>16个比特，顾名思义就是<strong>首部和数据载荷</strong>的长度</li><li>最大取值为十进制的65535,以字节为单位。</li></ul></li><li><h4 id="标识，标志，长偏移"><a href="#标识，标志，长偏移" class="headerlink" title="标识，标志，长偏移"></a><strong>标识，标志，长偏移</strong></h4><ul><li>作用是<strong>分片</strong> </li><li><strong>标识</strong>:占16比特，属于同一个数据报的各分片数据包应该具有相同的标识，并且IP软件维持一计数器，每产生一个数据报，计数器的值加1,并且将此值赋给标识字段</li><li><strong>标志</strong>：占3比特，DF位0表示可以切片，MF位0表示这是最后一个分片，保留位，必须为零</li><li><strong>片偏移</strong>：占13比特，值出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位。（片偏移以8个字节为单位）</li><li><strong>分片示例</strong>（假设因特网最大数据载荷为1500）</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726151551784.png" alt=""></li><li>分片的分片同理</li></ul></li><li><h4 id="生存时间，协议，首部检验和"><a href="#生存时间，协议，首部检验和" class="headerlink" title="生存时间，协议，首部检验和"></a>生存时间，协议，首部检验和</h4><ul><li><strong>生存时间</strong>TTL：路由器在转发该IP数据报时，将IP数据报首部中该字段的值减去IP数据报在本路由器上所耗费的时间（减1），若不为0就转发，否则就丢弃（当前以 跳数 为单位）</li><li><strong>协议</strong> 占8比特，用来指明，IP数据报是啥协议的数据单元<ul><li>常见的协议字段值</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726153430858.png" alt=""></li></ul></li><li><strong>首部检验和</strong>：也被称为因特网检验和，检验首部传输过程中是否出现差错，每经过一个路由器都需要重新计算首部检验和，IPV6中不再计算首部检验和</li></ul></li></ul><h4 id="发送与转发"><a href="#发送与转发" class="headerlink" title="发送与转发"></a>发送与转发</h4><p><strong>主机发送</strong></p><p> 间接交付是指两个不同的子网（网关）下进行数据报的发送</p><p>需要进行路由器的转发，</p><p><strong>路由器转发</strong></p><p>指定的路由器就是常说的默认网关</p><p>路由表中：目的网络，地址掩码 ：下一跳路由器</p><ul><li><p>注意是目的网络，路由器根据所传入的IP数据报首部的目的地址</p></li><li><p>目的地址与地址掩码相与得到所要传递的目的网络（网段）</p></li><li>如果找不到就丢弃该IP数据报，并返回一个ICMP报文</li></ul><p>最基本的原理</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220724105703620.png" alt=""></p><p><strong>附加：</strong></p><p>路由器不转发广播P数据报（可以理解为由软件实现），三层解析</p><p>VLAN（虚拟局域网技术）这玩意是在物理层隔离个广播域，只有两层解析地址，因此隔离广播域还得用VLAN</p><h3 id="静态路由的配置"><a href="#静态路由的配置" class="headerlink" title="静态路由的配置"></a>静态路由的配置</h3><p>多个路由之间的数据报的传递，需要手动配置静态路由表</p><p>但是不能及时适应网络状态的变化（流量，拓扑）</p><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a><strong>默认路由</strong></h4><p>当包含众多网络时（比如接入互联网），总不能每个接口都给路由表配置一个</p><p>我们使用该默认路由0.0.0.0/0</p><p>默认接入该接口下的所有网络.</p><h4 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a><strong>特定主机路由</strong></h4><p>考虑安全问题时，路由器中添加一条特定主机的IP（CIDR）也可以访问</p><p>当同时存在默认路由和特定主机路由，最长前缀匹配</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725092852395.png" alt=""></p><h4 id="静态路由环路"><a href="#静态路由环路" class="headerlink" title="静态路由环路"></a><strong>静态路由环路</strong></h4><ul><li><strong>错误的配置：</strong></li></ul><p>路由容易引发路由环路错误</p><p>不过呢为防止IP数据报在路由环路中永久兜圈，在IP数据报首部都设有有生存时间的</p><p>TTL字段，该字段在进入路由器后TTL字段的值减1.弱TTL的值不等于0,责备路由器转发，否则丢弃</p><ul><li><strong>聚合不存在了不存在的网络：</strong></li></ul><p>聚合的概念：就是超网。</p><p>你指定的聚合网络块中，有一些是没有进行配置主机接入的网络，当有数据报转发到该不存在的网络时就会找不到,只能走默认路由，二默认路由的下一跳是原网络，就会出现路由环路的问题</p><p>所以我们为这些不存在的网络配置了一个黑洞路由</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725100340470.png" alt="image-20220725100340470"></p><ul><li><strong>网络故障</strong></li></ul><p>网络故障导致的路由条目进行删除，一样转发只能走默认路由，如果下一跳是源网络，又会出现路由环路的情况</p><p>所以我们为这些删除的，不存在的网络配置了一个黑洞路由（下一条为null0)。</p><p>当网络故障恢复好后，路由器会自动检测添加该网络接口，并将之前的人工配置的黑洞路由配置自动失效</p><p>，当又出现故障，就恢复生效状态</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725100819279.png" alt=""></p><h3 id="动态路由的选择"><a href="#动态路由的选择" class="headerlink" title="动态路由的选择"></a>动态路由的选择</h3><p>比较复杂，开销大，但是适应性好，适用于大规模网络</p><p>特点:</p><ul><li><h4 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h4><p>动态路由选择</p></li><li><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>路由之间交换路由信息</p></li><li><h4 id="分层次"><a href="#分层次" class="headerlink" title="分层次"></a>分层次</h4><p>整个因特网划分各个自治系统AS</p></li></ul><h4 id="分层次-1"><a href="#分层次-1" class="headerlink" title="分层次"></a>分层次</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725101430655.png" alt=""></p><ul><li><p>自治系统的之间的路由选择</p><p>使用的协议为外部网关协议EGP（只是名称，不是具体协议）</p><p>等同于ERP外部路由协议</p></li><li><p>自治系统内部的路由选择</p><p>使用的协议为内部网关协议EGP（只是名称，不是具体协议）</p><p>等同于IRP内部路由协议</p></li></ul><p>  以下是常见的路由选择协议：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725103011360.png" alt=""></p><h4 id="路由器的基本机构"><a href="#路由器的基本机构" class="headerlink" title="路由器的基本机构"></a>路由器的基本机构</h4><p>分为两部分：</p><ul><li><h4 id="路由选择部分"><a href="#路由选择部分" class="headerlink" title="路由选择部分"></a>路由选择部分</h4><ul><li>路由选择处理机：路由表</li></ul></li><li><h4 id="分组转发部分"><a href="#分组转发部分" class="headerlink" title="分组转发部分"></a>分组转发部分</h4><ul><li>一组端口（可以输入可以输出，下图分出来是为了方便理解）</li><li>交换结构：分组表</li><li>输入输出的缓冲区<ul><li>输出缓冲区暂存的是来不及处理发送的数据</li><li>输入缓冲区暂存的事来不及处理接受的数据</li></ul></li></ul><p><strong>注意</strong>：</p><p>路由表和分组表事分开的东西，为了方便理解，默认将路由表</p></li></ul><p>如图所示：<img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725103600937.png" alt=""></p><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><ul><li>内部网关协议IGP中最先得到广泛使用的协议之一</li><li>要求每一个路由器都维护从它到其他每一个网络的距离记录，称为<strong>距离向量</strong>（Distance-Vector)</li><li><strong>跳数</strong>（Hop Count)作为度量(Metirc)来衡量到达目的网络的距离<ul><li>路由器到直连网络的距离定义为1</li><li>到非直联网络的距离定义为所经过的路由器数+1</li><li>最多<strong>15</strong>个路由器，所以<strong>距离等于16时</strong>相当于<strong>不可达</strong></li></ul></li></ul><h4 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><ul><li>好的路由就是距离短的路由</li><li>同时又多条距离相等的路由是进行，<strong>等价负载均衡</strong><ul><li><strong>等价负载均衡</strong>：将通信数据等量平均的分布到多条等价的路由上</li></ul></li></ul><ul><li><strong>仅和相邻路由器周期性交换更新路由表</strong></li><li>若干次交换网络与更新，路由都记录了各网络的最短距离和下一跳地址，这个过程称为收敛</li></ul><h4 id="更新规则："><a href="#更新规则：" class="headerlink" title="更新规则："></a>更新规则：</h4><p>​    路由表的交换，传递，改造，更新</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725113709731.png" alt=""></p><h4 id="RIP的缺陷"><a href="#RIP的缺陷" class="headerlink" title="RIP的缺陷"></a>RIP的缺陷</h4><ul><li><p>坏消息传的慢</p><p>出现故障时，就会有可能出现路由环路的问题，如图所示</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220725114803457.png" alt="image-20220725114803457"></p></li><li><p>坏消息 （故障的网络的信息）传得很慢</p><p>又被成为<strong>路由环路或无穷记数的问题</strong>：这是距离向量算法的一个固有问题</p><p>但是可以采取多种措施减小该问题出现的概率或者降低其带来的危害</p><ul><li>限制<strong>最大距离</strong>为15</li><li>当路由表发生变化<strong>立即发送</strong>更新报文，而不是周期发送</li><li><strong>水平分割</strong>：让路由器记录收到某特定路由信息的接口，而不让同意路由的信息再通过此接口反方向传送</li></ul></li></ul><p>​        <strong>注意：这些方法并不能消除问题，距离向量算法是这样的</strong></p><p><strong>缺少的内容</strong></p><p>RIP的报文格式</p><p>定时时常等</p><p>IPv4 的RIP有两个版本</p><p>IPv6 的RIPng</p><h3 id="开放式最短路径优先OSPF协议"><a href="#开放式最短路径优先OSPF协议" class="headerlink" title="开放式最短路径优先OSPF协议"></a>开放式最短路径优先OSPF协议</h3><p>克服RIP的缺点</p><ul><li>基于链路状态</li><li>采用SPF算法，原理上不会产生路由环路的问题</li><li>不限制网络规模，收敛速度快</li><li>链路的状态是指和那些路由器相邻，以及相应链路的代价（cost)<ul><li>代价用来表示链路时延距离带宽等等都行，由网络管理人员决定</li><li>思科路由器OSPF计算代价的方法：100Mbps/链路带宽</li></ul></li></ul><h4 id="基本工作原理-1"><a href="#基本工作原理-1" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><ul><li>发送问候（hello)分组,建立和维护邻居关系<ul><li>该分组封装在IP数据报中，发往组播地址224.0.0.5</li><li>发送周期为10秒</li><li>40秒未收到来自邻居路由器的hello分组，则认为该邻居路由不可达</li></ul></li><li>每个路由器都会产生链路状态通告LSA（Link State Advertisement).<ul><li>直连网络的链路状态信息</li><li>邻居路由器的链路状态信息</li></ul></li><li>每个路由器都有一个链路状态数据库LSDB，用来存储LSA</li><li>通过各个路由器泛洪发送封装自己的LSA的LSU分组，最终使个路由器的LSDB达到一致</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726110350726.png" alt=""></li><li>基于最短SPF算法得出最短路径。具体SPF算法请移步这篇文章：</li><li>OSPF有一下五种分组类型<ul><li>hello分组<ul><li>问问能不能到达</li></ul></li><li>数据库描述(<strong>D</strong>atabase <strong>D</strong>escription)<ul><li>发送自家的集合成的所有链路状态项目的摘要信息）</li></ul></li><li>链路状态请求（<strong>L</strong>ink <strong>S</strong>tate <strong>R</strong>equest）<ul><li>请求发送具体的详细信息</li></ul></li><li>链路状态更新（<strong>L</strong>ink <strong>S</strong>tate <strong>U</strong>pdate）<ul><li>路由器使用这种分组，发送链路状态进行洪泛发送，对全网更新链路状态</li></ul></li><li>链路状态确认（<strong>L</strong>ink <strong>S</strong>tate <strong>A</strong>ckonwledgment）<ul><li>确认更新链路状态的确认分组</li></ul></li></ul></li></ul><p><strong>基本工作过程如下图所示：</strong></p><p>​        <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726111842587.png" alt=""></p><ul><li>在多点接入网络中路由器邻居关系的建立<ul><li>选举 指定路由器DR，备选的 指定路由器BDR</li><li>所有的非DR/BDR只与DR/BDR建立邻居关系</li><li>非DR/BDR之间通过DR/BDR才能交换数据</li></ul></li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726112314026.png" alt="image-20220726112314026"></p><p>​        </p><p>​    实现选举并不复杂，类似交换机的生成树协议STP，忘请回看上一章</p><p>为了进一步扩大网络规模，OSPF把一个自治系统再划分为诺干更小的范围 ，叫做区域Area</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726112849474.png" alt="image-20220726112849474"></p><p>划分区域的好处，就是区域内交换的信息量少了，能应用于更大规模的网络</p><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><ul><li><p>这不讲了两个内部主要的网关（路由）协议，就不得不讲讲EGP外部网关协议中的BGP边界网关协议了</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726113414469.png" alt=""></p></li><li><p>内部网关协议IGP</p><ul><li>只需要考虑自治系统内的网络，无需考虑外部的其他策略</li></ul></li><li><p>外部网关协议EGP</p><ul><li>因为不同的自治系统内，度量路由的代价cost可能不同，因此需要换个度量寻找最佳路由，但是没有统一的度量，找个最佳路由没有意义</li><li>而且，不同的自治系统可能代表着不同的国家（你懂的）必须考虑相关策略（注意策略并不是协议）</li></ul><p><strong>注意：这里我还是要提一嘴，IGP和EGP并不是具体协议</strong>，可以理解为类型</p></li></ul><h4 id="基本工作原理-2"><a href="#基本工作原理-2" class="headerlink" title="基本工作原理"></a>基本工作原理</h4><p>基于以上考虑：</p><ul><li>BGP协议 设定一个路由作为自治系统内的 BGP发言人</li><li>发言人互相交换了网络可达性的信息后，各BGP发言人根据各自的相关策略选出一个达到各自治系统比较好的路由。也就是构造出一个树形结构（避免环路）</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726114524387.png" alt=""></p><ul><li>各AS自治系统交换其路径向量</li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726115256186.png" alt=""></li></ul><h4 id="BGP-4四种报文"><a href="#BGP-4四种报文" class="headerlink" title="BGP-4四种报文"></a>BGP-4四种报文</h4><ul><li>open<ul><li>打开，可以理解为开门，建立关系，通信初始化</li></ul></li><li>update<ul><li>通告路由信息，列出撤销或增加的多条路由</li></ul></li><li>keepalive<ul><li>周期性证实邻站的连通性</li></ul></li><li>notificatin<ul><li>用来发送检测到的差错信息</li></ul></li></ul><p>不同协议的报文的直接封装的协议分别如下图</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726120631145.png" alt=""></p><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><ul><li><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP（<strong>I</strong>nternet <strong>C</strong>ontrol <strong>M</strong>essage <strong>P</strong>rotocol）</p></li><li><p>主机或者路由器使用ICMP来发送<strong>差错报告报文</strong>和<strong>询问报文</strong>。</p></li><li><p>ICMP报文被封装在IP数据报中发送</p></li></ul><h4 id="五种差错报文类型"><a href="#五种差错报文类型" class="headerlink" title="五种差错报文类型"></a>五种差错报文类型</h4><ul><li>终点不可达<ul><li>终点还可以细分为，端口，路由，网络，等等</li></ul></li><li>源点抑制<ul><li>出现拥塞是丢弃数据报，就想源点发送源点抑制报文，通知源点把发送速率放慢点，要坏掉了。</li></ul></li><li>时间超过<ul><li>当收到不是给自己的IP数据报，将TTL减1,结果不为0就转发，结果为0时，就像源点发个时间超过报文</li><li>当出现分片缺少时，把所有分片都丢失，并且发送给源点<strong>一个</strong>时间超过</li></ul></li><li>参数问题<ul><li>检测到误码，就想源码法参数问题数据报文</li></ul></li><li>改变路由（重定向）<ul><li>路由器把改变路由报文发送给主机，让主机知道下次应当将数据包发送给另外的路由器。</li></ul></li></ul><p><strong>不该发送的情况</strong></p><ul><li>多播地址报文</li><li>ICMP报文出差错，不再发ICMP</li><li>数据片发送一个就够了</li><li>特殊地址，127.0.0.0或者0.0.0.0</li></ul><h4 id="两种常用ICMP询问报文"><a href="#两种常用ICMP询问报文" class="headerlink" title="两种常用ICMP询问报文"></a>两种常用ICMP询问报文</h4><ul><li>回送请求和回答<ul><li>向一个特定的目的主机发出询问，收到询问，目的主机必须回送一个回送回答报文</li><li><strong>用来测试目的站是否可达</strong></li></ul></li><li>时间戳请求和回答<ul><li>询问时间，1900年1月1日开始 到 当前时刻的多少秒，作为值填入一个32位的字段，作为回答报文</li><li><strong>用来进行时钟的同步和测量时间</strong></li></ul></li></ul><h4 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h4><ul><li><h4 id="分组网间探测-Packet-InterNet-Groper"><a href="#分组网间探测-Packet-InterNet-Groper" class="headerlink" title="分组网间探测(Packet InterNet Groper)"></a>分组网间探测(<strong>P</strong>acket <strong>I</strong>nter<strong>N</strong>et <strong>G</strong>roper)</h4><ul><li><p>就是我们常用的ping指令，用来测试网络是否可达</p></li><li><p>应用层直接使用网际层的ICMP（没有通过运输层的TCP或UDP）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接拿百度做测试就好</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure></li></ul><p>效果如图： <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726162956952.png" alt=""></p></li></ul><ul><li><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><ul><li><p>用来测试IP数据报从源主机到达目的主机要经过那些路由器</p></li><li><p>直接使用的网际层，一样没有用到应用层</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同样还是百度</span><br><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure></li></ul><p>效果如图 <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726163524000.png" alt=""></p></li></ul><p>​    原理就是源主机连续的发送，每发送一次，ttl+1,直到到达发送的主机（此时到当前目的路由TTL的值为1），回送请求回答的报文。</p><h3 id="虚拟专用网（VPN）与网络地址转换（NAT）"><a href="#虚拟专用网（VPN）与网络地址转换（NAT）" class="headerlink" title="虚拟专用网（VPN）与网络地址转换（NAT）"></a>虚拟专用网（VPN）与网络地址转换（NAT）</h3><h4 id="虚拟专用网（Virtual-Private-Network"><a href="#虚拟专用网（Virtual-Private-Network" class="headerlink" title="虚拟专用网（Virtual Private Network)"></a>虚拟专用网（Virtual Private Network)</h4><p>利用公用的因特网，作为一个专用网之间的通信载体，这样额专用网又成为虚拟专用网。</p><p>由于IPv4都分配完了挺紧缺的，一个机构能申请到的地址数远远小于拥有的主机数量，因此，虚拟专用网中的各个主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要再重新申请的，在因特网中使用的公有地址</p><p>以上这段话可以这么理解：我呢家里啊只申请到了一个IP地址，要接我网络的主机超过了我能拥有的IP的数量，我想让我的其他主机也能接入网络，但是没有IP地址，得咋整呢：</p><p>这么时候诶，</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726165421197.png" alt=""></p><p>我们查找到了几个能让我们自己使用的ip地址块，这些地址块被称为私有地址</p><p>也就是我们常说的 <strong>内网</strong>，我们将这些主机的IP设为这些内网地址。</p><p>但是私有地址们只能在内部通信，咋接入因特网呢，这些内网地址发出来的数据报因特网也不收啊？它只接受我们申请到的公网IP。</p><p>诶，所以你以为咱们为啥要买<strong>路由器</strong>？。。</p><p>这不就是将唯一申请到的IP地址分配给路由器么，通过路由器再接入互联网？（NAT）</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726170416656.png" alt=""></p><p>这种内网传送到内网的操作，咱们称其为<strong>IP隧道技术</strong></p><p>这类同一机构不同部门的内部网络所构成的虚拟专用网VPN又成为<strong>内联网VPN</strong></p><p>在世界各地接入因特网，只需要运行该VPN软件，就可以访问VPN其他内网的资源，<strong>这种VPN称为远程接入VPN</strong></p><h4 id="网络地址转换（Network-Address-Translation"><a href="#网络地址转换（Network-Address-Translation" class="headerlink" title="网络地址转换（Network Address Translation)"></a>网络地址转换（Network Address Translation)</h4><p>1994年提出了网络地址转换NAT的方法。</p><p>通俗来说就是：私有地址主机到的IP地址转换为全球IP地址</p><p>NAT路由器可以实现每一个内网地址对应一个外网地址对应并进行数据转发</p><p>但是只能一个外网地址跟一个内网地址对应，那不是还是需要申请公网地址？这不白转换了？</p><p>那么我们带着运输层的端口一起进行转换。这样，就可以只使用一个全球IP地址绑定多个本地地址的主机进行通信。</p><p><strong>NAPT</strong>（<strong>N</strong>etwork <strong>A</strong>ddress and <strong>P</strong>ort <strong>T</strong>ranslation)</p><p><strong>网络地址和端口号转换</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726172612960.png" alt=""></p><p>但是注意，外网的服务器是无法主动发起对内网的通信的，</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726173147402.png" alt=""></p><p><strong>内网的好处：</strong></p><ul><li>隔绝外网随意对内网进行链接，安全防护</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>能将IP地址解析下一个路由或者设备的相应MAC地址并在数据链路中重新封装</p><p>ARP（Address 解析 协议）高速缓存表：</p><p>用来存储的东西</p><p><strong>注意一下arp报文都是封装在MAC帧当中的</strong></p><p>在数据链路层，向所有主机发送ARP请求报文</p><p>根据其中请求的ARP请求报文检验，是否是来请求自己的，如果不是，就丢掉</p><p>如果是，交给上层网络层ARP进程 解析 先记录请求报文的主机IP与MAC 地址于自己的ARP高速缓存表中：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721172516670.png" alt=""></p><p>然后向下 数据链路层 再向发送请求的主机，一个ARP响应报文，其中包含自己的MAC 与ip地址，</p><p>收到了ARP响应报文，网络层的ARP进程进行解析，然后记录到自身的ARP告诉缓存表</p><p>注意不能跨网络使用</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721173048276.png" alt=""></p><p>注意了：</p><p>ARP还有其他报文，比如，免费报文（用来检测IP是否冲突）</p><p>ARP协议没有安全验证机制，有写人就会利用ARP进行攻击，ARP欺骗等问题</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这章学爽了</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++复健(未整理)</title>
      <link href="/2022/07/24/cfj/"/>
      <url>/2022/07/24/cfj/</url>
      
        <content type="html"><![CDATA[<p>C++复健（侯捷）</p><p>overloading (重载)</p><p>重载的条件：</p><p>同名</p><p>同作用域</p><p>不同的返回值</p><p>或者不同的参数（形参）</p><p>同名：其实在编译器来看是不同名的</p><p>作用域：一个类内，一个全局域内，一个函数域内</p><p>当构造函数放在私有中：</p><p>设计模式：Singleton</p><p>外界不能创建这个类</p><p>但是我们可以通过这个类提供的外界接口。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>; <span class="comment">//关键点在 static</span></span><br><span class="line">    <span class="built_in">setup</span>()&#123;...&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();<span class="comment">//调用方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数,内联（inline）定义，调用是最快的 </p><p>但内联是编译器决定的，写的定义过于复杂就不能一定是内联函数 </p><p>我们在类外定义函数实现的时候：需要inline在最外进行修饰，才有可能修饰成内联函数</p><p>构造函数：初始化值最好使用初始化列表的方式</p><p>常量成员函数</p><p>修饰符：const</p><p>要确定，是否要更改其中对象中数据，<br>如果要不需要更改 ，那必须需要修饰成员函数 添加const修饰</p><p>因为这是正规的正式合法的修饰，不加说明你是学习C++的杂牌军</p><p>const的意义</p><p>在使用该类的途中如果使用了const修饰，你却没有给这个函数修饰，编译器会报错</p><p>所有的成员函数都隐藏着一个参数 this; 这个this是调用这个成员函数的对象的指针</p><p>示例：</p><p>运算符的重写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面写法</span></span><br><span class="line"><span class="built_in">operator</span> ()(<span class="type">const</span> <span class="type">int</span> &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上</span></span><br><span class="line"><span class="built_in">operator</span> ()(<span class="keyword">this</span>,<span class="type">const</span> <span class="type">int</span> &amp;a)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>引用是可以理解为一个指针常量</p><p>可以改内容不可以改名字</p><p>我们可以用const修饰引用，既不可以该指针地址，也不可以改值</p><p>传指针才多大，当你要传的东西，大于指针地址的大小，为了速度呢前提是你不更改你传的东西，可以使用常量引用作为传值，若果要修改，就不要加常量修饰</p><p>注意了，返回引用本质是上返回指针，别啥玩意都返回引用，返回个野指针空指针啥的都是非法操作</p><p><strong>传递者无许知道接受者是以引用（reference)的形式接受</strong></p><p>标准库不是圣经,<del>圣经还有错的</del>呢，不是完美无缺的</p><p>构造函数的特殊语法初始化列表</p><p><strong>相同class的各个objects互为友元</strong></p><p><strong>一个好的C++代码习惯：</strong></p><p><strong>总结：内联函数最佳，const能加就加，引用能用就用，类中变量数据最好放私有区域</strong> <strong>用构造函数的特殊语法初始化列表</strong></p><p><strong>相当优雅</strong></p><p>类的匿名对象可以用作temp object（临时对象） ,一般用在生命周期比较短的作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return int( (int) char( &#x27;a&#x27;));</span><br></pre></td></tr></table></figure><p>拷贝构造编译器默认有给。</p><p>但是遇到以下情况：就不能用默认的：</p><p>类带指针成员</p><p>自定义一个string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(onst <span class="type">char</span>* cstr=<span class="number">0</span>);</span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span><span class="comment">//内联</span></span><br><span class="line">    String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* cstr=<span class="number">0</span>)<span class="comment">//拷贝构造</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data= <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)+<span class="number">1</span>];<span class="comment">//+1的意义是结束符号</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, cstr);<span class="comment">//数据的挪移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        m_data =<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//结束符号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">    String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>;<span class="comment">//检测自我赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个判断是有必要的，不止是为了效率，还为了正确性假设有这个么笨蛋</span></span><br><span class="line">    <span class="comment">//这么使用语法 s1=s1 如果不进行检测，就把自己先delete掉了。接下来的操作都是非法操作.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] m_data;<span class="comment">//指针数组串需要加中括号</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);<span class="comment">//深拷贝</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">    String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">String s3=s2;</span><br></pre></td></tr></table></figure><p>注意了有拷贝构造，VS的编译器就不给你生成别的默认的构造函数了（你就自己用你自己设定的吧！哼</p><p>啥事栈(stack)？啥事堆（heap）啥事作用域（scope）？</p><p><del>若不知道，回炉重造</del></p><p>栈：</p><p>存在于某作用域(scope)的一块内存空间。调用一个函数，函数本身会形成一个栈来方式所接还送肚饿参数和返回地址。</p><p>堆：</p><p>系统分配的（具体怎么分配问你操作系统）提供的一块全局的内存空间</p><p>程序可以动态分配区块，你得手动释放这块内存，才会死，否则只能就交给操作系统处理，具体怎么处理，还是得问问操作系统。</p><p>static静态修饰的玩意在全局区，直到程序结束</p><p>new 不是函数，实际上是一个操作符</p><p>而malloc才是一个函数</p><p>new的底层调用了malloc,然后调用构造函数ctor</p><p>delete同理</p><p>底层原理：先调用析构函数dtor  后调用free</p><p>VC编译器习的动态内存分配</p><p>注意是32位的操作系统下。</p><p>分配的内存块(in VC)，必须是16的倍数,除了本身的数据以外，还有两个4字节的头与尾cokie    值为总内存块的大小转16进制最后一位为1</p><p>1代表着，系统给出内存。0就没有给出，可以理解为一个标志</p><p>注意，分配的若是数组，将会分配的内存块中会有一个整数（4字节），值是数组的长度</p><p>调用delete时 也会先调用数组的长度次数的析构函数，再释放free内存</p><p>在使用NEW和 delete 的操作需要特别确认，不会出现误操作</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础ISO</title>
      <link href="/2022/07/21/socket/"/>
      <url>/2022/07/21/socket/</url>
      
        <content type="html"><![CDATA[<h1 id="ISO7层网络结构体系图"><a href="#ISO7层网络结构体系图" class="headerlink" title="ISO7层网络结构体系图"></a>ISO7层网络结构体系图</h1><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/bfcd89ba301b34b6f158d2065a5ccb40.jpg" alt="https://s4.51cto.com/oss/201910/22/bfcd89ba301b34b6f158d2065a5ccb40.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第三节|数据链路层</title>
      <link href="/2022/07/20/internet03/"/>
      <url>/2022/07/20/internet03/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>有些部分内容也是相当的抽象，了解即可</p><p>重点部分</p><ul><li>数据链路层的互联设备<span id="more"></span></li></ul><p>网络编程的主要研究在网络层中</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>给上一层交付的协议数据单元进行先添加帧尾和帧头使其成为帧</p><p>ppp帧（点对点信道的帧）</p><p>帧头帧尾作用之一是帧定界标志</p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>指的是对上层交付的传输数据没有任何限制，数据链路层的封装好像就是理所应当的，看不见的，不存在的（可以理解为你经常会忽视，你习以为常的事物）</p><h4 id="面对字节的物理链路使用字节填充"><a href="#面对字节的物理链路使用字节填充" class="headerlink" title="面对字节的物理链路使用字节填充"></a>面对字节的物理链路使用字节填充</h4><p>在发送帧之前检测定界标志，检测到定界符flag或者转义字符就前插入一个esc转义字符</p><p>如图所示：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图2022-07-1808-54-16.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图022-07-1808-54-29.png" alt=""></p><p>注意转义字符只有一个字节，10进制为27，是一个控制字符</p><h4 id="面向比特的物理链路使用比特填充"><a href="#面向比特的物理链路使用比特填充" class="headerlink" title="面向比特的物理链路使用比特填充"></a>面向比特的物理链路使用比特填充</h4><p>对数据部分进行每五个连续的比特1添加一个比特0，确保帧定界的标志成为唯一的值</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图022-07-1809-01-04.png" alt=""></p><p>在接收方时按照改规则去除比特0即可</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>提高帧的传输效率，应当使数据部分的长度更大一些</p><p>但是考虑到差错控制等多种因素，每一种数据链路层的协议都规定的帧的数据部分的最大上限</p><p>我们称其为最大传送单元MTU（Maximum Transfer Unit)</p><p>mac帧是没有定界符的，取代而之的是物理层加入一个前导码，有着相同的作用</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>比特差错，也是我们常说的误码</p><p>0变成1,1变成0 ，<del>想到了一些怪东西，不要深究</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/E42EE4FE61B7BAB7585878F6B6268C33.jpg" alt=""></p><p>在一定时间内，产生的错误在传输过程中占比，被称为误码率</p><p>这个时候我们就需要进行校验</p><h4 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h4><p>顾名思义，检测比特1是否为奇数或偶数</p><p>通信的双方指定一个校验方式</p><p>漏检率较高，计网用不着</p><h4 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h4><p>CRC (Cyclic Redundancy Check)</p><p>双方生成多项式G(X)</p><p>发送方：根据发送数据和生成的多项式计算出差错检测码（冗余码），将其添加到带传输数据的后面一起传输</p><p>简单冗余码的计算过程</p><p>首先我们需要得知待发送的信息的比特串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设为：101001</span><br></pre></td></tr></table></figure><p>生成一个多项式（随机假设的）</p><script type="math/tex; mode=display">G(x)=x^3+x^2+1</script><p>通过多项式的系数构造一个被除数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得到：1101</span><br></pre></td></tr></table></figure><p><strong>注意</strong> 使用的是模2除法，不是我们常用的十进制除法（进行的是异或运算）</p><p><img src="" alt=""></p><p>通过组合计算出来的余数就可以发送了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发送的数据：101001  001</span><br><span class="line">                  余数</span><br></pre></td></tr></table></figure><p>接受方：根据发送数据和生成的多项式计算，检查余数是否为0,若不为0,说明为产生误码</p><p>直接上图：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718095630773.png" alt="image-20220718095630773"></p><p><strong>注意</strong>：咱这只是差错检测，<strong>纠错</strong>是不行的，想要纠错，可以使用冗余信息更多的<strong>纠错码</strong>进行<strong>向前纠错</strong>。但是纠错码<strong>开销较大</strong>，计算机很少用</p><p>那么纠错该怎么实现呢，检错重传方式来纠正传输中的差错，或者是直接丢弃错误的帧，这都取决于数据链路层向上提供的是啥协议TCPor UDP可靠或者不可靠的 传输服务了</p><p><strong>CRC有很好的检错能力，计算也不复杂，而且易于硬件实现，所以广泛应用于数据链路层</strong></p><h3 id="可靠传输基本概念"><a href="#可靠传输基本概念" class="headerlink" title="可靠传输基本概念"></a>可靠传输基本概念</h3><p>基本概念：使用了差错检测后，出现了误码</p><p>不可靠传输服务：<strong>仅仅丢弃</strong>有误码的帧，啥也不做</p><p>可靠传输服务：发送端发到什么，接收端收什么</p><p>注意：可靠传输服务，<strong>不仅</strong>仅存在于数据链路层，在各层中都可以实现</p><p><strong>差错</strong>也有很多种：</p><p>比特差错<br>以下差错<strong>一般</strong>出现在数据链路层的上层</p><p><strong>分组丢失</strong></p><p><strong>分组失序</strong></p><p><strong>分组重复</strong></p><p><strong>再次作证了可靠传输服务</strong>，<strong>不仅仅存在于数据链路层</strong>，<strong>在各层中都可以实现</strong></p><h3 id="可靠传输的实现的机制"><a href="#可靠传输的实现的机制" class="headerlink" title="可靠传输的实现的机制"></a>可靠传输的实现的机制</h3><h4 id="停止等待协议（SW）"><a href="#停止等待协议（SW）" class="headerlink" title="停止等待协议（SW）"></a>停止等待协议（SW）</h4><p><strong>A方</strong>发送<strong>DATA分组</strong>给B方</p><p>B方检测<strong>DATA分组没有错误</strong>，返回发送一个<strong>ACK分组</strong>（表示接受成功）</p><p>A方接收到了ACK分组，OK，A方就可以呢<strong>继续发送下一个DATA分组</strong></p><p>当B方检测这个DATA分组<strong>有错误</strong>，丢掉，返回一个NAK分组（表示没有成功姐接受）</p><p>A方呢，重新再把这个DATA分组数据啊，再发送一次，直到呢B方返回一个ACK分组</p><p>图解：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718103620500.png" alt=""></p><p>诶那你就会有疑问了，如果出现A方发送的DATA数据丢失了呢，不就会出现B方什么也没收到，就什么也不返回，A方也不知道到底接没接收到，就一直处于等待接收方返回ACK/NAK的状态么。</p><p>出现这种情况，发送方内部启动个<strong>计时器</strong>，设定计时器的时间</p><p><strong>超时</strong>没收到返回分组，那我就<strong>重传</strong>原来的数据分组，这就是<strong>超时重传</strong>的概念</p><p>这个计时器的时间，一般大于发送往返的时间：图解如下</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718104421832.png" alt=""></p><p>然而呢，假设还有两种种情况：</p><p>就是出现：</p><ul><li><p>A方发送过去了，就是有点久<strong>超过了设定计时器定时 B方才接收到</strong> 或者 <strong>ACK回晚了</strong></p></li><li><p><strong>返回的ACK丢失了</strong>。</p></li></ul><p>出现这两种就会出现第二种解法：<strong>超时重传</strong>，但是啊，搞清楚了，B方式已经默认收到DATA 的，有A方又传了一个相同的DATA分组，这就是出现了<strong>分组重复</strong>的情况</p><p>这种情况需要发送方A在发送事给每个分组带上一个<strong>序号</strong>，接受方B接收该数据DATA0，检测该序号，与上一个DATA0<strong>分组序号相同</strong>就丢弃顺便返回一个ACK0（针对的DATA0的数据分组，注意啊：ACK也是需要编号的，否则依然会出现<strong>ACK重复混淆</strong> 的这种情况） ，A方就可以取消该DATA0分组的重传</p><p>继续发下一个DATA1（此时变为了1）返回的ACK1（也变为了1）</p><p>再下一个层就是为ACK0和DATA0，至此呢所有情况，都有了相应的应对方案。</p><p>上图：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718110752910.png" alt=""></p><p>值得一提的是：在PPP（点对点的信道物理链路层）中，发送时间，往返时间都是<strong>固定</strong>的，所以呢不用担心<strong>超时重传</strong>的问题，设不设定计时器重传时间，编不编号都无伤大雅，<del>除非有老鼠掐准点把你家电路吃了</del>，不过为了这个传输协议的鲁棒性，健壮型，加编号未尝不可</p><p><strong>但是在</strong>（实际的ISO协议）运输层中，这这额外的情况就很可能发生，设定往返超时的判断时间（<strong>重传时间</strong>）是需要<strong>谨慎确定</strong>的问题</p><p>注意：编号一个比特表示0/1就够了，停等协议是这样的</p><p><strong>SW协议的的信道利用率</strong></p><p>短距离，数据帧的长度低，信道利用率的能稍微高点</p><p>但实际上SW协议的新到利用率相当的低，有图可证</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220718134746790.png" alt=""></p><p>可以用公式来计算：</p><script type="math/tex; mode=display">U= \frac{T_D}{T_D+RTT+T_A}</script><p>RTT是往返时间，出现重传U还要降低</p><p>为此，如此低的信道利用率太浪费资源，就有了GBN和SR协议的解决方法</p><p><strong>SW协议也被称为 自动请求重传协议ARQ（Automatic Repeat reQuest)</strong></p><h4 id="回退N帧协议（GBN）"><a href="#回退N帧协议（GBN）" class="headerlink" title="回退N帧协议（GBN）"></a>回退N帧协议（GBN）</h4><p>那么，为了解决SW协议的信道利用率，就提出了回退N帧协议</p><p>那SW协议就就连续发多个分组，跟流水线一样</p><p>但是需要做出限制，限定了一个发送窗口，记为$W_T$</p><p>当取值等于1时，等于SW协议</p><p>取值等$1&lt;W_T&lt;=2^n-1$ </p><p>n为采用几个比特给分组编号</p><p>（如$W_T$大于上限，就会出现分组重复的差错）</p><p>我们也需要给接收方设定一个接受窗口$W_R$=1</p><p>接收方只能按序接收数据分组，当发送方每收到一个ACK就往前移动一个序号的发送窗口</p><p>图如下</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100250014.png" alt=""></p><p>如果每一个序号的分组都进行发送确认ACK，开销有点大，</p><p>可以只发送序号最大的ACK4（假设发送窗口为5，采用3比特进行编号）那么发送方就知道0~4的信号接收方已接受。</p><p>那么出现差错怎么办呢</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100449425.png" alt="image-20220719100449425"></p><p>就会将所有的发送全部丢弃，每丢弃一个数据分组，就发送一个ACK4,表示我只接受到了0到4的数据分组，之前的所有数据都没有成功接收，全部需要重发。</p><p>由此可见，在网络波动大时，新到的利用率跟SW协议差不了多少。</p><p><strong>总结：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719101040194.png" alt="image-20220719101040194"></p><p>我们可以看下题解析，巩固一下理解 </p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220719100136847.png" alt=""></p><p>同样是一种ARQ协议，当通信线路8太行时，信道利用率和SW协议差不多</p><h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p>是GBN的改进，本质呢依然是GBN，但是更改了接收方的接收窗口的尺寸$W_r$</p><p>发送窗口与接受窗口相等，依然是按序滑动窗口（不是算法的滑动窗口，但也差不多）</p><p>出现误码，两方的窗口都不会进行滑动，直到所有数据分组确认接受，</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720084751118.png" alt=""></p><p><strong>两者的尺寸问题：</strong></p><p>发送窗口：1&lt;$W_t$&lt;=$2^{n-1}$</p><p>接受窗口：1&lt;$W_r$&lt;=$W_t$</p><p>n为编号所使用的比特数</p><p><strong>总结：</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720085256472.png" alt=""></p><p>总的来说：只要理解SW（停止-等待）协议，可以发现GBN和SR都是基于SW的基础上加以改进的，理解起来都非常的容易</p><h2 id="点对点协议"><a href="#点对点协议" class="headerlink" title="点对点协议"></a>点对点协议</h2><p>点对点（ppp)协议：是目前使用最广泛的数据链路层协议，</p><p>也同时广泛应用于广域网之间的公用线路</p><p>对各种协议数据报的封装方法（封装成帧）</p><p><strong>链路控制协议LCP:</strong></p><p>用于建立，配置以及测试数据链路的链接</p><p><strong>一套网络控制协议NCPs ：</strong></p><p>其中的每一个协议支持不同的网络层协议</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720092649770.png" alt=""></p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720093302084.png" alt=""></p><h3 id="透明传输的实现"><a href="#透明传输的实现" class="headerlink" title="透明传输的实现"></a>透明传输的实现</h3><p>面对字节的异步传输链路：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094210308.png" alt=""></p><p>面对比特的同步传输链路：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094329746.png" alt=""></p><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094605294.png" alt=""></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720094946553.png" alt=""></p><p>静止状态，检测到载波（物理层提供的服务）建立物理层的链接，跳转到建立状态</p><p>建立状态，开始进行LCP配置</p><p>鉴别状态，根据LCP配置的鉴别协议选择是否鉴别，成功跳转到网络的NCP配置阶段，失败即终止</p><p>网络状态。进行NCP配置，链路两端互相发发送特定NCP分组，根据使用的控制协议比如 IP-CP协议，就发送IPCP 的配置模块（作用是分配IP地址），成功后跳转到打开状态</p><p>打开状态，表明可以进行数据通信，如果出现故障或者终止请求，跳转至终止状态</p><p>终止状态，检测到载波停止时回到静止状态。</p><h2 id="广播信道的数据链路层"><a href="#广播信道的数据链路层" class="headerlink" title="广播信道的数据链路层"></a>广播信道的数据链路层</h2><h3 id="共享式以太网"><a href="#共享式以太网" class="headerlink" title="共享式以太网"></a>共享式以太网</h3><p>接入控制与碰撞检测协议</p><p>共享信道，需要协调多个发送接受站点对一个传输媒体的占用</p><p>这里我们引入媒体接入控制的概念</p><p><img src="/home/icrad/.config/Typora/typora-user-images/image-20220720105614322.png" alt="image-20220720105614322"></p><p>我们需要大概了解静态划分信道与动态接入控制中的随机接入</p><h4 id="静态划分信道："><a href="#静态划分信道：" class="headerlink" title="静态划分信道："></a>静态划分信道：</h4><p>信道复用实现：</p><p><strong>频分复用FDM</strong>：</p><p>按照频率不同区分信道，复用器与分用器 是并行通信</p><p><strong>时分复用TDM：</strong></p><p>划分时间，设定不同的时隙，串行通信</p><p><strong>波分复用WDM：</strong></p><p>可以理解为光波的频分复用，光复用器与光分用器</p><p><strong>码分复用CDM：</strong></p><p>在同时同频带进行并行通信，根据的不同码型区分信道</p><p>我觉得挺有意思的，<del>是歪比巴卜加密通信</del>，其中有个概念叫码片（chip)：每一个比特时间再划分的M个端间隔间隔</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720112705746.png" alt=""></p><p>应用举例：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220720113025648.png" alt=""></p><p><strong>注意多址（MA）与复用的关系</strong>：</p><p>多址用与在动态的信道分配，固定的地址例如无线电则不需要多址，多址可以看成复用的应用</p><h4 id="随机接入协议："><a href="#随机接入协议：" class="headerlink" title="随机接入协议："></a>随机接入协议：</h4><p><strong>CSMA/CD协议：</strong></p><p>载波监听（<strong>C</strong>heck_<strong>S</strong>ign）: 监听信道否有载波</p><p>多址接入（<strong>M</strong>utli <strong>A</strong>ddress）：多个连接占在一条总线上，随机时间发送帧</p><p>碰撞检测（C D）：遇到碰撞，退避随机时间重新发送，强化碰撞（发送干扰信号，相当于放大碰撞）</p><p>关键概念：</p><p>争用期：争用期时间指的是，不会超过端到端往返时间时延的时间。</p><p><strong>注意：</strong>共享式以太网不能链接太多的主机，使用的总线也不能太长。</p><p>最小帧长：以太网规定最喜小帧长为64字节，即521比特（512比特时间为争用期）</p><p>作用是保证能在帧发送完成之前能检测到是否发生碰撞。</p><p>最大帧长：<br>以太网V2的MAC帧最大长度1518字节加上帧头与帧尾</p><p>帧的发送流程：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721155821739.png" alt=""></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721155917409.png" alt=""></p><h3 id="802-11局域网（Wlan）"><a href="#802-11局域网（Wlan）" class="headerlink" title="802.11局域网（Wlan）"></a>802.11局域网（Wlan）</h3><p><strong>CSMA/CA协议：</strong></p><p>应用于无线局域网的多址碰撞检测</p><p>CA（碰撞避免）</p><p>是重点，也是核心，无线信道，想要检测道碰撞，成本太高了</p><p>所以呢提出了新的概念，也就是CA；</p><p>CA中利用了SW协议，在尽量避免碰撞，又提出了虚拟载波监听（数据帧中也携带通信的需要时间），与信道预约（RTS与CTS帧（这两个帧携带通信需要时间）</p><p>看到这是不是觉得非常敷衍，是的，我开始摆烂了，记几个概念得了，再深入，就不止是考研的范畴了。</p><h2 id="数据链路层的互连设备"><a href="#数据链路层的互连设备" class="headerlink" title="数据链路层的互连设备"></a>数据链路层的互连设备</h2><h3 id="前置概念："><a href="#前置概念：" class="headerlink" title="前置概念："></a>前置概念：</h3><p>首先在研究互联设备之前，我们需要清楚三个概念：</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC是以太网的MAC子层所使用的地址(物理链路层)</p><p>以太网帧的结构</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220726155123275.png" alt=""></p><p>ppp信道不需要使用地址（因为只有两者）</p><p>帧里必须携带发送朱局和接收主机的地址，由于这类地址是通榆媒体介入控制</p><p>，因此这类地址被称为MAC地址</p><p>MAC 地址一般放在网卡的EEPROM中，也被称为硬件（物理）地址</p><p>注意（并非叫物理就是物理层的内容）</p><p>各种硬件接口都有MAC地址，所以</p><p><strong>严格来讲：MAC 地址是网络上各接口的唯一标识，而不是对网络上各设备的唯一标识</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721164243056.png" alt=""></p><p>48个字节，好像有几百亿的地址，起码用到2080年才用得完</p><p>我们通过MAC地址了解厂商信息；</p><p>也可以了解到MAC也有四种：</p><ul><li><p>全球：</p><ul><li>单播地址</li><li>多播地址</li></ul></li><li><p>本地（优先级最高）</p><ul><li>单播地址</li><li>多播地址</li></ul></li></ul><p>单播地址 应用于1对1设备</p><p>多播地址 应用于是以1 对多设备</p><h4 id="IP地址（网络层）"><a href="#IP地址（网络层）" class="headerlink" title="IP地址（网络层）"></a>IP地址（网络层）</h4><p>IP是TCP/IP体系结构网际层所使用的地址：</p><p>应用：因特网上的主机和路由器所使用的地址</p><p>注意这只是大概应用图：（具体实现在网络层中）</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721170406278.png" alt=""></p><h4 id="ARP协议（网络层）"><a href="#ARP协议（网络层）" class="headerlink" title="ARP协议（网络层）"></a>ARP协议（网络层）</h4><p>ARP协议是属于TCP/IP的东西，能将IP地址解析下一个路由或者设备的相应MAC地址并在数据链路中重新封装</p><p>ARP（Address 解析 协议）高速缓存表：</p><p>用来存储的东西</p><p><strong>注意一下arp报文都是封装在MAC帧当中的</strong></p><p>在数据链路层，向所有主机发送ARP请求报文</p><p>根据其中请求的ARP请求报文检验啊，是否是来请求自己的，如果不是，就丢掉</p><p>如果是，交给上层网络层ARP进程 解析 先记录请求报文的主机IP与MAC 地址于自己的ARP高速缓存表中：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721172516670.png" alt=""></p><p>然后向下 数据链路层 再向发送请求的主机，一个ARP响应报文，其中包含自己的MAC 与ip地址，</p><p>收到了ARP响应报文，网络层的ARP进程进行解析，然后记录到自身的ARP告诉缓存表</p><p>注意不能跨网络使用</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721173048276.png" alt=""></p><p>注意了：</p><p>ARP还有其他报文，比如，免费报文（用来检测IP是否冲突）</p><p>ARP协议没有安全验证机制，有写人就会利用ARP进行攻击，ARP欺骗等问题</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><ul><li>物理层中工作</li><li>仍是一个总线网，各站点共享总线资源，使用的还是CSMA/CD协议</li><li>又少量的容错和网络管理</li><li>集线器在物理层扩展以太网</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721174048318.png" alt=""></p><h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721174853814.png" alt=""></p><ul><li>其中的存储转发：就是交换机内的数据链路层的帧号的缓存存储，再根据表转发</li><li>而直通交换，不需要检测 就是帧容易出错</li></ul><p>总结集线器与交换机双方对比：</p><p>一张图足矣</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721175546494.png" alt=""></p><p>所以，碰撞这一块。。。CSMA/CD /CA 协议</p><p>我之前如果只学交换机是不是完全不需要考虑总线碰撞的问题呢？<del>MD，白学了</del></p><h4 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220721194240363.png" alt=""></p><p><strong>总结：</strong></p><p>登记遍历，无泛洪，有转发</p><h4 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h4><p>为了在给交换机增加冗余链路 ，增加可靠性的同时，不会出现网络环路（类似C++的头文件循环包含问题），网络环路带来的问题就是容易出现广播风暴（广播帧会多次转发，导致交换机堵塞，瘫痪）</p><p>需要用到一个算法协议STP生成树协议，这玩意，能将拓扑结构网络中不需要转发的窗口阻塞禁用，从而阻止广播风暴的问题</p><p>具体就是使用STP协议请移步这篇文章</p><h3 id="VLAN（虚拟局域网）"><a href="#VLAN（虚拟局域网）" class="headerlink" title="VLAN（虚拟局域网）"></a>VLAN（虚拟局域网）</h3><p>由于网络中会频繁出现广播信息，然而纯交换机组成的以太网会组成一个非常大的广播域，如果在这个广播域中，出现广播风暴，那是相当浪费网络资源和CPU的。</p><p><del>就是又STP协议也不顶用啊</del></p><p>所以，就需要有一个能够将广播域分割的方法</p><p>这就不得不拿出路由器了</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722083808830.png" alt=""></p><p>可是，这玩意的成本很高（相对于集线器与交换机而言），虽然也不是很高了现在，但也不能每两交换机之间就用一个罢，咱有钱也不能这么造不是？</p><p>这时，为了省钱呢，虚拟局域网VLAN诞生啦</p><p>这玩意概念上是</p><p><strong>将一个局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</strong></p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p><strong>IEEE 802.1Q帧（Dot One Q帧）</strong></p><p>是交换机在收到普通帧时的在扩展，插入了一个4字节的VLAN标记<img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722084927719.png" alt=""></p><ul><li>VLAN标记的最后12比特 成为VLAN标识符VID ，唯一地标志了以太网帧属于哪一个VLAN<ul><li>VID取值范围是0~4095( 0~$2^{12}-1$)</li><li>0和4095不表示VLAN，因此用于表示VLAN的VID取值也就是1~4094</li></ul></li><li><strong>注意</strong>这个帧是交换机来处理的，不是用户主机处理：<ul><li>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记，俗称打标签</li><li>转发的时候，按需求取掉或者保留标签转发</li></ul></li></ul><p>以上是</p><p><strong>交换机各端口的缺省VLAN ID</strong></p><ul><li>在思科交换机称为Native VLAN,即本征VLAN</li><li>在华为交换机上称为Port VLAN ID ，即端口VLAN ID ,简记为PVID（唯一的）。</li></ul><p><strong>注意：接下来我们讨论的是PVID</strong></p><p><strong>交换机端口类型</strong></p><ul><li><strong>Access</strong><ul><li>一般用于连接用户计算机</li><li>只能属于一个VLAN</li><li>PVID值与端口所属的VLAN的ID相同（默认为1）</li></ul></li></ul><p>接收：一般只接受未打标签的普通帧，再根据接受真的端口的PVID给帧打标签，字段中的VID 取值与PVID取值相等。</p><p>转发：检查帧中的VID与端口的PVID相等，则去标签，转发，否则就不转发。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722091128900.png" alt=""></p><ul><li><strong>Trunk</strong><ul><li>交换机之间或者交换机与路由器的互联</li><li>可以属于多个VLAN</li><li>用户可以设置端口的PVID值，默认为1.</li></ul></li></ul><p><strong>发送第一种情况</strong>：检测VID与PVID相等的帧，打标签，再转发</p><p><strong>接受第一种情况</strong>：接受到一个<strong>未打标签</strong>的帧，根据<strong>接收帧的端口PVID</strong>给帧打标签</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722091938090.png" alt=""></p><p><strong>发送第二种情况</strong>：接受一有标签但是PVID不等VID的帧，直接转发</p><p><strong>接受第二种情况</strong>：接受到一个打标签的帧，我直接带着标签转发</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722092327523.png" alt=""></p><ul><li><strong>Hybrid(思科没有)</strong></li></ul><p>同时具有Access与Trunk的特性：</p><p>端口可以互连：用户主机与交换机，交换机交换机，用户与用户</p><p>不同的地方在于：端口多了个 去标签白名单</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220722093740897.png" alt=""></p><p>至此，数据链路层的内容结束</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第二节|物理层</title>
      <link href="/2022/07/17/internet02/"/>
      <url>/2022/07/17/internet02/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章了解个概念，不深究，比较抽象</p><span id="more"></span><h2 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h2><p><strong>明确：考虑怎么链接各种计算机之间传输比特流数据</strong></p><p>四个特性</p><ul><li><p>机械</p><p>接口类型</p></li><li><p>电气</p><p>电压</p></li><li><p>功能</p><p>传输1/0编码</p></li><li><p>过程</p><p>时种顺序</p></li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><p>注意传输介质实际上不属于物理层</p><h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul><li><strong>双绞线</strong></li></ul><p>两根，按一定规则双绞，抗干扰</p><ul><li><p><strong>同轴电缆</strong></p></li><li><p><strong>光纤</strong></p><ul><li><p>单模光纤：波导,就是贵，对光信号要求高</p></li><li><p>多模光纤：全反射</p><p>优点：带宽大,损耗低</p></li></ul></li><li><p><strong>电力线</strong></p><p>适合短距离</p></li></ul><h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><p>(自由空间)</p><ul><li><strong>微波</strong></li></ul><p>直线，电离层无折射，需要中继站，典型5G通信</p><ul><li><strong>无线电波</strong></li></ul><p>电离层折射，距离远</p><ul><li><strong>可见光</strong></li></ul><p>应用：lifi</p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>一条数据传输线路</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>多条数据传输线路</p><p><strong>计算机内部常用并行传输</strong></p><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><h4 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h4><p>连续无间隔</p><p><strong>外同步</strong></p><p>多加一条单独的时钟信号线</p><p><strong>内同步</strong></p><p>市中心号线与发送数据曼彻斯特编码</p><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>异步的体现：字节之间的时间间隔不固定</p><p>需要字节需要加上起始位和结束位</p><p>但各比特的持续时间是相同的</p><p>字节异步，比特同步</p><h3 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h3><p>单向</p><h3 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h3><p>双向不同时</p><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>同时双向</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p>关于编码与调制我们需要了解：</p><p>信息-&gt;数据（二进制）-&gt;信号（电磁表现）</p><p>数字基带信号的数字</p><p>模拟基带信号</p><p>两者都有编码和调制</p><h3 id="数字基带信号"><a href="#数字基带信号" class="headerlink" title="数字基带信号"></a>数字基带信号</h3><p>编码（数字信号转化数字信号）：以太网下的曼彻斯特编码，4B/5B 走的是数字信道</p><p>调制（数字信号转化模拟信号）：WIFI CCK/DSS/OFDM调制，走的是模拟信道</p><h3 id="模拟基带信号"><a href="#模拟基带信号" class="headerlink" title="模拟基带信号"></a>模拟基带信号</h3><p>编码（数字信号转化数字信号）：音频信号的PCM脉码调制，走的是数字信道</p><p>调制（数字信号转化模拟信号）：FDM频分复用，充分利用带宽资源，走的是模拟信道</p><p><del>啊~这熟悉又陌生的的名词</del></p><p><strong>注意</strong></p><p>传输媒体不等于信道</p><p>不同的传输媒体，包含多个不同数量的信道</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h4><p>自同步，编码效率低，需要归零</p><h4 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h4><p>需要多一条信道传输时钟信号，这玩意不能用来传递时钟信号</p><h4 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h4><p>码元为单位，以中间的信号跳变表示0/1</p><p>跳变有表示时钟，又表示数据</p><p>（是传统以太网10Mb/s）</p><h4 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h4><p>跳变只表示时钟</p><p>码元开始处 的电平是否发生变化表示数据，</p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字基带信号</p><p>频率，振幅，相位</p><h4 id="二元调制："><a href="#二元调制：" class="headerlink" title="二元调制："></a>二元调制：</h4><p>只有<strong>两种</strong>码元</p><p><strong>调幅AM</strong></p><p><strong>调频FM</strong></p><p><strong>调相PM</strong></p><p>调频和调相<strong>不能一块调</strong>，调幅调相可以同时，或者调频调幅</p><h4 id="混合调制："><a href="#混合调制：" class="headerlink" title="混合调制："></a>混合调制：</h4><p><strong>调频和调相混合</strong></p><p>至少可以有<strong>四种</strong>码元，若是有4个相位，4种振幅，可以调出16个不同的波形，也就是码元</p><p>我们再以二进制处理这16种码元</p><script type="math/tex; mode=display">log_216=4</script><p>可以算出每个码元所还能携带的信息量为4比特</p><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p><strong>奈氏准则</strong>，假定的理想条件下，避免码间串扰，码元的传输速率是有上限的</p><p>不考虑信噪比</p><p>理想低通信道的最高码元传输速率=2W Baud= 2W(单位：码元/s)</p><p>理想带通信道的组稿码元传输速率=W Baud= W（单位：码元/s）</p><p>W指的是，信道带宽hz</p><p>那么要考虑噪声，引出<strong>香农公式</strong></p><p>带宽受限 且高斯白噪声干扰的信道的极限信息的传输效率</p><script type="math/tex; mode=display">c=W*log_2(1+\frac{S}{N})~~~~（单位：bit/s）</script><p>综上奈氏准则和香农公式，要想<strong>提高信息的传输速率</strong>就必须用<strong>多元</strong>制的调制方式，努力提高<strong>信道中的信噪比</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思维导图：不着急，躺平摸鱼</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础，物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础|第一节</title>
      <link href="/2022/07/15/Internet01/"/>
      <url>/2022/07/15/Internet01/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络基础-第一节"><a href="#计算机网络基础-第一节" class="headerlink" title="计算机网络基础|第一节"></a>计算机网络基础|第一节</h1><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/728da9773912b31bad1719cedfd48473dbb4e130.png" alt="img"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学校网课不努力，B站大学再继续。实在努力不下去，美团饿么当兄弟。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/9bb444786eaac9678f1b8574db28d03b69cef878.jpg@942w_942h_progressive.webp" alt="img"></p><span id="more"></span><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p>两个以上主机可发送接受信息的互连的，可自治的，组成计算机网络</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="常用以下8个"><a href="#常用以下8个" class="headerlink" title="常用以下8个"></a>常用以下8个</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h4><p><strong>比特 bit 数据量单位</strong></p><p>代表：一个数0/1</p><p>字节=B</p><p>8bit=1B;</p><p>注意：<strong>依次乘与2的10次方</strong></p><p><strong>K-&gt;M-&gt;G-&gt;T</strong></p><p>举个例子</p><p>我们购买的硬盘，商家标的是250GB为什么在操作系统中却只有232.8GB呢</p><p>我们看下面的一个公式：</p><script type="math/tex; mode=display">\frac{250*10^{9} } {2^{30} }=232.8（GB）</script><p>商家的计算方式是G 为10的9次方，操作系统中数据量的G 是2的30次方</p><p><strong>比特率</strong>速率单位 bit/s</p><p>注意：<strong>依次乘与10的3次方</strong></p><p><strong>k-&gt;M-&gt;G-&gt;T</strong></p><p><strong>与数据量不同</strong></p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h4><p>在<strong>模拟信号</strong>中 ：单位<strong>Hz</strong></p><p>表达的是信号频率范围</p><p>在<strong>计算机网络</strong>中：</p><p>可以理解为网络中点到点传输的 最高数据率</p><p>单位b/s与比特率相同</p><p>这两者其实表述都是有联系的，带宽频率越宽，网络越好</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图50.png" alt=""></p><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3.吞吐量"></a>3.吞吐量</h4><p>单位时间通过的数据量</p><p>受到带宽限制</p><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><p>总的来说就是传输数据的时间</p><p>可以细分为：</p><p>网络时延：发送，传播，处理</p><ul><li>发送时延：分组长度/发送速率</li></ul><ul><li><p>传播时延</p><p>计算是有公式的</p><p>信道长度/电磁波传播速率 </p><p>然而在不同的传输介质中传播速率是不同的</p><p>这里列出3个不同的常见的传播介质</p><ul><li>光纤</li><li>忘了</li><li>是啥来着？</li></ul></li><li><p>处理时延：不方便计算</p></li></ul><h4 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h4><p>传播时延乘与带宽的乘积</p><p><img src="/home/icrad/图片/截图/截图 2022-07-15 19-11-41.png" alt=""></p><p>链路的时延带宽积又称为以比特为单位的链路长度</p><h4 id="6-往返时间"><a href="#6-往返时间" class="headerlink" title="6.往返时间"></a>6.往返时间</h4><p>数据双向交互一次的时间</p><p>我们简称为<strong>RTT(Round-Trip Time)</strong></p><h4 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h4><ul><li><p>信道利用率：有百分之几的时间是被利用的</p></li><li><p>网络利用率：全网络的信道利用率的加权平均。</p></li></ul><p>根据排队论，信道的利用率增大时，该信道引起的时延也会迅速增加</p><p>因此信道利用率并非越高越好</p><p>如果令<script type="math/tex">D_0</script>表示为网络空闲的时延，D表示当前的时延，那么在适当的假定条件下，可以用以下的简单公式来表示D与<script type="math/tex">D_0</script>和利用率U之间的关系</p><script type="math/tex; mode=display">D=\frac{D_0} {1-U}</script><ul><li>当网络的利用率达到50%时，时延加倍</li><li>当利用率超过50%时，时延急剧增大</li><li>当网络利用率接近100%时，时延趋于无穷大</li><li>依次一些拥有交大主干网的ISP通常会控制他们的新到利用率不超过50%,如果超过了，就扩容，增加带宽。</li><li><strong>注意</strong>：也不能太低，浪费了宝贵的通信资源，设定一个程序机制来根据情况动态调整网络中的通信量，是网络利用率保持在一个合理的范围内</li></ul><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><p>即分组的丢失率</p><ul><li>一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li><li>可以分为接口丢包率，结点丢包率，链路丢包率，路径丢包率，网络丢包率等</li></ul><p>分组丢失主要有两种情况：</p><ul><li><p>分组在传输的过程中，出现误码，被结点丢弃；</p></li><li><p>分组到达一台队列已满的分组交换机时被丢弃；在通信量较大是就可能造成网络拥塞</p></li><li><p>因此 丢包率也可以反应网络的拥塞情况</p><ul><li><p>无拥塞时路径丢包率为0；</p></li><li><p>轻度拥塞时路径丢包率为1%~4%</p></li></ul></li></ul><ul><li>严重时可达到5%~15%</li></ul><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p>有三种常见的计算机网络体系结构</p><ul><li><p><strong>法律上的国际标准(OSI)</strong></p><p>有七层：我不考研简单知道一下就够了，实际上开发不会用到这个框架</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图414.png" alt=""></p></li><li><p><strong>实际上的国际标准(TCP/IP)</strong></p><p>表明了各种层的协议</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图.png" alt=""></p></li><li><p><strong>原理体系结构（在学习中我们主要遵循的）</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图54.png" alt=""></p></li></ul><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>分层的思想：以大化小，以小化了</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>需要解决：</p><ul><li><p>传输介质</p></li><li><p>物理接口</p></li><li><p>什么信号</p></li></ul><p>严格来说：传输媒体并不属于物理层</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>需要解决：</p><ul><li>目的主机该如何标识（主机编址）</li><li>目的主机识别出力分组数据的封装</li><li>协调多个主机之间的数据交换（一个网络或一段链路）</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>需要解决：</p><ul><li>网络以及网络中的各主机的共同编址问题（多个网络（路由））</li><li>路由器该怎么转发分组，路由的选择</li></ul><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>需要解决：</p><ul><li>不同网络应用进程之间的通信(<strong>端到端</strong>的逻辑通信，不是端口到端口)</li><li>出错与异常的解决（丢包，误码等）</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>需要解决：</p><ul><li>不同网络进城程间的通信的基础上，规定特定的技术协议运用</li></ul><h3 id="分层的思想示例"><a href="#分层的思想示例" class="headerlink" title="分层的思想示例"></a>分层的思想示例</h3><p>简单的图解（图片来源湖南科技大学课程）：<br><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图2022-07-1623.png" alt=""></p><p>可以简单理解为：邮件的传输</p><p>个人主机：</p><ul><li><p>首先在<strong>应用层</strong>我们写了一个信件（<strong>报文</strong>） 内容规则可以是http，FTP，我们放在了自家的邮寄箱中 </p><p>这个时候来了个小哥来拿，他根据你在的地方，寄的信件内容类型呢，加了个邮局分局的地址等一系列信息，进行了一个简单的包装</p><p>（<strong>运输层</strong>根据tcp协议的规定 添加端口等一系列信息的<strong>TCP首部</strong>，成了一个<strong>TCP报文段</strong>）</p></li><li><p>拿到了你这个地区的邮局站，根据你要寄的地址分号码分类</p><p>（<strong>网络层</strong>加了个<strong>IP首部</strong>，成为了一个<strong>IP数据报</strong>）</p></li><li><p>然后根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>（<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p></li></ul><p>（帧交给物理层，加了个前导码，目的是为了让目的主机做好帧接受的准备）</p><p>​    </p><p>通过链路到达了另外一个邮寄站点（路由） </p><ul><li><p>物理层将信件货物拆解，去掉上一个标签</p><p>（比特流化为帧）</p></li><li><p>再将其交付给处理信件地址的网络层解析（提取查找路由表，确定转发端口 指定下一个路由或者地址）</p></li><li><p>再重新根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>(<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p><p>（<strong>帧</strong>交给<strong>物理层</strong>，加了个<strong>前导码</strong>，目的是为了让目的主机做好帧接受的准备）</p></li></ul><p>  以下内容都是同理</p><p>  （重复解析封装一发送）</p><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>任何可发送或接受信息的硬件或者软件进城</p><h4 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h4><p>相同层次中的实体</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120751857.png" alt=""></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>控制两个对等实体进行逻辑通信的规则的集合</p><p>注意：<strong>逻辑通信</strong>，的意思是，这个通信的的规则不是存在的，是假设的一种通信，单独简化研究，同理逻辑接口</p><p>三要素：</p><ul><li>语法：定义交换信息的格式（各种分组格式http ftp等）</li><li>语义：定义通信双方所要完成的操作</li><li>同步：定义收发双方的时序关系（<strong>三次握手</strong>）</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120824649.png" alt=""></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>协议的控制下，<strong>对等实体</strong>的逻辑通信向上层提供服务</p><p>实现本层的协议需要，使用下面一层所提供的服务</p><p>协议是<strong>水平</strong>的，服务是<strong>垂直</strong>的</p><ul><li><p>服务访问点：相邻两层的逻辑接口，用于交换两层之间的是实体信息，区分不同的服务类型</p><ul><li>数据链路层的服务访问点为帧的<strong>类型字段</strong></li><li>网络层的服务访问点为ip数据报首部的<strong>协议字段</strong></li><li>运输层的服务访问点为<strong>端口号</strong></li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120844704.png" alt=""></li></ul></li></ul><p>  <strong>协议数据单元</strong></p><p>  PDU：对等层次之间传送的数据包称为该层的协议数据单元</p><p>  SDU：同一系统系统内服务数据单元 层与层之间交换的数据包成为服务数据单元</p><p>  多个SDU 可以合成为一个PDU</p><p>  一个SDU 也 可以分为多个PDU </p><p>  比特-&gt;帧-&gt;ip数据段-&gt;tcp/udp数据报-&gt;报文</p><p>  <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/截图27.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不着急写，<del>随便做个思维导图糊弄一下</del></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB基础</title>
      <link href="/2022/07/14/GDB/"/>
      <url>/2022/07/14/GDB/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB的调试"><a href="#GDB的调试" class="headerlink" title="GDB的调试"></a>GDB的调试</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gdb.jpg" alt=""></p><p><strong>GDB (GUN DEBUGGER)</strong></p><ol><li><p>设置断点</p></li><li><p>单步运行</p></li><li><p>查看变量值</p></li><li><p>动态改变执行环境</p></li><li><p>分析崩溃产生core文件</p><span id="more"></span></li></ol><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g test.cpp -o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#生成可调试的执行文件</span></span><br></pre></td></tr></table></figure><h3 id="GDB-常用指令"><a href="#GDB-常用指令" class="headerlink" title="GDB 常用指令"></a>GDB 常用指令</h3><p>​    说多也不多，毕竟现在调试大多都是gui调试，暂时很少直接用gdb命令行进行调试，写几个比较基础的<del>糊弄糊弄，就记住几个</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gdb [file]</span><br><span class="line"><span class="comment">#执行gdb调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入gdb，可以直接输入命令</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span>(b) [num]</span><br><span class="line"><span class="comment">#在第num行代码设置断电</span></span><br><span class="line"></span><br><span class="line">info breakpoint </span><br><span class="line"><span class="comment">#查看当前代码信息</span></span><br><span class="line"></span><br><span class="line">display [变量]</span><br><span class="line"><span class="comment">#显示变量，在每次运行到断点显示值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line"><span class="comment">#继续运行</span></span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"><span class="comment">#运行程序</span></span><br><span class="line"></span><br><span class="line">quit</span><br><span class="line"><span class="comment">#退出GDB调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#更多的我也记不到了，用man gdb指令查吧</span></span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>程序出现段错误时，GDB打开可调试的执行文件，直接运行，程序停止位置表示段错误的位置</p>]]></content>
      
      
      <categories>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
            <tag> C++ </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G++基础</title>
      <link href="/2022/07/14/Gcc/"/>
      <url>/2022/07/14/Gcc/</url>
      
        <content type="html"><![CDATA[<h2 id="G-GCC基础"><a href="#G-GCC基础" class="headerlink" title="G++/GCC基础"></a>G++/GCC基础</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gcc.png" alt=""></p><h3 id="编译过程有四步"><a href="#编译过程有四步" class="headerlink" title="编译过程有四步"></a>编译过程有四步</h3><span id="more"></span><ol><li><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp -o test.i</span><br><span class="line"><span class="comment">#预处理为.i文件</span></span><br><span class="line"><span class="comment">#头文件啥的的预定义啥的</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.i -o test.s</span><br><span class="line"><span class="comment">#编译为汇编语言输出为.s文件</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c test.s -o test.o</span><br><span class="line"><span class="comment">#编译为机器语言输出为.o</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ test.o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#生成为可执行文件test，二进制的文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="GCC-G-的优化选项"><a href="#GCC-G-的优化选项" class="headerlink" title="GCC/G++的优化选项"></a>GCC/G++的优化选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本优化</span></span><br><span class="line">-O </span><br><span class="line"><span class="comment">#等效O1</span></span><br><span class="line">-O0</span><br><span class="line"><span class="comment">#不做优化</span></span><br><span class="line">-O1</span><br><span class="line"><span class="comment">#为默认优化</span></span><br><span class="line">-O2</span><br><span class="line"><span class="comment">#默认优化+额外的调整</span></span><br><span class="line">-O3</span><br><span class="line"><span class="comment">#默认优化+额外的调整+循环展开等处理特性的优化</span></span><br><span class="line"></span><br><span class="line">g++ test.cpp -O2 -o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#优化等级2生成可执行文件test</span></span><br></pre></td></tr></table></figure><p>所谓优化就是提升效率，编译时间换取执行效率</p><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span><span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> result;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> temp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> five;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有很多计算步骤都都在循环条件里</span></span><br><span class="line"><span class="keyword">for</span>(counter=<span class="number">0</span>;counter&lt;<span class="number">2000</span>*<span class="number">2000</span>*<span class="number">100</span>/<span class="number">4</span>+<span class="number">2010</span>;counter+=(<span class="number">10</span><span class="number">-6</span>)/<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">temp+=counter/<span class="number">1979</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">five=<span class="number">200</span>*<span class="number">200</span>/<span class="number">8000</span>;</span><br><span class="line">result=counter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;result=&quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试优化O2与不优化O0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -O2 -o Youhua</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -O0 -o NotYouhua</span><br></pre></td></tr></table></figure><p>再依次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time ./Youhua</span><br><span class="line">time ./NotYouhua</span><br></pre></td></tr></table></figure><p>可以看见优化后的执行效率相当高</p><h3 id="指定库文件与头文件"><a href="#指定库文件与头文件" class="headerlink" title="指定库文件与头文件"></a>指定库文件与头文件</h3><p>库的指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ -lglog test.cpp</span><br><span class="line"><span class="comment">#链接golg 库</span></span><br><span class="line"></span><br><span class="line">g++ -L/home/icrad/mylibfolder -lmylib test.cpp</span><br><span class="line"><span class="comment">#链接自己的指定的库文件夹下的库文件，需要大写</span></span><br></pre></td></tr></table></figure><p>头文件的指定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般来说，是不需要指定的，GCC默认去找include文件夹，当不存在时，就需要自己指定了头文件目录了</span></span><br><span class="line"></span><br><span class="line">g++ -I/myinclude test.cpp</span><br></pre></td></tr></table></figure><h3 id="基本常用的其他项"><a href="#基本常用的其他项" class="headerlink" title="基本常用的其他项"></a>基本常用的其他项</h3><ul><li><p>-Wall</p><p>打印警告信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Wall test.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-w</p><p>关闭警告信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -W test.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-std=c++11</p><p>指定C++ 特性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 test.cpp</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-o</p><p>编译输出可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-D</p><p>定义宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用场景，可以在编译的时候选择是否 执行宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;DEBUG_LOG&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Ubuntu,yes!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译这个文件时可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -DDEBUG test.cpp -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>生成的执行文件会将宏定义中的代码输出</p><p>如果没有定义宏，只会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu,yes!</span><br></pre></td></tr></table></figure></li></ul><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g test.cpp -o <span class="built_in">test</span></span><br><span class="line"><span class="comment">#生成可调试的执行文件</span></span><br></pre></td></tr></table></figure><h3 id="编译示例"><a href="#编译示例" class="headerlink" title="编译示例"></a>编译示例</h3><h4 id="多文件夹的目录结构"><a href="#多文件夹的目录结构" class="headerlink" title="多文件夹的目录结构"></a>多文件夹的目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── include</span><br><span class="line">│   └── swap.h</span><br><span class="line">├── math.cpp</span><br><span class="line">└── src</span><br><span class="line">    └── swap.cpp</span><br></pre></td></tr></table></figure><ul><li><h4 id="直接编译"><a href="#直接编译" class="headerlink" title="直接编译"></a>直接编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ math.cpp -std=c++11 src/swap.cpp -Iinclude</span><br><span class="line"><span class="comment">#记得引入头文件</span></span><br></pre></td></tr></table></figure><p>即可生成可执行文件a.out </p></li></ul><ul><li><h4 id="链接生成静态库"><a href="#链接生成静态库" class="headerlink" title="链接生成静态库"></a>链接生成静态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将src的文件夹下的swap.cpp生成为.o文件(汇编语言)</span></span><br><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line">g++ swap.cpp  -c -I../include</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行归档操作</span></span><br><span class="line">ar rs libswap.a swap.o</span><br><span class="line"><span class="comment">#作用是将swap.o归档为一个静态库文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..<span class="comment">#回到上级目录</span></span><br><span class="line">g++ math.cpp -lswap -Lsrc -I\include -o static_swap</span><br><span class="line"><span class="comment">#链接指定的静态库进行编译</span></span><br><span class="line"><span class="comment">#最终得到可执行文件static_swap</span></span><br></pre></td></tr></table></figure></li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><ul><li><h4 id="链接生成动态库"><a href="#链接生成动态库" class="headerlink" title="链接生成动态库"></a>链接生成动态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> src/</span><br><span class="line"></span><br><span class="line">g++ swap.cpp -I../include -fPIC -shared -o libswap.so</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line">gccswap.cpp -I../include -c -fPIC </span><br><span class="line"><span class="comment">#生成.o文件</span></span><br><span class="line">gcc -shared -o libswap.so swap.o</span><br><span class="line"><span class="comment">#生成静态库文件libswap.so</span></span><br><span class="line"></span><br><span class="line">回到上级目录</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">g++ math .cpp -Iinclude -lswap -Lsrc -o dyna_swap</span><br><span class="line"><span class="comment">#生成了可执行的文件dyna_swap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态库的可执行文件需要指定搜索路径</p><p>为什不直接设定系统的环境变量？避免与系统重复</p><p>第一种方法（临时测试用 ——推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH=src ./dyna_swap</span><br><span class="line"><span class="comment">#指定了动态库的搜索路径运行该可执行文件</span></span><br></pre></td></tr></table></figure><p>第二种方法：可以配置用户终端的环境变量（不推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改当前目录的bashrc文件</span><br><span class="line">再最后行加入动态库的路径</span><br><span class="line">LD_LIBRARY_PATH=</span><br></pre></td></tr></table></figure></li><li><p>第三种的方法（推荐）</p><ul><li><p>找到动态库连接器的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc</span><br><span class="line">sudo vi ld.so.conf</span><br></pre></td></tr></table></figure></li><li><p>将动态库的路径写到配置文件中，绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态库的路径</span><br></pre></td></tr></table></figure></li><li><p>更新 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig -v</span><br></pre></td></tr></table></figure><p>更新后就可以使用该链接动态库的程序的执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldd </span><br><span class="line"><span class="comment">#查看执行文件的动态库连接</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>静态库与静态库的区别：大小，前者更大，直接包含在执行文件中了，而动态库在调用相应函数时才会加载，所以在运行时，静态库不需要指定路径直接运行，而动态库需要。</p>]]></content>
      
      
      <categories>
          
          <category> GCC/G++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> G++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的更新与备份</title>
      <link href="/2022/07/14/blog/"/>
      <url>/2022/07/14/blog/</url>
      
        <content type="html"><![CDATA[<h2 id="博客的更新与备份"><a href="#博客的更新与备份" class="headerlink" title="博客的更新与备份"></a>博客的更新与备份</h2><p>基于hexo的博客，搭建在github的仓库中</p><p>我们要实现在不同的系统与电脑中进行修改，与同步</p><span id="more"></span><h3 id="需要以下条件"><a href="#需要以下条件" class="headerlink" title="需要以下条件"></a>需要以下条件</h3><ol><li>Nodes.js</li><li>npm</li><li>git</li><li>博客源文件已经部署在github的仓库中（建议部署在分支中）</li></ol><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><p>首先新系统下的git配置，关键点在于重新配置ssh密匙</p><p>其次是Nodes.js与npm需要最新版本（有多新装多新</p><h3 id="初始化另一台电脑的操作"><a href="#初始化另一台电脑的操作" class="headerlink" title="初始化另一台电脑的操作"></a>初始化另一台电脑的操作</h3><ol><li><p>git bash 将远程仓库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 博客所在仓库地址</span><br></pre></td></tr></table></figure></li><li><p>进入项目目录，安装依赖启动博客服务器，生成静态文件</p><p>并在本地部署，通过<a href="http://localhost:4000进行访问">http://localhost:4000进行访问</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">hexo g&amp;hexo s</span><br></pre></td></tr></table></figure></li><li><p>发布文章与之前相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo c&amp;hexo d -g</span><br></pre></td></tr></table></figure></li></ol><h3 id="另一台电脑同步"><a href="#另一台电脑同步" class="headerlink" title="另一台电脑同步"></a>另一台电脑同步</h3><p>​        在博客目录下执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>​        后执行更新原始文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull </span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;描述&quot;</span></span><br><span class="line">git push origin hexo </span><br></pre></td></tr></table></figure><p>​        每次有新的操作的时候，在另一台电脑上也同时进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull hexo <span class="comment">#拉取源文件</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的写一个makefile</title>
      <link href="/2022/07/14/makefile/"/>
      <url>/2022/07/14/makefile/</url>
      
        <content type="html"><![CDATA[<h3 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h3><p>什么是MakeFile？很好理解，是一种规则，什么规则呢？顾名思义：生成文件的规则</p><p>这是一条基本语法(伪代码)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">目标:依赖</span></span><br><span class="line">依赖操作成为目标的指令</span><br></pre></td></tr></table></figure><p>三个要素：</p><ul><li>目标<ul><li>需要的结果</li></ul></li><li>依赖<ul><li>执行中需要的文件</li></ul></li><li>指令<ul><li>执行的操作代码</li></ul></li></ul><p> make指令执行的顺序模式是：自顶向下，典型的树状结构</p><p>可以理解为，执行最顶部的目标生成规则，根据当前目标所需的依赖向下查找依赖的生成规则。</p><p>最终目标生成规则一般都写在最上方，第一条</p><p>简单看一个简单的makefiiewe文件的简单编写伪代码</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>makeFile文件的简单的编写格式如下</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  target=最终文件名</span><br><span class="line">  </span><br><span class="line">  obj=子文件1 子文件2 子文件3 ....</span><br><span class="line">  </span><br><span class="line">    <span class="variable">$(target)</span>：<span class="variable">$(obj)</span></span><br><span class="line">     具体操作命令</span><br><span class="line">   子文件%：源文件%</span><br><span class="line">     具体操作命令</span><br><span class="line">     ....</span><br><span class="line">     .PHONY:clean</span><br><span class="line">     clean:</span><br><span class="line">     -rm</span><br><span class="line">rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br><span class="line"><span class="comment">#-f 强制执行</span></span><br></pre></td></tr></table></figure><h4 id="需要注意的"><a href="#需要注意的" class="headerlink" title="需要注意的"></a>需要注意的</h4><p>  自动变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&lt;</span>：规则中的第一个依赖(就是子文件1)</span><br><span class="line"><span class="variable">$@</span>：当前规则中的目标</span><br></pre></td></tr></table></figure><p>每次生成的会对子依赖进行检查是否有修改</p><p>函数的使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">指定目录下的所有.c文件</span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> ./%.o, ./%.c, $(<span class="built_in">wildcard</span> ./*.c)</span>)</span><br><span class="line">将的所有.o 字符 替换为.c </span><br></pre></td></tr></table></figure><p>删除之前生成的子文件，因为不是我们的最终目标，是临时的文件，需要手动删除那不如加条目标指令进行删除。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span> -f</span><br><span class="line"><span class="comment">#-f 强制执行</span></span><br></pre></td></tr></table></figure><p>makefile加入该删除代码后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line"><span class="comment">#只执行clean</span></span><br></pre></td></tr></table></figure><p>举例验证：加入一个hello目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:</span></span><br><span class="line">echo <span class="string">&quot;hello,makefile!&quot;</span></span><br></pre></td></tr></table></figure><p>在终端执行:就会只执行hello目标的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make hello</span><br></pre></td></tr></table></figure><p>将目标声明为伪目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> .PHONY:clean</span><br><span class="line"><span class="comment">#就不回再重复比较文件，默认执行该目标操作</span></span><br></pre></td></tr></table></figure><p>而加入-rm的作用是</p><p>当出现报错无法执行是，忽略该报错执行下一条命令语句</p><p>还有更多函数和编写细节，用到了的时候再说罢。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>给我的感觉就是一个类脚本的语言，可以将不止是 C++ or JAVA 或者其他语言的项目，集成方便的进行编译的或者其他操作，挺有意思的.</p>]]></content>
      
      
      <categories>
          
          <category> makefile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake基础</title>
      <link href="/2022/07/12/cmake01/"/>
      <url>/2022/07/12/cmake01/</url>
      
        <content type="html"><![CDATA[<h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a><a href="">Cmake</a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux下cmake编译工具使用过程与windows的操作大同小异</p><p>单独开一篇文章对指令基础做个总结</p><span id="more"></span><h3 id="Corss-platform-development"><a href="#Corss-platform-development" class="headerlink" title="Corss-platform development"></a>Corss-platform development</h3><p>跨平台：毕竟做linux下的c++ 开发不用cmake 可不行,总不能徒手写makefile文件罢,利用cmake生成的makefile也相当块。</p><h3 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h3><p>指令格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令（参数1 参数2）</span><br></pre></td></tr></table></figure><p>不同参数需要用<strong>空格</strong>或者<strong>分号</strong>隔开</p><p>指令无关大小写，<strong>参数</strong>和<strong>变量</strong>是大小写<strong>相关</strong>的</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ul><li><p><strong>cmake_minimum_required</strong>:指定cmake版本</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cmake_minimum_required -指定cmake的最小版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>project</strong>:定义工程名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定 project(projectname [CXX][C][java])</span></span><br><span class="line"><span class="keyword">project</span>(HEllO CXX)</span><br><span class="line"><span class="comment">#指定工程名称为HELLO 支持C++ </span></span><br></pre></td></tr></table></figure></li><li><p><strong>set</strong>:显示的定义变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC sayhello.cpp hello.cpp)</span><br><span class="line"><span class="comment">#定义一个SRC变量 引用SRC 相当于引用sayhello.cpp hello.cpp</span></span><br></pre></td></tr></table></figure></li><li><p><strong>include_directories </strong>向工程添加多个特定的头文件搜索路径</p><p>假设文件夹路径是这样的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">└── myfolderinclude</span><br><span class="line">    └── othersfolderinclude</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(../myfolderinclude ./othersfolderinclude)</span><br><span class="line"><span class="comment">#类似于g++中的-I </span></span><br></pre></td></tr></table></figure></li><li><p><strong>link_directories</strong>:向工程添加多个指定的库文件搜索路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(../myfolderlib ./othersfolderlib)</span><br></pre></td></tr></table></figure></li><li><p><strong>add_library</strong>:生成库文件</p><p>比较重要的语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add-library(libname[SHARED|STATIC|MODULE][EXCLUDE_FORM_ALL]source1 source2 ..sourceN)</span></span><br><span class="line"><span class="comment">#通过变量SRC （上方代码中定义的SRC变量引用）生成动态[SHARED] 的libhellp.so文件</span></span><br><span class="line"><span class="keyword">add_library</span>(hello SHARED <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="comment">#注意，变量的引用使用$&#123;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>add_compile_options</strong>：添加编译参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-Wall -std=c++ -O2)</span><br><span class="line"><span class="comment">#分别添加的是警告显示，定义语言特性，优化级数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>add_executable</strong> :生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="comment">#将main.cpp编译为 mian</span></span><br></pre></td></tr></table></figure></li><li><p><strong>target_link_libraries</strong>为target链接的动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#等价于g++ -l 编译器参数</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main hello)</span><br><span class="line"><span class="comment">#将hello动态库链接到可执行文件main </span></span><br></pre></td></tr></table></figure></li><li><p><strong>add_subdirectory</strong>向当前的工程添加存放源文件的子目录，指定中间二进制和目标二进制的存放位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="comment">#添加一个src子目录,src中需要也有一个CMakelists.txt</span></span><br></pre></td></tr></table></figure></li><li><p><strong>aux_source_directory</strong> 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC)</span><br><span class="line"><span class="comment">#定义. （就是一个目录下所有的源文件） 为SRC变量</span></span><br><span class="line">add_exrcutable(mian <span class="variable">$&#123;SRC&#125;</span>)</span><br><span class="line"><span class="comment">#引用SRC 生成可执行文件</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><ul><li><p><strong>CMAKE_CXX_FLAGS</strong>：编译选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在CMAKE_CXX_FALGS编译选项后加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FALGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br><span class="line"><span class="comment">#类似CMAKE_CXX_FALGS+=-std=c++11</span></span><br></pre></td></tr></table></figure></li><li><p><strong>CMAKE_BUILDTYPE</strong>：编译类型</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"><span class="comment">#编译为Debug</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="comment">#编译为Release</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CMake编译"><a href="#CMake编译" class="headerlink" title="CMake编译"></a>CMake编译</h3><p>手动编写CMakeLists.txt</p><h4 id="两种编译规则"><a href="#两种编译规则" class="headerlink" title="两种编译规则"></a>两种编译规则</h4><ul><li><p>​    子目录无CMakeLists.txt</p></li><li><p>​    子目录包含CMakeLists.txt</p></li></ul><h4 id="两种构建方式"><a href="#两种构建方式" class="headerlink" title="两种构建方式"></a>两种构建方式</h4><ul><li><p>内部构建（不用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单纯的直接cmake 当前文件夹生成makefile</span><br><span class="line">再make 执行makefile 生成可执行文件等等，</span><br><span class="line">因为都生成在当前文件夹很乱，目录结构不清析。</span><br><span class="line">所以不用</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>外部构建（常用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在当前目录下新建一个build </span></span><br><span class="line"><span class="built_in">mkdir</span> build </span><br><span class="line"><span class="comment">#跳转</span></span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line"><span class="comment">#执行cmake,执行上层主目录下的CMakelists.txt</span></span><br><span class="line">cmake .. </span><br><span class="line"><span class="comment">#生成makefile和其他文件</span></span><br><span class="line">make </span><br><span class="line"><span class="comment">#执行</span></span><br><span class="line"><span class="comment">#所有的编译输出文件都存在了build目录中</span></span><br><span class="line"><span class="comment">#互不干扰结构明了</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CMake在vs-code下的甜点"><a href="#CMake在vs-code下的甜点" class="headerlink" title="CMake在vs.code下的甜点"></a>CMake在vs.code下的甜点</h3><p>​        当我们需要在vs.code调试CMake代码生成的可执行文件的时候，可以设置launch.json和一个task.json的调试脚本<del>个人觉得，只是锦上添花的操作，除了tasks.josn,我们可以写bat，或者shell都可以而且代码更少</del>，达到可以直接运行调试的效果，不需要在修改源代码后，再手动输入cmake与make 重新编译，实现自动化操作</p><p>​        首先我们选择运行与调试默认生成的launch.json，给出一个文件目录的示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles/....</span><br><span class="line">│   ├── cmake_install.cmake</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── main<span class="comment">#这个是生成的可执行文件</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── gun.h</span><br><span class="line">│   └── soilder.h</span><br><span class="line">├── main.cpp</span><br><span class="line">└── src</span><br><span class="line">    ├── gun.cpp</span><br><span class="line">    └── soilder.cpp</span><br></pre></td></tr></table></figure><p>根据文件目录我们将默认生成的launch.json进行改动</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) 启动&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/main&quot;</span><span class="punctuation">,</span><span class="comment">//这里需要更改为你的可执行文件</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            </span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Build&quot;</span><span class="punctuation">,</span> <span class="comment">//这是里我们需要修改的地方</span></span><br><span class="line">            <span class="comment">//上方代码的意思是，执行调试前的前置任务，所以我们需要再生成一个tasks.json文件</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span><span class="comment">//默认添加</span></span><br><span class="line">            </span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再编写一个简单的tasks.json，可以直接在vs.code终端菜单下直接生成一个简单的任务范例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><span class="comment">//指定工作区下的目录</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;step1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmake&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;..&quot;</span>  <span class="comment">//参数</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;step2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span><span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                </span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;dependsOrder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sequence&quot;</span><span class="punctuation">,</span><span class="comment">//依赖顺序设置为顺序执行</span></span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span>   <span class="comment">//顺序</span></span><br><span class="line">                <span class="string">&quot;step1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;step2&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用VScode与CMake做C++开发环境</title>
      <link href="/2022/07/11/zatan01/"/>
      <url>/2022/07/11/zatan01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//v2-49a45b8c622434dbf79463ccab9fa627_720w.png" alt=""></p><h3 id="啥事cmake"><a href="#啥事cmake" class="headerlink" title="啥事cmake?"></a>啥事cmake?</h3><p>​        CMake 是一个开源、跨平台的工具，旨在构建、测试和打包您的程序。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。这套 CMake 工具由 Kitware 创建，以满足 ITK 和 VTK 等开源项目对强大的跨平台构建环境的需求。</p><p>​        说白了，这玩意只是个配置器，配置你的编译器该如何进行编译</p><span id="more"></span><h3 id="cmake的好处："><a href="#cmake的好处：" class="headerlink" title="cmake的好处："></a>cmake的好处：</h3><pre><code>&lt;center&gt;“Write once, run everywhere”&lt;/center&gt;</code></pre><p>​        非常好理解，就是只写一次，到处运行</p><p>​        对我来说就三个字：跨平台。</p><h3 id="cmake的缺点："><a href="#cmake的缺点：" class="headerlink" title="cmake的缺点："></a>cmake的缺点：</h3><p>​        缺点：麻烦，步骤繁多        </p><p>​        断点调试挺麻烦的，VScode里的插件可以，但是需要对luanch.json和tasks.json进行修改，尤其是出现多个目录多个源文件等大项目的编译，修改虽然不复杂，但是麻烦。想要调试添加额外配置参数来打印所执行的所有代码及行号，插入log等方式检查问题。</p><p>​        有这弱语言的共通问题，就是容易出问题。</p><p>总而言之，挺麻烦的</p><p><del>要不是最近需要将Qmake项目迁移到cmake，还真不想用这玩意</del></p><h3 id="利用CMake编译一个简单的C-程序"><a href="#利用CMake编译一个简单的C-程序" class="headerlink" title="利用CMake编译一个简单的C++程序"></a>利用CMake编译一个简单的C++程序</h3><p>首先vscode需要下载两个插件，CMAKE与C/C++,这些我默认就有，因为在下载之前就一直用着VS2022，模块化无脑安装。</p><p>然后配置CMake和MINGW环境变量，这些我默认也有，安装Qt自带，直接指向Qt/tools里的对应路径即可。</p><p>前提条件准备得那是相当充足。</p><p>直接就随便顺手写一个冒泡排序的小例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建这样一个目录结构</span><br><span class="line">└── src</span><br><span class="line">    └── sort.cpp</span><br><span class="line">└── include</span><br><span class="line">    └── sort.h</span><br><span class="line">└── main.cpp    </span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;sort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    Sort sort;</span><br><span class="line">    <span class="built_in">sort</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.<span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sort</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>-i<span class="number">-1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span>(x[j]&lt;x[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp=x[j];</span><br><span class="line">                    x[j]=x[j+<span class="number">1</span>];</span><br><span class="line">                    x[j+<span class="number">1</span>]=temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sort.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&quot;sort.h&quot;</span><br><span class="line">void Sort::test()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;test\n&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，前提源文件准备工作结束</p><p>开始编写CMakelists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这种写法非常简单，无脑摁写，但是不够直观</span></span><br><span class="line"><span class="keyword">project</span>(Sorttest) <span class="comment">#项目名称</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(src SRC_SUB) <span class="comment">#项目根目录下的所有子项目</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_CUR)  <span class="comment">#同理</span></span><br><span class="line"><span class="keyword">add_executable</span>(sort <span class="variable">$&#123;SRC_SUB&#125;</span> <span class="variable">$&#123;SRC_CUR&#125;</span>) <span class="comment">#同理</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>) <span class="comment">#头文件包含目录</span></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>) <span class="comment">#最低版本需求</span></span><br><span class="line"><span class="keyword">project</span>(Sorttest) <span class="comment">#项目名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment">#头文键包含</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main</span><br><span class="line">               <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/main.cpp <span class="comment">#这个路径看这个main.cpp位于哪里了              </span></span><br><span class="line">               <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/sort.cpp)</span><br></pre></td></tr></table></figure><p>后者相对前者直观一些，效果都是一样的</p><p>在CMakelist.txt视窗中按下快捷键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift+ctrl+p</span><br></pre></td></tr></table></figure><p>唤起</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711223231514.png" alt="image-20220711223231514"></p><p>选择CMake配置，一切自动化帮你构建build文件夹目录</p><p>再新终端下方 cd跳转到build目录中</p><p>输入以下指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><p>运行如下工具 (这个是根据build的中的Makefile中的规则经行对源文件进行编译)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make.exe </span><br></pre></td></tr></table></figure><p>可以看到运行后在Bulid目录下多出一个sort.exe</p><p>在终端中输入运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\sort.exe</span><br></pre></td></tr></table></figure><p>既可以看到程序的输出结果：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711224250666.png" alt="image-20220711224250666"></p><p>至此编译到此结束</p>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> CMake </tag>
            
            <tag> VScode </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础00</title>
      <link href="/2022/07/11/linux00/"/>
      <url>/2022/07/11/linux00/</url>
      
        <content type="html"><![CDATA[<h2 id="linux基础中的基础"><a href="#linux基础中的基础" class="headerlink" title="linux基础中的基础"></a>linux基础中的基础</h2><h3 id="linux-的基础命令"><a href="#linux-的基础命令" class="headerlink" title="linux  的基础命令"></a>linux  的基础命令</h3><h4 id="指令默认格式"><a href="#指令默认格式" class="headerlink" title="指令默认格式"></a>指令默认格式</h4><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令 [选项] [操作对象]</span><br></pre></td></tr></table></figure><p>注意：中括号代表的意思是可以省略内容不输入，一样可以运行该指令</p><p>默认打开终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Alt+T</span><br></pre></td></tr></table></figure><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>打印当前所在的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>打印当前目录下的文件与文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>ls的用法扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [文件路径]</span><br><span class="line"><span class="comment">#文件路径：</span></span><br><span class="line"><span class="comment">#相对路径or绝对路径</span></span><br></pre></td></tr></table></figure><p>打开文件目录下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> 选项 [文件路径]</span><br><span class="line"><span class="comment">#选项：指定方式显示</span></span><br></pre></td></tr></table></figure><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-a <span class="comment">#表示显示所有的(all)文件与文件夹，包括隐藏</span></span><br><span class="line">-l <span class="comment">#表示详细列表的方式展示(list)</span></span><br><span class="line">-h <span class="comment">#以可读性较高的形式显示</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="cd-chanage-directory"><a href="#cd-chanage-directory" class="headerlink" title="cd(chanage directory)"></a>cd(chanage directory)</h4></li></ul><p>：跳转目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  </span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment">#作用都是直接回到家目录</span></span><br></pre></td></tr></table></figure><p>与ls类似的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [文件路径]</span><br><span class="line"><span class="comment">#文件路径：</span></span><br><span class="line"><span class="comment">#相对路径or绝对路径</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a>mkdir(make directories)</h4></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> myfolder </span><br><span class="line"><span class="comment">#在当前的目录下创建一个mydir文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> myfolder1 myfolder2</span><br><span class="line"><span class="comment">#在当前目录下创建两个文件夹，分别是 myfolder1，myfolder2</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/a/b/c</span><br><span class="line"><span class="comment">#-p 选项是必须的</span></span><br><span class="line"><span class="comment">#当前家目录下(~)创建多层不存在的目录</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="touch-change-file-timestamps"><a href="#touch-change-file-timestamps" class="headerlink" title="touch-change file timestamps"></a>touch-change file timestamps</h4></li></ul><p>作用：创建文件（虽然本意不是这个）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span>  test.txt</span><br><span class="line"><span class="comment">#在当前目录下生成一个 test.txt文件</span></span><br><span class="line"><span class="built_in">touch</span> ../test1  <span class="comment">#（相对路径)</span></span><br><span class="line"><span class="comment">#在当前目录的上级目录下生成一个 test1文件</span></span><br><span class="line"><span class="built_in">touch</span> ~/test2  <span class="comment">#(绝对路径)</span></span><br><span class="line"><span class="comment">#在~（家)目录下生成一个 test2文件</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm (remove )"></a>rm (remove )</h4></li></ul><p>删除指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> [选项] [路径]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.txt</span><br><span class="line"><span class="comment">#删除文件</span></span><br><span class="line"><span class="built_in">rm</span> ../test1</span><br><span class="line"><span class="comment">#删除上级目录的文件</span></span><br><span class="line"><span class="built_in">rm</span> ~/test2</span><br><span class="line"><span class="comment">#在~（家)目录下删除test2文件</span></span><br></pre></td></tr></table></figure><p>删除文件夹和文件夹下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf [文件夹路径]</span><br><span class="line"><span class="comment">#删除文件夹</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a>cp(copy)</h4></li></ul><p>作用：复制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [复制的文件路径] [副本的文件路径]</span><br><span class="line"><span class="built_in">cp</span> ../test ./test.txt</span><br><span class="line"><span class="comment">#上级的目录下的test文件复制到当前目录下 并且换了个名字（加了个.txt后缀名）</span></span><br></pre></td></tr></table></figure><p>复制文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r [文件夹路径] [副本文件夹的路径]</span><br><span class="line"><span class="comment">#-r是递归的意思</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="mv-move"><a href="#mv-move" class="headerlink" title="mv (move)"></a>mv (move)</h4></li></ul><p>作用：移动文件位置，或者重命名文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> <span class="built_in">test</span> test.txt</span><br><span class="line"><span class="comment">#重新命名test文件为 test.txt(在当前目录下)</span></span><br><span class="line"><span class="comment">#等效 mv test ./test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> <span class="built_in">test</span> ../test.txt </span><br><span class="line"><span class="comment">#重新命名并且移动到了上级目录中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="men-menu"><a href="#men-menu" class="headerlink" title="men (menu)"></a>men (menu)</h4><p>说明书目录:</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">ls</span></span><br><span class="line"><span class="comment">#参看命令ls的手册</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在man中无cd的手册</span></span><br><span class="line"><span class="comment">#我们在cd help中可以看到</span></span><br><span class="line"></span><br><span class="line">man man </span><br><span class="line"><span class="comment">#参看man的命令手册</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line"><span class="comment">#立即重启</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>关机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h [时间]</span><br><span class="line"></span><br><span class="line">shutdown -h now </span><br><span class="line"><span class="comment">#立即关机</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="文件的编辑"><a href="#文件的编辑" class="headerlink" title="文件的编辑"></a>文件的编辑</h3><ul><li><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>一句话：<strong>编辑器之神</strong></p><p>安装：(Ubuntu LTS 22.04)</p><p><del>想用的时候居然没有安装</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#建议安装：</span></span><br><span class="line"> ctags vim-doc vim-scripts</span><br><span class="line"><span class="comment">#顺带一并安装#都是vim的插件</span></span><br><span class="line">sudo apt-get install ctags</span><br><span class="line">sudo apt-get install vim-doc</span><br><span class="line">sudo apt-get install vim-scripts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/2018101511335895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9jeTY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="助记图"></p></li></ul><p>  这里不继续详细的说明，将会新开一篇文章来记录VIM 的使用</p><p>  简单的使用：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim [file]</span><br><span class="line">#直接打开文本</span><br></pre></td></tr></table></figure><p>  终端直接变成了文本编辑器</p><p>  键盘摁下 i 键</p><p>  可以可以看见左下角状态变更为 插入 （insert）</p><p>  此时即可以输入文本进行编辑了</p><p>  保存需摁下</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift </span><br></pre></td></tr></table></figure><p>  输入： </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:w #保存文本</span><br><span class="line">:q #退出vim编辑器</span><br></pre></td></tr></table></figure><ul><li><h4 id="geidt"><a href="#geidt" class="headerlink" title="geidt"></a>geidt</h4><p>纯文本的编辑器，ubuntu 都是自带的,默认的编辑器</p></li></ul><p>  简单的使用：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim [file]</span><br><span class="line"><span class="comment">#直接打开文本编辑框，</span></span><br></pre></td></tr></table></figure><p>  与vim不同点在于 弹出的geidt的编辑界面，对新手挺友好的</p><p>  直接按照Windows下的记事本使用即可</p><ul><li><h4 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h4><p>与Vim类似，但是比vim简单而且小巧</p><p>简单的使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano [file]</span><br><span class="line"><span class="comment">#终端变成nano界面</span></span><br></pre></td></tr></table></figure><p>指令都在下方直观的显示出来</p><p>修饰键是Ctrl ，使用起来非常简单</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习第一节|Qt基础</title>
      <link href="/2022/06/26/QTstudy/"/>
      <url>/2022/06/26/QTstudy/</url>
      
        <content type="html"><![CDATA[<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628200812272.png" alt=""></p><p>基于C++的跨平台的图形引擎</p><p>发行于1991年 <del>就记了个大概，不知道的咱可以百度不是</del></p><span id="more"></span><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.跨平台</p><p>2.接口简单</p><p>3.一定程度简化了内存回收</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.WPS</p><p>2.linux-KDE</p><p>3.vlc多媒体播放</p><h2 id="创建第一个Qt"><a href="#创建第一个Qt" class="headerlink" title="创建第一个Qt"></a>创建第一个Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111650699.png" alt=""></p><p>系统环境：windows11<br>软件环境：Qt6.2.3(MSVC 2019 64bit)</p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>一开始可以直接打开官方的Qt Creator，暂且不需要使用MSVS上进行调试开发，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-&gt; new project</span><br></pre></td></tr></table></figure><h4 id="选择模板（tempates"><a href="#选择模板（tempates" class="headerlink" title="选择模板（tempates)"></a>选择模板（tempates)</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110514448.png" alt=""></p><p>默认<strong>Qt widget application</strong>（最基本的，也是最常用的窗口应用）</p><p>新建文件名和选择路径需要注意：（名字 路径，都不要有中文）</p><h4 id="选择构建系统（build-system）"><a href="#选择构建系统（build-system）" class="headerlink" title="选择构建系统（build system）"></a>选择构建系统（build system）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110646484.png" alt=""></p><p>因为做的是第一个程序，要快速上手选择qmake（Qt自带，不过个人建议cmake）。</p><h4 id="细节（details）"><a href="#细节（details）" class="headerlink" title="细节（details）"></a>细节（details）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111032398.png" alt=""></p><p>名字都可以默认，也可以更改随喜好，注意事项（中文不行，空格禁止）</p><p><strong>重点在于Base class（基类）</strong></p><p>窗口类型介绍：QMainWindow、QWidget、QDialog三个类都可以用来创建窗口，可以直接使用，也可以继承后使用。</p><p>　　QMainWindow窗口包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式，也可以说是GUI程序的主窗口。</p><p>　　QDialog是对话框窗口的基类。对话框主要用来执行短期任务，或者与用户进行互动，它可以是模态的，也可以是非模态的。他没有菜单栏、工具栏、状态栏等。</p><p>　　如果是主窗口，就使用QMainWindow类；</p><p>　　如果是对话框，就使用QDialog类；</p><p>　　如果不确定，有可能作为顶层窗口，也有可能嵌入到其他窗口，就使用QWidget类。</p><p>​        第一个程序我们可以默认直接选QWidget类</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202512898.png" alt=""></p><p>这个是生成一个UI界面，一开始做第一个程序可以不选，因为需要学习一下UI底层的实现代码。</p><h4 id="Kits-选择"><a href="#Kits-选择" class="headerlink" title="Kits 选择"></a>Kits 选择</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202115437.png" alt=""></p><p>这里我因为安装时选择需要MSVC调试开发，所以会出现MSVC，默认有MInGW,一般可全选，创建第一个项目的时候不容易出错</p><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202912401.png" alt="">选择版本控制系统，一开始第一个程序用不上，实际是做大项目开发用的源代码管理工具选择，比如说我们常见的git ，svn等。具体可看这篇CSDN博文：<a href="https://blog.csdn.net/weixin_45627194/article/details/110050361">源代码管理工具 </a></p><p>点击完成至此，创建一个Qt项目完成</p><h4 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//ctrl / 注释</span><br><span class="line">//ctrl r 运行</span><br><span class="line">//ctrl b 编译</span><br><span class="line">//ctrl i 自动对齐</span><br><span class="line">//F4 快捷切换同名文件</span><br></pre></td></tr></table></figure><h3 id="生成的代码文件"><a href="#生成的代码文件" class="headerlink" title="生成的代码文件"></a>生成的代码文件</h3><h3 id="需要掌握的："><a href="#需要掌握的：" class="headerlink" title="需要掌握的："></a>需要掌握的：</h3><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="comment">//argc为命令行变量的数量</span></span><br><span class="line"><span class="comment">//*argv变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;<span class="comment">//a即为应用程序对象，有且仅有一个</span></span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="comment">//窗口对象 （子类widger ：public QWidget）</span></span><br><span class="line">    <span class="comment">//默认不显示；</span></span><br><span class="line">    <span class="comment">//需要以下函数调用，调用的是顶层窗口函数</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">     <span class="comment">//让应用程序对象进入消息循环机制</span></span><br><span class="line">    <span class="comment">//类似while（true）</span></span><br><span class="line">    <span class="comment">//触发条件退出循环结束程序</span></span><br><span class="line">    <span class="comment">//堵塞你的代码运行</span></span><br><span class="line">    <span class="comment">//与system(&quot;pause&quot;)作用类似</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//之后的代码依旧会顺序执行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>widget.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include&lt;QDebug&gt;</span><br><span class="line">#include&lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent): QWidget(parent)//这不就是初始化列表么</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个按钮</span><br><span class="line">    QPushButton *btn = new QPushButton;</span><br><span class="line">    //btn-&gt;show();//单独弹出一个顶层的窗口来弹出窗口控件</span><br><span class="line">    //所以我们需要将Btn对象依赖在Widget窗口中</span><br><span class="line">    btn-&gt;setParent(this);</span><br><span class="line">    //函数名直译，设置父母。</span><br><span class="line"></span><br><span class="line">    //给按钮显示值</span><br><span class="line">    btn-&gt;setText(&quot;第一个按钮&quot;);</span><br><span class="line"></span><br><span class="line">//    创建第二个按钮</span><br><span class="line">    QPushButton *btn2=new QPushButton(&quot;第二个按钮&quot;,this);//有参构造</span><br><span class="line">    //但是有问题，只会按照空间的大小创建窗口</span><br><span class="line">    //我们可以自己设定默认窗口大小</span><br><span class="line">    //可修改</span><br><span class="line">    resize(600,400);</span><br><span class="line">   //我想要窗口固定大小，就需要</span><br><span class="line">    setFixedSize(600,400);</span><br><span class="line">    //同理，按钮需要定义大小也可以</span><br><span class="line">    btn-&gt;resize(50,20);</span><br><span class="line"></span><br><span class="line">    //但是运行还是只有一个按钮没因为默认位置将第一个按钮覆盖显示了，我们需要移动他</span><br><span class="line">    btn2-&gt;move (100,100);</span><br><span class="line">    //这样我们就可以看到两个按钮了，这个时候我也可以更改应用标题</span><br><span class="line">    setWindowTitle(&quot;第一个Qt&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //问题：</span><br><span class="line">    //我们的按钮都是开辟于堆区，不用去考虑释放内存的问题吗</span><br><span class="line">    //引入对象树的概念</span><br><span class="line">    //setparent(this)</span><br><span class="line">    //关键函数：</span><br><span class="line">//将这个类与类下的对象放入对象树中</span><br><span class="line">//析构的时候   --接以下注释--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug(&quot;父类的析构&quot;);</span><br><span class="line">    </span><br><span class="line">    //先执行自行添加的代码，然后</span><br><span class="line">    //底层在释放这个类之前判断是否有子类，如果有就找到子类析构，再执行自添加的代码，再判断，</span><br><span class="line">    //直到找不到子类，确认是最后一个子类后释放这个子类下的对象</span><br><span class="line">    //所以就会出现，先输出父类析构代码再输出子类的析构代码的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h4><p>Qt的学习重点，Qt的引以为豪的部分。</p><p>怎了么理解信号与槽？</p><p>我们现看个例子：</p><p>我打开一盏灯，灯亮了</p><p>信号的发送者，发送具体信号，信号的接收者，槽函数：信号的处理</p><p>connect （信号的发送者，发送具体信号；信号的接收者，信号的处理）</p><p>信号槽的优点，松散耦合：可以理解为信号发送与接收者没啥关联，通过connect的链接两端耦合在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接函数</span></span><br><span class="line"><span class="built_in">connect</span>(mybtn  ,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;Widget::close);</span><br><span class="line"><span class="comment">//参数1：信号发送者，参数2：信号这里填入地址；</span></span><br><span class="line"><span class="comment">//参数3：信号接收者，参数3；同样是地址槽（槽函数，执行行为）</span></span><br></pre></td></tr></table></figure><p>QT库中有现成的信号与槽函数，当然我们也可以自己写一个，具体实现：</p><p>更多内容在下一篇文章再说，<del>还没写呢。先玩游戏去辣</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628211036994.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Qt学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt6.2.3，C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章的技巧</title>
      <link href="/2022/06/25/hello-world/"/>
      <url>/2022/06/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        第一次利用Typora编写Md文件并且发布博客，有很多操作还是非常生疏，在这里记录个Md文件的文章编辑的常用代码。以供我啥时候突然给整忘了回来看看😁</p><p>​                                    <span id="more"></span></p><p>`                      </p><h3 id="文章阅读截止"><a href="#文章阅读截止" class="headerlink" title="文章阅读截止"></a>文章阅读截止</h3><p>​        将过长的文章截取，只显示代码上方的文章内容，避免文章过长的显示在博客主页（这个可以说是非常常用）</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><h3 id="文章的新建命令"><a href="#文章的新建命令" class="headerlink" title="文章的新建命令"></a>文章的新建命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>​        在github bash 中使用 该指令可以新建一个页面：</p><p>​        使用实例如下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post 标题</span><br></pre></td></tr></table></figure><p>​        可以在hexo根文件的中的_post的文件夹中发现新建了一个标题.md    ，头部信息如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: //时间</span><br><span class="line">tags: //标签</span><br><span class="line">categories:  //分类</span><br></pre></td></tr></table></figure><h3 id="草稿的新建命令"><a href="#草稿的新建命令" class="headerlink" title="草稿的新建命令"></a>草稿的新建命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft title</span><br></pre></td></tr></table></figure><p>​        在github bash 中使用 该指令可以新建一个草稿：</p><p>​        使用实例如下 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft 标题</span><br></pre></td></tr></table></figure><p>​        可以在hexo根文件的中的_drafts的文件夹中发现新建了一个标题.md    头部的信息如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: //时间</span><br><span class="line">tags: //标签</span><br><span class="line">categories:  //分类</span><br></pre></td></tr></table></figure><p>​        草稿不会显示在博客中，想要看到博客草稿需要在github bash 中使用如下指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -draft</span><br></pre></td></tr></table></figure><p>​        该指令的作用除了在本地运行博客部署以外，可以在博客中访问草稿.</p><h3 id="front-Matter"><a href="#front-Matter" class="headerlink" title="front  Matter"></a>front  Matter</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//20200916181236318.png" alt=""></p><p>​    每个创建的MD文件都在头端插入了名为front  Matter预定义读取参数,就是上文所说的头部信息。<br>​    可以看见这张图是有水印的，我们可以利用MD的文件中的画图代码画出相同的信息：</p><center>|    参数    |       描述       |       默认值       || :--------: | :--------------: | :----------------: ||   layout   |       布局       |         无         ||   title    |       标题       |         无         ||    date    |    建立的日期    |    文件建立日期    ||   update   |    更新的日期    | 每次文件更新的日期 ||  comments  | 该文章的评论功能 |  默认每个文章开启  ||    tags    |       标签       |         无         || categories |       分类       |         无         |</center>]]></content>
      
      
      <categories>
          
          <category> 博客技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
