<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络基础|第二节|物理层</title>
    <link href="/2022/07/17/internet02/"/>
    <url>/2022/07/17/internet02/</url>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本章了解个概念，不深究，比较抽象</p><h2 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h2><p><strong>明确：考虑怎么链接各种计算机之间传输比特流数据</strong></p><p>四个特性</p><ul><li><p>机械</p><p>接口类型</p></li><li><p>电气</p><p>电压</p></li><li><p>功能</p><p>传输1&#x2F;0编码</p></li><li><p>过程</p><p>时种顺序</p></li></ul><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><p>注意传输介质实际上不属于物理层</p><h4 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h4><ul><li><strong>双绞线</strong></li></ul><p>两根，按一定规则双绞，抗干扰</p><ul><li><p><strong>同轴电缆</strong></p></li><li><p><strong>光纤</strong></p><ul><li><p>单模光纤：波导,就是贵，对光信号要求高</p></li><li><p>多模光纤：全反射</p><p>优点：带宽大,损耗低</p></li></ul></li><li><p><strong>电力线</strong></p><p>适合短距离</p></li></ul><h4 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h4><p>(自由空间)</p><ul><li><strong>微波</strong></li></ul><p>直线，电离层无折射，需要中继站，典型5G通信</p><ul><li><strong>无线电波</strong></li></ul><p>电离层折射，距离远</p><ul><li><strong>可见光</strong></li></ul><p>应用：lifi</p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h3><p>一条数据传输线路</p><h3 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h3><p>多条数据传输线路</p><p><strong>计算机内部常用并行传输</strong></p><h3 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h3><h4 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h4><p>连续无间隔</p><p><strong>外同步</strong></p><p>多加一条单独的时钟信号线</p><p><strong>内同步</strong></p><p>市中心号线与发送数据曼彻斯特编码</p><h3 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h3><p>异步的体现：字节之间的时间间隔不固定</p><p>需要字节需要加上起始位和结束位</p><p>但各比特的持续时间是相同的</p><p>字节异步，比特同步</p><h3 id="单工"><a href="#单工" class="headerlink" title="单工"></a>单工</h3><p>单向</p><h3 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h3><p>双向不同时</p><h3 id="全双工"><a href="#全双工" class="headerlink" title="全双工"></a>全双工</h3><p>同时双向</p><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p>关于编码与调制我们需要了解：</p><p>信息-&gt;数据（二进制）-&gt;信号（电磁表现）</p><p>数字基带信号的数字</p><p>模拟基带信号</p><p>两者都有编码和调制</p><h3 id="数字基带信号"><a href="#数字基带信号" class="headerlink" title="数字基带信号"></a>数字基带信号</h3><p>编码（数字信号转化数字信号）：以太网下的曼彻斯特编码，4B&#x2F;5B 走的是数字信道</p><p>调制（数字信号转化模拟信号）：WIFI CCK&#x2F;DSS&#x2F;OFDM调制，走的是模拟信道</p><h3 id="模拟基带信号"><a href="#模拟基带信号" class="headerlink" title="模拟基带信号"></a>模拟基带信号</h3><p>编码（数字信号转化数字信号）：音频信号的PCM脉码调制，走的是数字信道</p><p>调制（数字信号转化模拟信号）：FDM频分复用，充分利用带宽资源，走的是模拟信道</p><p><del>这熟悉又陌生的的名词</del></p><p><strong>注意</strong></p><p>传输媒体不等于信道</p><p>不同的传输媒体，包含多个不同数量的信道</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="归零编码"><a href="#归零编码" class="headerlink" title="归零编码"></a>归零编码</h4><p>自同步，编码效率低，需要归零</p><h4 id="不归零编码"><a href="#不归零编码" class="headerlink" title="不归零编码"></a>不归零编码</h4><p>需要多一条信道传输时钟信号，这玩意不能用来传递时钟信号</p><h4 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h4><p>码元为单位，以中间的信号跳变表示0&#x2F;1</p><p>跳变有表示时钟，又表示数据</p><p>（是传统以太网10Mb&#x2F;s）</p><h4 id="差分曼彻斯特编码"><a href="#差分曼彻斯特编码" class="headerlink" title="差分曼彻斯特编码"></a>差分曼彻斯特编码</h4><p>跳变只表示时钟</p><p>码元开始处 的电平是否发生变化表示数据，</p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字基带信号</p><p>频率，振幅，相位</p><h4 id="二元调制："><a href="#二元调制：" class="headerlink" title="二元调制："></a>二元调制：</h4><p>只有<strong>两种</strong>码元</p><p><strong>调幅AM</strong></p><p><strong>调频FM</strong></p><p><strong>调相PM</strong></p><p>调频和调相<strong>不能一块调</strong>，调幅调相可以同时，或者调频调幅</p><h4 id="混合调制："><a href="#混合调制：" class="headerlink" title="混合调制："></a>混合调制：</h4><p><strong>调频和调相混合</strong></p><p>至少可以有<strong>四种</strong>码元，若是有4个相位，4种振幅，可以调出16个不同的波形，也就是码元</p><p>我们再以二进制处理这16种码元<br>$$<br>log_216&#x3D;4<br>$$<br>可以算出每个码元所还能携带的信息量为4比特</p><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p><strong>奈氏准则</strong>，假定的理想条件下，避免码间串扰，码元的传输速率是有上限的</p><p>不考虑信噪比</p><p>理想低通信道的最高码元传输速率&#x3D;2W Baud&#x3D; 2W(单位：码元&#x2F;s)</p><p>理想带通信道的组稿码元传输速率&#x3D;W Baud&#x3D; W（单位：码元&#x2F;s）</p><p>W指的是，信道带宽hz</p><p>那么要考虑噪声，引出<strong>香农公式</strong></p><p>带宽受限 且高斯白噪声干扰的信道的极限信息的传输效率<br>$$<br>c&#x3D;W*log_2(1+\frac{S}{N})~~~~（单位：bit&#x2F;s）<br>$$</p><p>综上奈氏准则和香农公式，要想<strong>提高信息的传输速率</strong>就必须用<strong>多元</strong>制的调制方式，努力提高<strong>信道中的信噪比</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思维导图：不着急</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>基础，物理层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/16/socket/"/>
    <url>/2022/07/16/socket/</url>
    
    <content type="html"><![CDATA[<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>套接字 描述计算机的ip地址和端口，基于TCP&#x2F;ip</p><p>这里我直接上图：先把协议的概念先搞懂</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/bfcd89ba301b34b6f158d2065a5ccb40.jpg" alt="https://s4.51cto.com/oss/201910/22/bfcd89ba301b34b6f158d2065a5ccb40.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础|第一节</title>
    <link href="/2022/07/15/Internet01/"/>
    <url>/2022/07/15/Internet01/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础-第一节"><a href="#计算机网络基础-第一节" class="headerlink" title="计算机网络基础|第一节"></a>计算机网络基础|第一节</h1><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/728da9773912b31bad1719cedfd48473dbb4e130.png" alt="img"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学校网课不努力，B站大学再继续。实在努力不下去，美团饿么当兄弟。</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/9bb444786eaac9678f1b8574db28d03b69cef878.jpg@942w_942h_progressive.webp" alt="img"></p><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p>两个以上主机可发送接受信息的互连的，可自治的，组成计算机网络</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="常用以下8个"><a href="#常用以下8个" class="headerlink" title="常用以下8个"></a>常用以下8个</h3><h4 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h4><p><strong>比特 bit 数据量单位</strong></p><p>代表：一个数0&#x2F;1</p><p>字节&#x3D;B</p><p>8bit&#x3D;1B;</p><p>注意：<strong>依次乘与2的10次方</strong></p><p><strong>K-&gt;M-&gt;G-&gt;T</strong></p><p>举个例子</p><p>我们购买的硬盘，商家标的是250GB为什么在操作系统中却只有232.8GB呢</p><p>我们看下面的一个公式：<br>$$<br>\frac{250*10^{9} } {2^{30} }&#x3D;232.8（GB）<br>$$</p><p>商家的计算方式是G 为10的9次方，操作系统中数据量的G 是2的30次方</p><p><strong>比特率</strong>速率单位 bit&#x2F;s</p><p>注意：<strong>依次乘与10的3次方</strong></p><p><strong>k-&gt;M-&gt;G-&gt;T</strong></p><p><strong>与数据量不同</strong></p><h4 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h4><p>在<strong>模拟信号</strong>中 ：单位<strong>Hz</strong></p><p>表达的是信号频率范围</p><p>在<strong>计算机网络</strong>中：</p><p>可以理解为网络中点到点传输的 最高数据率</p><p>单位b&#x2F;s与比特率相同</p><p>这两者其实表述都是有联系的，带宽频率越宽，网络越好</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE50.png"></p><h4 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3.吞吐量"></a>3.吞吐量</h4><p>单位时间通过的数据量</p><p>受到带宽限制</p><h4 id="4-时延"><a href="#4-时延" class="headerlink" title="4.时延"></a>4.时延</h4><p>总的来说就是传输数据的时间</p><p>可以细分为：</p><p>网络时延：发送，传播，处理</p><ul><li><p>发送时延：分组长度&#x2F;发送速率</p></li><li><p>传播时延</p><p>计算是有公式的</p><p>信道长度&#x2F;电磁波传播速率 </p><p>然而在不同的传输介质中传播速率是不同的</p><p>这里列出3个不同的常见的传播介质</p><ul><li>光纤</li><li>忘了</li><li>是啥来着？</li></ul></li><li><p>处理时延：不方便计算</p></li></ul><h4 id="5-时延带宽积"><a href="#5-时延带宽积" class="headerlink" title="5.时延带宽积"></a>5.时延带宽积</h4><p>传播时延乘与带宽的乘积</p><p>![](&#x2F;home&#x2F;icrad&#x2F;图片&#x2F;截图&#x2F;截图 2022-07-15 19-11-41.png)</p><p>链路的时延带宽积又称为以比特为单位的链路长度</p><h4 id="6-往返时间"><a href="#6-往返时间" class="headerlink" title="6.往返时间"></a>6.往返时间</h4><p>数据双向交互一次的时间</p><p>我们简称为<strong>RTT(Round-Trip Time)</strong></p><h4 id="7-利用率"><a href="#7-利用率" class="headerlink" title="7.利用率"></a>7.利用率</h4><ul><li><p>信道利用率：有百分之几的时间是被利用的</p></li><li><p>网络利用率：全网络的信道利用率的加权平均。</p></li></ul><p>根据排队论，信道的利用率增大时，该信道引起的时延也会迅速增加</p><p>因此信道利用率并非越高越好</p><p>如果令$$D_0$$表示为网络空闲的时延，D表示当前的时延，那么在适当的假定条件下，可以用以下的简单公式来表示D与$$D_0$$和利用率U之间的关系<br>$$<br>D&#x3D;\frac{D_0} {1-U}<br>$$</p><ul><li>当网络的利用率达到50%时，时延加倍</li><li>当利用率超过50%时，时延急剧增大</li><li>当网络利用率接近100%时，时延趋于无穷大</li><li>依次一些拥有交大主干网的ISP通常会控制他们的新到利用率不超过50%,如果超过了，就扩容，增加带宽。</li><li><strong>注意</strong>：也不能太低，浪费了宝贵的通信资源，设定一个程序机制来根据情况动态调整网络中的通信量，是网络利用率保持在一个合理的范围内</li></ul><h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><p>即分组的丢失率</p><ul><li>一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li><li>可以分为接口丢包率，结点丢包率，链路丢包率，路径丢包率，网络丢包率等</li></ul><p>分组丢失主要有两种情况：</p><ul><li><p>分组在传输的过程中，出现误码，被结点丢弃；</p></li><li><p>分组到达一台队列已满的分组交换机时被丢弃；在通信量较大是就可能造成网络拥塞</p></li><li><p>因此 丢包率也可以反应网络的拥塞情况</p><ul><li><p>无拥塞时路径丢包率为0；</p></li><li><p>轻度拥塞时路径丢包率为1%~4%</p></li><li><p>严重时可达到5%~15%</p></li></ul></li></ul><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><p>有三种常见的计算机网络体系结构</p><ul><li><p><strong>法律上的国际标准(OSI)</strong></p><p>有七层：我不考研简单知道一下就够了，实际上开发不会用到这个框架</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE414.png"></p></li><li><p><strong>实际上的国际标准(TCP&#x2F;IP)</strong></p><p>表明了各种层的协议</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE.png"></p></li><li><p><strong>原理体系结构（在学习中我们主要遵循的）</strong></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE54.png"></p></li></ul><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p>分层的思想：以大化小，以小化了</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>需要解决：</p><ul><li><p>传输介质</p></li><li><p>物理接口</p></li><li><p>什么信号</p></li></ul><p>严格来说：传输媒体并不属于物理层</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>需要解决：</p><ul><li>目的主机该如何标识（主机编址）</li><li>目的主机识别出力分组数据的封装</li><li>协调多个主机之间的数据交换（一个网络或一段链路）</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>需要解决：</p><ul><li>网络以及网络中的各主机的共同编址问题（多个网络（路由））</li><li>路由器该怎么转发分组，路由的选择</li></ul><h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>需要解决：</p><ul><li>不同网络应用进程之间的通信(<strong>端到端</strong>的逻辑通信，不是端口到端口)</li><li>出错与异常的解决（丢包，误码等）</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>需要解决：</p><ul><li>不同网络进城程间的通信的基础上，规定特定的技术协议运用</li></ul><h3 id="分层的思想示例"><a href="#分层的思想示例" class="headerlink" title="分层的思想示例"></a>分层的思想示例</h3><p>简单的图解（图片来源湖南科技大学课程）：<br><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE2022-07-1623.png"></p><p>可以简单理解为：邮件的传输</p><p>个人主机：</p><ul><li><p>首先在<strong>应用层</strong>我们写了一个信件（<strong>报文</strong>） 内容规则可以是http，FTP，我们放在了自家的邮寄箱中 </p><p>这个时候来了个小哥来拿，他根据你在的地方，寄的信件内容类型呢，加了个邮局分局的地址等一系列信息，进行了一个简单的包装</p><p>（<strong>运输层</strong>根据tcp协议的规定 添加端口等一系列信息的<strong>TCP首部</strong>，成了一个<strong>TCP报文段</strong>）</p></li><li><p>拿到了你这个地区的邮局站，根据你要寄的地址分号码分类</p><p>（<strong>网络层</strong>加了个<strong>IP首部</strong>，成为了一个<strong>IP数据报</strong>）</p></li><li><p>然后根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>（<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p></li></ul><p>（帧交给物理层，加了个前导码，目的是为了让目的主机做好帧接受的准备）</p><p>​</p><p>通过链路到达了另外一个邮寄站点（路由） </p><ul><li><p>物理层将信件货物拆解，去掉上一个标签</p><p>（比特流化为帧）</p></li><li><p>再将其交付给处理信件地址的网络层解析（提取查找路由表，确定转发端口 指定下一个路由或者地址）</p></li><li><p>再重新根据地址选择海路或者陆地，天空等各种不同的路线，打上分类标识</p><p>(<strong>IP数据报</strong>给<strong>数据链路层</strong>处理，加了个<strong>ETH 首部</strong>和<strong>尾部</strong>，成为<strong>帧</strong>）</p></li><li><p>物理层将信件进行处理贴上标签，成为货物，开始邮寄</p><p>（<strong>帧</strong>交给<strong>物理层</strong>，加了个<strong>前导码</strong>，目的是为了让目的主机做好帧接受的准备）</p><p>以下内容都是同理</p><p>（重复解析封装一发送）</p></li></ul><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>任何可发送或接受信息的硬件或者软件进城</p><h4 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h4><p>相同层次中的实体</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120751857.png"></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>控制两个对等实体进行逻辑通信的规则的集合</p><p>注意：<strong>逻辑通信</strong>，的意思是，这个通信的的规则不是存在的，是假设的一种通信，单独简化研究，同理逻辑接口</p><p>三要素：</p><ul><li>语法：定义交换信息的格式（各种分组格式http ftp等）</li><li>语义：定义通信双方所要完成的操作</li><li>同步：定义收发双方的时序关系（<strong>三次握手</strong>）</li></ul><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120824649.png"></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>协议的控制下，<strong>对等实体</strong>的逻辑通信向上层提供服务</p><p>实现本层的协议需要，使用下面一层所提供的服务</p><p>协议是<strong>水平</strong>的，服务是<strong>垂直</strong>的</p><ul><li><p>服务访问点：相邻两层的逻辑接口，用于交换两层之间的是实体信息，区分不同的服务类型</p><ul><li>数据链路层的服务访问点为帧的<strong>类型字段</strong></li><li>网络层的服务访问点为ip数据报首部的<strong>协议字段</strong></li><li>运输层的服务访问点为<strong>端口号</strong></li><li><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/image-20220716120844704.png"></li></ul><p><strong>协议数据单元</strong></p><p>PDU：对等层次之间传送的数据包称为该层的协议数据单元</p><p>SDU：同一系统系统内服务数据单元 层与层之间交换的数据包成为服务数据单元</p><p>多个SDU 可以合成为一个PDU</p><p>一个SDU 也 可以分为多个PDU </p><p>比特-&gt;帧-&gt;ip数据段-&gt;tcp&#x2F;udp数据报-&gt;报文</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/%E6%88%AA%E5%9B%BE27.png"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不着急写，<del>随便做个思维导图糊弄一下</del></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB基础</title>
    <link href="/2022/07/14/GDB/"/>
    <url>/2022/07/14/GDB/</url>
    
    <content type="html"><![CDATA[<h2 id="GDB的调试"><a href="#GDB的调试" class="headerlink" title="GDB的调试"></a>GDB的调试</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gdb.jpg"></p><p><strong>GDB (GUN DEBUGGER)</strong></p><ol><li><p>设置断点</p></li><li><p>单步运行</p></li><li><p>查看变量值</p></li><li><p>动态改变执行环境</p></li><li><p>分析崩溃产生core文件</p></li></ol><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g test.cpp -o <span class="hljs-built_in">test</span><br><span class="hljs-comment">#生成可调试的执行文件</span><br></code></pre></td></tr></table></figure><h3 id="GDB-常用指令"><a href="#GDB-常用指令" class="headerlink" title="GDB 常用指令"></a>GDB 常用指令</h3><p>​说多也不多，毕竟现在调试大多都是gui调试，暂时很少直接用gdb命令行进行调试，写几个比较基础的<del>糊弄糊弄，就记住几个</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb [file]<br><span class="hljs-comment">#执行gdb调试</span><br><br><span class="hljs-comment">#进入gdb，可以直接输入命令</span><br><br><span class="hljs-built_in">break</span>(b) [num]<br><span class="hljs-comment">#在第num行代码设置断电</span><br><br>info breakpoint <br><span class="hljs-comment">#查看当前代码信息</span><br><br>display [变量]<br><span class="hljs-comment">#显示变量，在每次运行到断点显示值</span><br><br><span class="hljs-built_in">continue</span><br><span class="hljs-comment">#继续运行</span><br><br>run<br><span class="hljs-comment">#运行程序</span><br><br>quit<br><span class="hljs-comment">#退出GDB调试</span><br><br><span class="hljs-comment">#更多的我也记不到了，用men gdb指令查吧</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>GDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GDB</tag>
      
      <tag>C++</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>G++基础</title>
    <link href="/2022/07/14/Gcc/"/>
    <url>/2022/07/14/Gcc/</url>
    
    <content type="html"><![CDATA[<h2 id="G-x2F-GCC基础"><a href="#G-x2F-GCC基础" class="headerlink" title="G++&#x2F;GCC基础"></a>G++&#x2F;GCC基础</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com/img/gcc.png"></p><h3 id="编译过程有四步"><a href="#编译过程有四步" class="headerlink" title="编译过程有四步"></a>编译过程有四步</h3><ol><li><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -E test.cpp -o test.i<br><span class="hljs-comment">#预处理为.i文件</span><br><span class="hljs-comment">#头文件啥的的预定义啥的</span><br></code></pre></td></tr></table></figure></li><li><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -S test.i -o test.s<br><span class="hljs-comment">#编译为汇编语言输出为.s文件</span><br></code></pre></td></tr></table></figure></li><li><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -c test.s -o test.o<br><span class="hljs-comment">#编译为机器语言输出为.o</span><br></code></pre></td></tr></table></figure></li><li><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ test.o <span class="hljs-built_in">test</span><br><span class="hljs-comment">#生成为可执行文件test，二进制的文件</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="GCC-x2F-G-的优化选项"><a href="#GCC-x2F-G-的优化选项" class="headerlink" title="GCC&#x2F;G++的优化选项"></a>GCC&#x2F;G++的优化选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#基本优化</span><br>-O <br><span class="hljs-comment">#等效O1</span><br>-O0<br><span class="hljs-comment">#不做优化</span><br>-O1<br><span class="hljs-comment">#为默认优化</span><br>-O2<br><span class="hljs-comment">#默认优化+额外的调整</span><br>-O3<br><span class="hljs-comment">#默认优化+额外的调整+循环展开等处理特性的优化</span><br><br>g++ test.cpp -O2 -o <span class="hljs-built_in">test</span><br><span class="hljs-comment">#优化等级2生成可执行文件test</span><br></code></pre></td></tr></table></figure><p>所谓优化就是提升效率，编译时间换取执行效率</p><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span><span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> counter;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> result;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> temp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> five;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-comment">//有很多计算步骤都都在循环条件里</span><br><span class="hljs-keyword">for</span>(counter=<span class="hljs-number">0</span>;counter&lt;<span class="hljs-number">2000</span>*<span class="hljs-number">2000</span>*<span class="hljs-number">100</span>/<span class="hljs-number">4</span>+<span class="hljs-number">2010</span>;counter+=(<span class="hljs-number">10</span><span class="hljs-number">-6</span>)/<span class="hljs-number">4</span>)<br>&#123;<br><br>temp+=counter/<span class="hljs-number">1979</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)<br>&#123;<br>five=<span class="hljs-number">200</span>*<span class="hljs-number">200</span>/<span class="hljs-number">8000</span>;<br>result=counter;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;result=&quot;</span>&lt;&lt;result&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>测试优化O2与不优化O0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ test.cpp -O2 -o Youhua<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ test.cpp -O0 -o NotYouhua<br></code></pre></td></tr></table></figure><p>再依次执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">time ./Youhua<br>time ./NotYouhua<br></code></pre></td></tr></table></figure><p>可以看见优化后的执行效率相当高</p><h3 id="指定库文件与头文件"><a href="#指定库文件与头文件" class="headerlink" title="指定库文件与头文件"></a>指定库文件与头文件</h3><p>库的指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -lglog test.cpp<br><span class="hljs-comment">#链接golg 库</span><br><br>g++ -L/home/icrad/mylibfolder -lmylib test.cpp<br><span class="hljs-comment">#链接自己的指定的库文件夹下的库文件，需要大写</span><br></code></pre></td></tr></table></figure><p>头文件的指定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#一般来说，是不需要指定的，GCC默认去找include文件夹，当不存在时，就需要自己指定了头文件目录了</span><br><br>g++ -I/myinclude test.cpp<br></code></pre></td></tr></table></figure><h3 id="基本常用的其他项"><a href="#基本常用的其他项" class="headerlink" title="基本常用的其他项"></a>基本常用的其他项</h3><ul><li><p>-Wall</p><p>打印警告信息</p></li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -Wall test.cpp<br></code></pre></td></tr></table></figure><ul><li><p>-w</p><p>关闭警告信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -W test.cpp<br></code></pre></td></tr></table></figure></li><li><p>-std&#x3D;c++11</p><p>指定C++ 特性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -std=c++11 test.cpp<br></code></pre></td></tr></table></figure></li><li><p>-o</p><p>编译输出可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ test.cpp -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li><li><p>-D</p><p>定义宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//使用场景，可以在编译的时候选择是否 执行宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>     cout&lt;&lt;<span class="hljs-string">&quot;DEBUG_LOG&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Ubuntu,yes!&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译这个文件时可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -DDEBUG test.cpp -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>生成的执行文件会将宏定义中的代码输出</p><p>如果没有定义宏，只会输出</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Ubuntu,</span>yes!<br></code></pre></td></tr></table></figure></li></ul><h3 id="GDB调试参数"><a href="#GDB调试参数" class="headerlink" title="GDB调试参数"></a>GDB调试参数</h3><p>调试需要在编译时加入可调试信息才可使用GDB工具进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g test.cpp -o <span class="hljs-built_in">test</span><br><span class="hljs-comment">#生成可调试的执行文件</span><br></code></pre></td></tr></table></figure><h3 id="编译示例"><a href="#编译示例" class="headerlink" title="编译示例"></a>编译示例</h3><h4 id="多文件夹的目录结构"><a href="#多文件夹的目录结构" class="headerlink" title="多文件夹的目录结构"></a>多文件夹的目录结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── include<br>│   └── swap<span class="hljs-selector-class">.h</span><br>├── math<span class="hljs-selector-class">.cpp</span><br>└── <span class="hljs-attribute">src</span><br>    └── swap.cpp<br></code></pre></td></tr></table></figure><ul><li><h4 id="直接编译"><a href="#直接编译" class="headerlink" title="直接编译"></a>直接编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ math.cpp -std=c++11 src/swap.cpp -Iinclude<br><span class="hljs-comment">#记得引入头文件</span><br></code></pre></td></tr></table></figure><p>即可生成可执行文件a.out </p></li><li><h4 id="链接生成静态库"><a href="#链接生成静态库" class="headerlink" title="链接生成静态库"></a>链接生成静态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将src的文件夹下的swap.cpp生成为.o文件(汇编语言)</span><br><span class="hljs-built_in">cd</span> src/<br>g++ swap.cpp  -c -I../include<br><br><span class="hljs-comment">#进行归档操作</span><br>ar rs libswap.a swap.o<br><span class="hljs-comment">#作用是将swap.o归档为一个静态库文件</span><br><br><span class="hljs-built_in">cd</span> ..<span class="hljs-comment">#回到上级目录</span><br>g++ math.cpp -lswap -Lsrc -I\include -o static_swap<br><span class="hljs-comment">#链接指定的静态库进行编译</span><br><span class="hljs-comment">#最终得到可执行文件static_swap</span><br></code></pre></td></tr></table></figure></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul><li><h4 id="链接生成动态库"><a href="#链接生成动态库" class="headerlink" title="链接生成动态库"></a>链接生成动态库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src/<br><br>g++ swap.cpp -I../include -fPIC -shared -o libswap.so<br><span class="hljs-comment">#等价于</span><br>gccswap.cpp -I../include -c -fPIC <br><span class="hljs-comment">#生成.o文件</span><br>gcc -shared -o libswap.so swap.o<br><span class="hljs-comment">#生成静态库文件libswap.so</span><br><br>回到上级目录<br><span class="hljs-built_in">cd</span> ..<br>g++ math .cpp -Iinclude -lswap -Lsrc -o dyna_swap<br><span class="hljs-comment">#生成了可执行的文件dyna_swap</span><br><br></code></pre></td></tr></table></figure><p>动态库的可执行文件需要指定搜索路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">LD_LIBRARY_PATH=src ./dyna_swap<br><span class="hljs-comment">#指定了动态库的搜索路径运行该可执行文件</span><br></code></pre></td></tr></table></figure></li></ul><p>静态库与静态库的区别：大小，前者更大，动态库在调用相应函数时才会加载，所以在运行时，静态库不需要指定路径直接运行，而动态库需要。</p>]]></content>
    
    
    <categories>
      
      <category>GCC/G++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>G++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客的更新与备份</title>
    <link href="/2022/07/14/blog/"/>
    <url>/2022/07/14/blog/</url>
    
    <content type="html"><![CDATA[<h2 id="博客的更新与备份"><a href="#博客的更新与备份" class="headerlink" title="博客的更新与备份"></a>博客的更新与备份</h2><p>基于hexo的博客，搭建在github的仓库中</p><p>我们要实现在不同的系统与电脑中进行修改，与同步</p><h3 id="需要以下条件"><a href="#需要以下条件" class="headerlink" title="需要以下条件"></a>需要以下条件</h3><ol><li>Nodes.js</li><li>npm</li><li>git</li><li>博客源文件已经部署在github的仓库中（建议部署在分支中）</li></ol><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><p>首先新系统下的git配置，关键点在于重新配置ssh密匙</p><p>其次是Nodes.js与npm需要最新版本（有多新装多新</p><h3 id="初始化另一台电脑的操作"><a href="#初始化另一台电脑的操作" class="headerlink" title="初始化另一台电脑的操作"></a>初始化另一台电脑的操作</h3><ol><li><p>git bash 将远程仓库克隆到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 博客所在仓库地址<br></code></pre></td></tr></table></figure></li><li><p>进入项目目录，安装依赖启动博客服务器，生成静态文件</p><p>并在本地部署，通过<a href="http://localhost:4000进行访问">http://localhost:4000进行访问</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br>hexo g&amp;hexo s<br></code></pre></td></tr></table></figure></li><li><p>发布文章与之前相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo c&amp;hexo d -g<br></code></pre></td></tr></table></figure></li></ol><h3 id="另一台电脑同步"><a href="#另一台电脑同步" class="headerlink" title="另一台电脑同步"></a>另一台电脑同步</h3><p>​在博客目录下执行</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo d -g</span><br></code></pre></td></tr></table></figure><p>​后执行更新原始文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull <br>git add -A<br>git commit -m <span class="hljs-string">&quot;描述&quot;</span><br>git push origin hexo <br></code></pre></td></tr></table></figure><p>​每次有新的操作的时候，在另一台电脑上也同时进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull hexo <span class="hljs-comment">#拉取源文件</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake基础</title>
    <link href="/2022/07/12/cmake01/"/>
    <url>/2022/07/12/cmake01/</url>
    
    <content type="html"><![CDATA[<h2 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a><a href="">Cmake</a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux下cmake编译工具使用过程与windows的操作大同小异</p><p>单独开一篇文章对指令基础做个总结</p><h3 id="Corss-platform-development"><a href="#Corss-platform-development" class="headerlink" title="Corss-platform development"></a>Corss-platform development</h3><p>跨平台：毕竟做linux下的c++ 开发不用cmake 可不行</p><h3 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h3><p>指令格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">指令（参数1 参数2）<br></code></pre></td></tr></table></figure><p>不同参数需要用<strong>空格</strong>或者<strong>分号</strong>隔开</p><p>指令无关大小写，<strong>参数</strong>和<strong>变量</strong>是大小写<strong>相关</strong>的</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ul><li><p><strong>cmake_minimum_required</strong>:指定cmake版本</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#cmake_minimum_required -指定cmake的最小版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.8</span>.<span class="hljs-number">3</span>)<br><br></code></pre></td></tr></table></figure></li><li><p><strong>project</strong>:定义工程名称</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#指定 project(projectname [CXX][C][java])</span><br><span class="hljs-keyword">project</span>(HEllO CXX)<br><span class="hljs-comment">#指定工程名称为HELLO 支持C++ </span><br></code></pre></td></tr></table></figure></li><li><p><strong>set</strong>:显示的定义变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(SRC sayhello.cpp hello.cpp)<br><span class="hljs-comment">#定义一个SRC变量 引用SRC 相当于引用sayhello.cpp hello.cpp</span><br></code></pre></td></tr></table></figure></li><li><p>**include_directories **向工程添加多个特定的头文件搜索路径</p><p>假设文件夹路径是这样的格式</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad">└── myfolder<span class="hljs-meta"><span class="hljs-keyword">include</span></span><br><span class="hljs-meta">    └── othersfolderinclude</span><br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include_directories</span>(../myfolderinclude ./othersfolderinclude)<br><span class="hljs-comment">#类似于g++中的-I </span><br></code></pre></td></tr></table></figure></li><li><p><strong>link_directories</strong>:向工程添加多个指定的库文件搜索路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>(../myfolderlib ./othersfolderlib)<br></code></pre></td></tr></table></figure></li><li><p><strong>add_library</strong>:生成库文件</p><p>比较重要的语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># add-library(libname[SHARED|STATIC|MODULE][EXCLUDE_FORM_ALL]source1 source2 ..sourceN)</span><br><span class="hljs-comment">#通过变量SRC （上方代码中定义的SRC变量引用）生成动态[SHARED] 的libhellp.so文件</span><br><span class="hljs-keyword">add_library</span>(hello SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-comment">#注意，变量的引用使用$&#123;&#125;</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>add_compile_options</strong>：添加编译参数</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_compile_options</span>(-Wall -std=c++ -O2)<br><span class="hljs-comment">#分别添加的是警告显示，定义语言特性，优化级数</span><br></code></pre></td></tr></table></figure></li><li><p><strong>add_executable</strong> :生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-comment">#将main.cpp编译为 mian</span><br></code></pre></td></tr></table></figure></li><li><p><strong>target_link_libraries</strong>为target链接的动态库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#等价于g++ -l 编译器参数</span><br><span class="hljs-keyword">target_link_libraries</span>(main hello)<br><span class="hljs-comment">#将hello动态库链接到可执行文件main </span><br></code></pre></td></tr></table></figure></li><li><p><strong>add_subdirectory</strong>向当前的工程添加存放源文件的子目录，指定中间二进制和目标二进制的存放位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_subdirectory</span>(src)<br><span class="hljs-comment">#添加一个src子目录,src中需要也有一个CMakelists.txt</span><br></code></pre></td></tr></table></figure></li><li><p><strong>aux_source_directory</strong> 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">aux_source_directory</span>(. SRC)<br><span class="hljs-comment">#定义. （就是一个目录下所有的源文件） 为SRC变量</span><br>add_exrcutable(mian <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-comment">#引用SRC 生成可执行文件</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><ul><li><p><strong>CMAKE_CXX_FLAGS</strong>：编译选项</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#在CMAKE_CXX_FALGS编译选项后加 -std=c++11</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FALGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)<br><span class="hljs-comment">#类似CMAKE_CXX_FALGS+=-std=c++11</span><br></code></pre></td></tr></table></figure></li><li><p><strong>CMAKE_BUILDTYPE</strong>：编译类型</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Debug)<br><span class="hljs-comment">#编译为Debug</span><br><span class="hljs-keyword">set</span>(CMAKE_BUILD_TYPE Release)<br><span class="hljs-comment">#编译为Release</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="CMake编译"><a href="#CMake编译" class="headerlink" title="CMake编译"></a>CMake编译</h3><p>手动编写CMakeLists.txt</p><h4 id="两种编译规则"><a href="#两种编译规则" class="headerlink" title="两种编译规则"></a>两种编译规则</h4><ul><li><p>​子目录无CMakeLists.txt</p></li><li><p>​子目录包含CMakeLists.txt</p></li></ul><h4 id="两种构建方式"><a href="#两种构建方式" class="headerlink" title="两种构建方式"></a>两种构建方式</h4><ul><li><p>内部构建（不用</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss">单纯的直接cmake 当前文件夹生成makefile<br>再<span class="hljs-built_in">make</span> 执行makefile 生成可执行文件等等，<br>因为都生成在当前文件夹很乱，目录结构不清析。<br>所以不用<br></code></pre></td></tr></table></figure></li><li><p>外部构建（常用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在当前目录下新建一个build </span><br><span class="hljs-built_in">mkdir</span> build <br><span class="hljs-comment">#跳转</span><br><span class="hljs-built_in">cd</span> build <br><span class="hljs-comment">#执行cmake,执行上层主目录下的CMakelists.txt</span><br>cmake .. <br><span class="hljs-comment">#生成makefile和其他文件</span><br>make <br><span class="hljs-comment">#执行</span><br><span class="hljs-comment">#所有的编译输出文件都存在了build目录中</span><br><span class="hljs-comment">#互不干扰结构明了</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="CMake在vs-code下的甜点"><a href="#CMake在vs-code下的甜点" class="headerlink" title="CMake在vs.code下的甜点"></a>CMake在vs.code下的甜点</h3><p>​当我们需要在vs.code调试CMake代码生成的可执行文件的时候，可以设置launch.json和一个task.json的调试脚本<del>个人觉得，只是锦上添花的操作，除了tasks.josn,我们可以写bat，或者shell都可以而且代码更少</del>，达到可以直接运行调试的效果，不需要在修改源代码后，再手动输入cmake与make 重新编译，实现自动化操作</p><p>​首先我们选择运行与调试默认生成的launch.json，给出一个文件目录的示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── build<br>│   ├── CMakeCache.txt<br>│   ├── CMakeFiles/....<br>│   ├── cmake_install.cmake<br>│   ├── Makefile<br>│   └── main<span class="hljs-comment">#这个是生成的可执行文件</span><br>├── CMakeLists.txt<br>├── include<br>│   ├── gun.h<br>│   └── soilder.h<br>├── main.cpp<br>└── src<br>    ├── gun.cpp<br>    └── soilder.cpp<br></code></pre></td></tr></table></figure><p>根据文件目录我们将默认生成的launch.json进行改动</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(gdb) 启动&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/main&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//这里需要更改为你的可执行文件</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <br>            <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//这是里我们需要修改的地方</span><br>            <span class="hljs-comment">//上方代码的意思是，执行调试前的前置任务，所以我们需要再生成一个tasks.json文件</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span><span class="hljs-comment">//默认添加</span><br>            <br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>再编写一个简单的tasks.json，可以直接在vs.code终端菜单下直接生成一个简单的任务范例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><span class="hljs-comment">//指定工作区下的目录</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;step1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;..&quot;</span>  <span class="hljs-comment">//参数</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;step2&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">true</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Build&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;dependsOrder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sequence&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//依赖顺序设置为顺序执行</span><br>            <span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span>   <span class="hljs-comment">//顺序</span><br>                <span class="hljs-string">&quot;step1&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;step2&quot;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用VScode与CMake做C++开发环境</title>
    <link href="/2022/07/11/zatan01/"/>
    <url>/2022/07/11/zatan01/</url>
    
    <content type="html"><![CDATA[<p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//v2-49a45b8c622434dbf79463ccab9fa627_720w.png"></p><h3 id="啥事cmake"><a href="#啥事cmake" class="headerlink" title="啥事cmake?"></a>啥事cmake?</h3><p>​CMake 是一个开源、跨平台的工具，旨在构建、测试和打包您的程序。CMake 用于使用简单的平台和编译器独立配置文件来控制程序编译过程，并生成可在您选择的编译器环境中使用的主机配置文件和项目文件。这套 CMake 工具由 Kitware 创建，以满足 ITK 和 VTK 等开源项目对强大的跨平台构建环境的需求。</p><p>​说白了，这玩意只是个配置器，配置你的编译器该如何进行编译</p><h3 id="cmake的好处："><a href="#cmake的好处：" class="headerlink" title="cmake的好处："></a>cmake的好处：</h3><pre><code class="hljs">&lt;center&gt;“Write once, run everywhere”    &lt;/center&gt;</code></pre><p>​非常好理解，就是只写一次，到处运行</p><p>​对我来说就三个字：跨平台。</p><h3 id="cmake的缺点："><a href="#cmake的缺点：" class="headerlink" title="cmake的缺点："></a>cmake的缺点：</h3><p>​缺点：麻烦，步骤繁多</p><p>​断点调试挺麻烦的，VScode里的插件可以，但是需要对luanch.json和tasks.json进行修改，尤其是出现多个目录多个源文件等大项目的编译，修改虽然不复杂，但是麻烦。想要调试添加额外配置参数来打印所执行的所有代码及行号，插入log等方式检查问题。</p><p>​有这弱语言的共通问题，就是容易出问题。</p><p>总而言之，挺麻烦的</p><p><del>要不是最近需要将Qmake项目迁移到cmake，还真不想用这玩意</del></p><h3 id="利用CMake编译一个简单的C-程序"><a href="#利用CMake编译一个简单的C-程序" class="headerlink" title="利用CMake编译一个简单的C++程序"></a>利用CMake编译一个简单的C++程序</h3><p>首先vscode需要下载两个插件，CMAKE与C&#x2F;C++,这些我默认就有，因为在下载之前就一直用着VS2022，模块化无脑安装。</p><p>然后配置CMake和MINGW环境变量，这些我默认也有，安装Qt自带，直接指向Qt&#x2F;tools里的对应路径即可。</p><p>前提条件准备得那是相当充足。</p><p>直接就随便顺手写一个冒泡排序的小例子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//创建这样一个目录结构</span><br>└── <span class="hljs-attribute">src</span><br>    └── sort<span class="hljs-selector-class">.cpp</span><br>└── include<br>    └── sort<span class="hljs-selector-class">.h</span><br>└── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span>    <br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sort.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">7</span>&#125;;<br>    Sort sort;<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">/* code */</span><br>        cout&lt;&lt;a[i]&lt;&lt;endl;<br>    &#125;<br>    sort.<span class="hljs-built_in">test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>sort.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> temp;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x[<span class="hljs-number">10</span>])</span></span><br><span class="hljs-function">    </span>&#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        &#123;   <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>-i<span class="hljs-number">-1</span>; j++)<br>            &#123;<br>                 <br>                <span class="hljs-keyword">if</span>(x[j]&lt;x[j+<span class="hljs-number">1</span>])<br>                &#123;<br>                    temp=x[j];<br>                    x[j]=x[j+<span class="hljs-number">1</span>];<br>                    x[j+<span class="hljs-number">1</span>]=temp;<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br><br>    &#125;<br><br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>sort.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sort.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort::test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;test\n&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>到这里，前提源文件准备工作结束</p><p>开始编写CMakelists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#这种写法非常简单，无脑摁写，但是不够直观</span><br><span class="hljs-keyword">project</span>(Sorttest) <span class="hljs-comment">#项目名称</span><br><span class="hljs-keyword">aux_source_directory</span>(src SRC_SUB) <span class="hljs-comment">#项目根目录下的所有子项目</span><br><span class="hljs-keyword">aux_source_directory</span>(. SRC_CUR)  <span class="hljs-comment">#同理</span><br><span class="hljs-keyword">add_executable</span>(sort <span class="hljs-variable">$&#123;SRC_SUB&#125;</span> <span class="hljs-variable">$&#123;SRC_CUR&#125;</span>) <span class="hljs-comment">#同理</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-keyword">include</span>) <span class="hljs-comment">#头文件包含目录</span><br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>) <span class="hljs-comment">#最低版本需求</span><br><span class="hljs-keyword">project</span>(Sorttest) <span class="hljs-comment">#项目名</span><br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment">#头文键包含</span><br><br><span class="hljs-comment">#添加源文件</span><br><span class="hljs-keyword">add_executable</span>(main<br>               <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/main.cpp <span class="hljs-comment">#这个路径看这个main.cpp位于哪里了              </span><br>               <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/sort.cpp)<br></code></pre></td></tr></table></figure><p>后者相对前者直观一些，效果都是一样的</p><p>在CMakelist.txt视窗中按下快捷键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">shift</span>+ctrl+p<br></code></pre></td></tr></table></figure><p>唤起</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711223231514.png" alt="image-20220711223231514"></p><p>选择CMake配置，一切自动化帮你构建build文件夹目录</p><p>再新终端下方 cd跳转到build目录中</p><p>输入以下指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">cmake ..<br></code></pre></td></tr></table></figure><p>运行如下工具 (这个是根据build的中的Makefile中的规则经行对源文件进行编译)</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">mingw32-<span class="hljs-keyword">make</span>.<span class="hljs-keyword">exe</span> <br></code></pre></td></tr></table></figure><p>可以看到运行后在Bulid目录下多出一个sort.exe</p><p>在终端中输入运行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">.\<span class="hljs-keyword">sort</span>.<span class="hljs-keyword">exe</span><br></code></pre></td></tr></table></figure><p>既可以看到程序的输出结果：</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220711224250666.png" alt="image-20220711224250666"></p><p>至此编译到此结束</p>]]></content>
    
    
    <categories>
      
      <category>CMake,C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>CMake</tag>
      
      <tag>VScode</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux基础00</title>
    <link href="/2022/07/11/linux00/"/>
    <url>/2022/07/11/linux00/</url>
    
    <content type="html"><![CDATA[<h2 id="linux基础中的基础"><a href="#linux基础中的基础" class="headerlink" title="linux基础中的基础"></a>linux基础中的基础</h2><h3 id="linux-的基础命令"><a href="#linux-的基础命令" class="headerlink" title="linux  的基础命令"></a>linux  的基础命令</h3><h4 id="指令默认格式"><a href="#指令默认格式" class="headerlink" title="指令默认格式"></a>指令默认格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">指令 [选项] [操作对象]<br></code></pre></td></tr></table></figure><p>注意：中括号代表的意思是可以省略内容不输入，一样可以运行该指令</p><p>默认打开终端</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">Ctrl+Alt+<span class="hljs-built_in">T</span><br></code></pre></td></tr></table></figure><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>打印当前所在的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><p>打印当前目录下的文件与文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>ls的用法扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> [文件路径]<br><span class="hljs-comment">#文件路径：</span><br><span class="hljs-comment">#相对路径or绝对路径</span><br></code></pre></td></tr></table></figure><p>打开文件目录下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> 选项 [文件路径]<br><span class="hljs-comment">#选项：指定方式显示</span><br></code></pre></td></tr></table></figure><p>选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a <span class="hljs-comment">#表示显示所有的(all)文件与文件夹，包括隐藏</span><br>-l <span class="hljs-comment">#表示详细列表的方式展示(list)</span><br>-h <span class="hljs-comment">#以可读性较高的形式显示</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="cd-chanage-directory"><a href="#cd-chanage-directory" class="headerlink" title="cd(chanage directory)"></a>cd(chanage directory)</h4></li></ul><p>：跳转目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>  <br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-comment">#作用都是直接回到家目录</span><br></code></pre></td></tr></table></figure><p>与ls类似的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> [文件路径]<br><span class="hljs-comment">#文件路径：</span><br><span class="hljs-comment">#相对路径or绝对路径</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a>mkdir(make directories)</h4></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> myfolder <br><span class="hljs-comment">#在当前的目录下创建一个mydir文件夹</span><br><span class="hljs-built_in">mkdir</span> myfolder1 myfolder2<br><span class="hljs-comment">#在当前目录下创建两个文件夹，分别是 myfolder1，myfolder2</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/a/b/c<br><span class="hljs-comment">#-p 选项是必须的</span><br><span class="hljs-comment">#当前家目录下(~)创建多层不存在的目录</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="touch-change-file-timestamps"><a href="#touch-change-file-timestamps" class="headerlink" title="touch-change file timestamps"></a>touch-change file timestamps</h4></li></ul><p>作用：创建文件（虽然本意不是这个）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span>  test.txt<br><span class="hljs-comment">#在当前目录下生成一个 test.txt文件</span><br><span class="hljs-built_in">touch</span> ../test1  <span class="hljs-comment">#（相对路径)</span><br><span class="hljs-comment">#在当前目录的上级目录下生成一个 test1文件</span><br><span class="hljs-built_in">touch</span> ~/test2  <span class="hljs-comment">#(绝对路径)</span><br><span class="hljs-comment">#在~（家)目录下生成一个 test2文件</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm (remove )"></a>rm (remove )</h4></li></ul><p>删除指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [选项] [路径]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> test.txt<br><span class="hljs-comment">#删除文件</span><br><span class="hljs-built_in">rm</span> ../test1<br><span class="hljs-comment">#删除上级目录的文件</span><br><span class="hljs-built_in">rm</span> ~/test2<br><span class="hljs-comment">#在~（家)目录下删除test2文件</span><br></code></pre></td></tr></table></figure><p>删除文件夹和文件夹下的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf [文件夹路径]<br><span class="hljs-comment">#删除文件夹</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a>cp(copy)</h4></li></ul><p>作用：复制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> [复制的文件路径] [副本的文件路径]<br><span class="hljs-built_in">cp</span> ../test ./test.txt<br><span class="hljs-comment">#上级的目录下的test文件复制到当前目录下 并且换了个名字（加了个.txt后缀名）</span><br></code></pre></td></tr></table></figure><p>复制文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -r [文件夹路径] [副本文件夹的路径]<br><span class="hljs-comment">#-r是递归的意思</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="mv-move"><a href="#mv-move" class="headerlink" title="mv (move)"></a>mv (move)</h4></li></ul><p>作用：移动文件位置，或者重命名文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> <span class="hljs-built_in">test</span> test.txt<br><span class="hljs-comment">#重新命名test文件为 test.txt(在当前目录下)</span><br><span class="hljs-comment">#等效 mv test ./test.txt</span><br><br><span class="hljs-built_in">mv</span> <span class="hljs-built_in">test</span> ../test.txt <br><span class="hljs-comment">#重新命名并且移动到了上级目录中</span><br><br></code></pre></td></tr></table></figure><ul><li><h4 id="men-menu"><a href="#men-menu" class="headerlink" title="men (menu)"></a>men (menu)</h4>说明书目录:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">man <span class="hljs-built_in">ls</span><br><span class="hljs-comment">#参看命令ls的手册</span><br><br><span class="hljs-comment">#在man中无cd的手册</span><br><span class="hljs-comment">#我们在cd help中可以看到</span><br><br>man man <br><span class="hljs-comment">#参看man的命令手册</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot<br><span class="hljs-comment">#立即重启</span><br></code></pre></td></tr></table></figure></li><li><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>关机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">shutdown -h [时间]<br><br>shutdown -h now <br><span class="hljs-comment">#立即关机</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="文件的编辑"><a href="#文件的编辑" class="headerlink" title="文件的编辑"></a>文件的编辑</h3><ul><li><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>一句话：<strong>编辑器之神</strong></p><p>安装：(Ubuntu LTS 22.04)</p><p><del>想用的时候居然没有安装</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install vim<br><br><span class="hljs-comment">#建议安装：</span><br> ctags vim-doc vim-scripts<br><span class="hljs-comment">#顺带一并安装#都是vim的插件</span><br>sudo apt-get install ctags<br>sudo apt-get install vim-doc<br>sudo apt-get install vim-scripts<br><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/2018101511335895?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9jeTY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="助记图"></p><p>这里不继续详细的说明，将会新开一篇文章来记录VIM 的使用</p><p>简单的使用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vim</span><span class="hljs-meta"> [file]</span><br><span class="hljs-comment">#直接打开文本</span><br></code></pre></td></tr></table></figure><p>终端直接变成了文本编辑器</p><p>键盘摁下 i 键</p><p>可以可以看见左下角状态变更为 插入 （insert）</p><p>此时即可以输入文本进行编辑了</p><p>保存需摁下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">shift</span> <br></code></pre></td></tr></table></figure><p>输入： </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:w</span> <span class="hljs-comment">#保存文本</span><br><span class="hljs-symbol">:q</span> <span class="hljs-comment">#退出vim编辑器</span><br></code></pre></td></tr></table></figure></li><li><h4 id="geidt"><a href="#geidt" class="headerlink" title="geidt"></a>geidt</h4><p>纯文本的编辑器，ubuntu 都是自带的,默认的编辑器</p><p>简单的使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim [file]<br><span class="hljs-comment">#直接打开文本编辑框，</span><br></code></pre></td></tr></table></figure><p>与vim不同点在于 弹出的geidt的编辑界面，对新手挺友好的</p><p>直接按照Windows下的记事本使用即可</p></li><li><h4 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h4><p>与Vim类似，但是比vim简单而且小巧</p><p>简单的使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano [file]<br><span class="hljs-comment">#终端变成nano界面</span><br></code></pre></td></tr></table></figure><p>指令都在下方直观的显示出来</p><p>修饰键是Ctrl ，使用起来非常简单</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt学习第一节|Qt基础</title>
    <link href="/2022/06/26/QTstudy/"/>
    <url>/2022/06/26/QTstudy/</url>
    
    <content type="html"><![CDATA[<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628200812272.png"></p><p>基于C++的跨平台的图形引擎</p><p>发行于1991年 <del>就记了个大概，不知道的咱可以百度不是</del></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.跨平台</p><p>2.接口简单</p><p>3.一定程度简化了内存回收</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.WPS</p><p>2.linux-KDE</p><p>3.vlc多媒体播放</p><h2 id="创建第一个Qt"><a href="#创建第一个Qt" class="headerlink" title="创建第一个Qt"></a>创建第一个Qt</h2><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111650699.png"></p><p>系统环境：windows11<br>软件环境：Qt6.2.3(MSVC 2019 64bit)</p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>一开始可以直接打开官方的Qt Creator，暂且不需要使用MSVS上进行调试开发，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">file</span>-&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">project</span><br></code></pre></td></tr></table></figure><h4 id="选择模板（tempates"><a href="#选择模板（tempates" class="headerlink" title="选择模板（tempates)"></a>选择模板（tempates)</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110514448.png"></p><p>默认<strong>Qt widget application</strong>（最基本的，也是最常用的窗口应用）</p><p>新建文件名和选择路径需要注意：（名字 路径，都不要有中文）</p><h4 id="选择构建系统（build-system）"><a href="#选择构建系统（build-system）" class="headerlink" title="选择构建系统（build system）"></a>选择构建系统（build system）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628110646484.png"></p><p>因为做的是第一个程序，要快速上手选择qmake（Qt自带，不过个人建议cmake）。</p><h4 id="细节（details）"><a href="#细节（details）" class="headerlink" title="细节（details）"></a>细节（details）</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628111032398.png"></p><p>名字都可以默认，也可以更改随喜好，注意事项（中文不行，空格禁止）</p><p><strong>重点在于Base class（基类）</strong></p><p>窗口类型介绍：QMainWindow、QWidget、QDialog三个类都可以用来创建窗口，可以直接使用，也可以继承后使用。</p><p>　　QMainWindow窗口包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式，也可以说是GUI程序的主窗口。</p><p>　　QDialog是对话框窗口的基类。对话框主要用来执行短期任务，或者与用户进行互动，它可以是模态的，也可以是非模态的。他没有菜单栏、工具栏、状态栏等。</p><p>　　如果是主窗口，就使用QMainWindow类；</p><p>　　如果是对话框，就使用QDialog类；</p><p>　　如果不确定，有可能作为顶层窗口，也有可能嵌入到其他窗口，就使用QWidget类。</p><p>​第一个程序我们可以默认直接选QWidget类</p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202512898.png"></p><p>这个是生成一个UI界面，一开始做第一个程序可以不选，因为需要学习一下UI底层的实现代码。</p><h4 id="Kits-选择"><a href="#Kits-选择" class="headerlink" title="Kits 选择"></a>Kits 选择</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202115437.png"></p><p>这里我因为安装时选择需要MSVC调试开发，所以会出现MSVC，默认有MInGW,一般可全选，创建第一个项目的时候不容易出错</p><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628202912401.png">选择版本控制系统，一开始第一个程序用不上，实际是做大项目开发用的源代码管理工具选择，比如说我们常见的git ，svn等。具体可看这篇CSDN博文：<a href="https://blog.csdn.net/weixin_45627194/article/details/110050361">源代码管理工具 </a></p><p>点击完成至此，创建一个Qt项目完成</p><h4 id="常用快捷键："><a href="#常用快捷键：" class="headerlink" title="常用快捷键："></a>常用快捷键：</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>ctrl / 注释<br><span class="hljs-regexp">//</span>ctrl r 运行<br><span class="hljs-regexp">//</span>ctrl b 编译<br><span class="hljs-regexp">//</span>ctrl i 自动对齐<br><span class="hljs-regexp">//</span>F4 快捷切换同名文件<br></code></pre></td></tr></table></figure><h3 id="生成的代码文件"><a href="#生成的代码文件" class="headerlink" title="生成的代码文件"></a>生成的代码文件</h3><h3 id="需要掌握的："><a href="#需要掌握的：" class="headerlink" title="需要掌握的："></a>需要掌握的：</h3><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><br><span class="hljs-comment">//argc为命令行变量的数量</span><br><span class="hljs-comment">//*argv变量的数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<span class="hljs-comment">//a即为应用程序对象，有且仅有一个</span><br>    Widget w;<br>    <span class="hljs-comment">//窗口对象 （子类widger ：public QWidget）</span><br>    <span class="hljs-comment">//默认不显示；</span><br>    <span class="hljs-comment">//需要以下函数调用，调用的是顶层窗口函数</span><br>    w.<span class="hljs-built_in">show</span>();<br><br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>     <span class="hljs-comment">//让应用程序对象进入消息循环机制</span><br>    <span class="hljs-comment">//类似while（true）</span><br>    <span class="hljs-comment">//触发条件退出循环结束程序</span><br>    <span class="hljs-comment">//堵塞你的代码运行</span><br>    <span class="hljs-comment">//与system(&quot;pause&quot;)作用类似</span><br><br>    <span class="hljs-comment">//之后的代码依旧会顺序执行。</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>widget.cpp</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &quot;widget.h&quot;</span><br><span class="hljs-comment">#include&lt;QDebug&gt;</span><br><span class="hljs-comment">#include&lt;QPushButton&gt;</span><br><br><br>Widget::Widget(QWidget *parent): QWidget(parent)<span class="hljs-regexp">//</span>这不就是初始化列表么<br>&#123;<br>    <span class="hljs-regexp">//</span>创建一个按钮<br>    QPushButton *btn = new QPushButton;<br>    <span class="hljs-regexp">//</span>btn-&gt;show();<span class="hljs-regexp">//</span>单独弹出一个顶层的窗口来弹出窗口控件<br>    <span class="hljs-regexp">//</span>所以我们需要将Btn对象依赖在Widget窗口中<br>    btn-&gt;setParent(this);<br>    <span class="hljs-regexp">//</span>函数名直译，设置父母。<br><br>    <span class="hljs-regexp">//</span>给按钮显示值<br>    btn-&gt;setText(<span class="hljs-string">&quot;第一个按钮&quot;</span>);<br><br><span class="hljs-regexp">//</span>    创建第二个按钮<br>    QPushButton *btn2=new QPushButton(<span class="hljs-string">&quot;第二个按钮&quot;</span>,this);<span class="hljs-regexp">//</span>有参构造<br>    <span class="hljs-regexp">//</span>但是有问题，只会按照空间的大小创建窗口<br>    <span class="hljs-regexp">//</span>我们可以自己设定默认窗口大小<br>    <span class="hljs-regexp">//</span>可修改<br>    resize(<span class="hljs-number">600</span>,<span class="hljs-number">400</span>);<br>   <span class="hljs-regexp">//</span>我想要窗口固定大小，就需要<br>    setFixedSize(<span class="hljs-number">600</span>,<span class="hljs-number">400</span>);<br>    <span class="hljs-regexp">//</span>同理，按钮需要定义大小也可以<br>    btn-&gt;resize(<span class="hljs-number">50</span>,<span class="hljs-number">20</span>);<br><br>    <span class="hljs-regexp">//</span>但是运行还是只有一个按钮没因为默认位置将第一个按钮覆盖显示了，我们需要移动他<br>    btn2-&gt;move (<span class="hljs-number">100</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-regexp">//</span>这样我们就可以看到两个按钮了，这个时候我也可以更改应用标题<br>    setWindowTitle(<span class="hljs-string">&quot;第一个Qt&quot;</span>);<br><br><br>    <span class="hljs-regexp">//</span>问题：<br>    <span class="hljs-regexp">//</span>我们的按钮都是开辟于堆区，不用去考虑释放内存的问题吗<br>    <span class="hljs-regexp">//</span>引入对象树的概念<br>    <span class="hljs-regexp">//</span>setparent(this)<br>    <span class="hljs-regexp">//</span>关键函数：<br><span class="hljs-regexp">//</span>将这个类与类下的对象放入对象树中<br><span class="hljs-regexp">//</span>析构的时候   --接以下注释--<br>&#125;<br><br>Widget::~Widget()<br>&#123;<br>    qDebug(<span class="hljs-string">&quot;父类的析构&quot;</span>);<br>    <br>    <span class="hljs-regexp">//</span>先执行自行添加的代码，然后<br>    <span class="hljs-regexp">//</span>底层在释放这个类之前判断是否有子类，如果有就找到子类析构，再执行自添加的代码，再判断，<br>    <span class="hljs-regexp">//</span>直到找不到子类，确认是最后一个子类后释放这个子类下的对象<br>    <span class="hljs-regexp">//</span>所以就会出现，先输出父类析构代码再输出子类的析构代码的情况<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h4><p>Qt的学习重点，Qt的引以为豪的部分。</p><p>怎了么理解信号与槽？</p><p>我们现看个例子：</p><p>我打开一盏灯，灯亮了</p><p>信号的发送者，发送具体信号，信号的接收者，槽函数：信号的处理</p><p>connect （信号的发送者，发送具体信号；信号的接收者，信号的处理）</p><p>信号槽的优点，松散耦合：可以理解为信号发送与接收者没啥关联，通过connect的链接两端耦合在一起</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//连接函数</span><br><span class="hljs-built_in">connect</span>(mybtn  ,&amp;QPushButton::clicked,<span class="hljs-keyword">this</span>,&amp;Widget::close);<br><span class="hljs-comment">//参数1：信号发送者，参数2：信号这里填入地址；</span><br><span class="hljs-comment">//参数3：信号接收者，参数3；同样是地址槽（槽函数，执行行为）</span><br></code></pre></td></tr></table></figure><p>QT库中有现成的信号与槽函数，当然我们也可以自己写一个，具体实现：</p><p>更多内容在下一篇文章再说，<del>还没写呢。先玩游戏去辣</del></p><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220628211036994.png"></p>]]></content>
    
    
    <categories>
      
      <category>Qt学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt6.2.3，C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>觉得博客很空总想写点什么？</title>
    <link href="/2022/06/26/others1/"/>
    <url>/2022/06/26/others1/</url>
    
    <content type="html"><![CDATA[<h2 id="个人最近杂谈："><a href="#个人最近杂谈：" class="headerlink" title="个人最近杂谈："></a>个人最近杂谈：</h2><p>​百无聊赖，不知道写些什么，也不知道要做些什么（虽然有一堆事请要做，但是就是不想干），想要说些什么，却不知道写啥，肚子里憋不出一点墨水，确实很久都没有翻过书了，既然开始建立了博客，就得写写博文，平常连论文都憋不出几个字，但是还得整些文化人的东西，果然有必要增加阅读量的，总不能一天到晚看番剧在评论区玩玩烂梗，总不能一直写大白文。 </p> <center> <img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//image-20220626222334097.png" r style="zoom:40%;" /></center><p>​最近在网络上看到的段子：奶酪洞越多，奶酪越少，而奶酪越多，奶酪洞越多，得出结论：奶酪越少，奶酪就越少；<br>​乍一看，嗯，很合理。虽然仔细思考一看有很多漏洞，但是依旧合理，首先第一眼能看到最大的问题就是，结论纯纯的废话：<del>毕竟正在看这篇文章的一定在看这篇文章罢</del> </p><p>​我们可以简单的分析一下，首先<strong>典型的演绎论证，需要：前提，论证，结论</strong>。 这个是我们常用的论证手段。这条段子咱们可以处理为：</p><p>​前提：如果奶酪洞越多，奶酪越少。论证：奶酪越多，奶酪洞越多。</p><p>​结论：奶酪越少，奶酪就越少；</p><p>​前提乍一看是真，但是我的理解是：多和少这个概念其实是通过对比而言的，怎么定义多，怎么定义少？所以原前提对我个人而言是不能确定的（虽然一般都会默认比较的是自身的体重体积大小 的变化前与变化后）。我们需要让前提更严谨一些：有一个奶酪，体积重量大小都是一个固定的量，不会产生莫名其妙的增加或减少，只会通过奶酪洞的形式变化，如果奶酪洞越多，奶酪的重量大小和体积大小越少。这样就可以确定该前提为真。<br>​虽然看都很合理，但是蕴含悖论：前提永远都是真的 ，看到论证实际上也都是为了配合前提而多说的废话，用来强调前提，而重要的是，结论也永远都是真的 奶酪越少，奶酪就越少；不谈语句问题。这也是个合理的论证，因为不存在一种情况，使得前提为真而结论为假。</p><p>​总结：虽然合理但是，无效。</p><p>​咳咳，扯远了<del>想到什么写什么，完全没有规划的那种</del> 来形容我现在的思想情况吧：学的越多越感觉自己懂得越少（拿段子来说的话，奶酪量可以相比脑容量了，自身就没啥奶酪，结果还要开洞&#x2F;😢😢）</p><p>​要搭建个博客，直到最近我都认为，搭建博客，需要买个服务器，注册域名，虽然不是必要的，但是有个属于自己的网址确实cool😎，然后找个网页模板就开始改（虽然确实没啥问题），最后将网页上传到服务器就够了。一开始确实是这么认为的，脑子里只有html，CSS，JS的一点概念我就屁颠屁颠来直接开整了，现在网络能拿到很多教程资源（感谢开源！），<del>但依旧磕磕绊绊换了无数个主题弄了个三天</del>，找免费图床,建反向代理，期中了解下node.js，和PHP，虽然有wordpress（这个虽然很方便也有很多现成的方案，但是也需要些折腾，<del>主要是不想买服务器,想白嫖</del>，而且在国内需要建站域名和网站都需要备案），最终选择了基于hexo的fluid的主题，期间用也有试过自建主题，发现需要了解的东西很多，从零开始写CSS和JS也太折磨我了，虽然我怕麻烦，但是为了解决gitalk的porxy代理问题花了一天时间找了的免费的无服务构建应用平台和免费好使的评论，最后做了一大堆查找了一大堆，才回过神，<strong>卧槽!我一开始不是只想找个地方记录我的平常的学习进度么？</strong></p>]]></content>
    
    
    <categories>
      
      <category>日常杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网上冲浪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章的技巧</title>
    <link href="/2022/06/25/hello-world/"/>
    <url>/2022/06/25/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​第一次利用Typora编写Md文件并且发布博客，有很多操作还是非常生疏，在这里记录个Md文件的文章编辑的常用代码。以供我啥时候突然给整忘了回来看看😁</p><p>​<span id="more"></span></p><p>&#96;                      </p><h3 id="文章阅读截止"><a href="#文章阅读截止" class="headerlink" title="文章阅读截止"></a>文章阅读截止</h3><p>​将过长的文章截取，只显示代码上方的文章内容，避免文章过长的显示在博客主页（这个可以说是非常常用）</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- more --&gt;<br></code></pre></td></tr></table></figure><h3 id="文章的新建命令"><a href="#文章的新建命令" class="headerlink" title="文章的新建命令"></a>文章的新建命令</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>​在github bash 中使用 该指令可以新建一个页面：</p><p>​使用实例如下 ：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> 标题<br></code></pre></td></tr></table></figure><p>​可以在hexo根文件的中的_post的文件夹中发现新建了一个标题.md，头部信息如下</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: 标题<br>date: //时间<br><span class="hljs-keyword">tags:</span> //标签<br>categories:  //分类<br></code></pre></td></tr></table></figure><h3 id="草稿的新建命令"><a href="#草稿的新建命令" class="headerlink" title="草稿的新建命令"></a>草稿的新建命令</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> draft <span class="hljs-built_in">title</span><br></code></pre></td></tr></table></figure><p>​在github bash 中使用 该指令可以新建一个草稿：</p><p>​使用实例如下 ：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">draft</span> 标题<br></code></pre></td></tr></table></figure><p>​可以在hexo根文件的中的_drafts的文件夹中发现新建了一个标题.md头部的信息如下</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: 标题<br>date: //时间<br><span class="hljs-keyword">tags:</span> //标签<br>categories:  //分类<br></code></pre></td></tr></table></figure><p>​草稿不会显示在博客中，想要看到博客草稿需要在github bash 中使用如下指令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s -draft</span><br></code></pre></td></tr></table></figure><p>​该指令的作用除了在本地运行博客部署以外，可以在博客中访问草稿.</p><h3 id="front-Matter"><a href="#front-Matter" class="headerlink" title="front  Matter"></a>front  Matter</h3><p><img src="https://blog-1253996024.cos.ap-beijing.myqcloud.com//20200916181236318.png"></p><p>​每个创建的MD文件都在头端插入了名为front  Matter预定义读取参数,就是上文所说的头部信息。<br>​可以看见这张图是有水印的，我们可以利用MD的文件中的画图代码画出相同的信息：</p><center><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">layout</td><td align="center">布局</td><td align="center">无</td></tr><tr><td align="center">title</td><td align="center">标题</td><td align="center">无</td></tr><tr><td align="center">date</td><td align="center">建立的日期</td><td align="center">文件建立日期</td></tr><tr><td align="center">update</td><td align="center">更新的日期</td><td align="center">每次文件更新的日期</td></tr><tr><td align="center">comments</td><td align="center">该文章的评论功能</td><td align="center">默认每个文章开启</td></tr><tr><td align="center">tags</td><td align="center">标签</td><td align="center">无</td></tr><tr><td align="center">categories</td><td align="center">分类</td><td align="center">无</td></tr></tbody></table></center>]]></content>
    
    
    <categories>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>md</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
